<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/blog/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="关系型数据库基本原理 本文所述内容主要针对的是关系型数据库，nosql 数据库并不适用。    1. 索引 1.1. 索引的优点和缺点 1.2. 索引类型 1.3. 索引数据结构 1.4. 索引原则   2. 事务 2.1. ACID 2.2. 并发一致性问题 2.3. 事务隔离级别 2.4. 死锁   3. 并发控制 3.1. 锁粒度 3.2. 数据库锁的类型 3.3. 数据库锁的协议   4.">
<meta property="og:type" content="article">
<meta property="og:title" content="关系型数据库基本原理">
<meta property="og:url" content="https://dunwu.github.io/2019/03/06/database/sql/关系型数据库基本原理/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:description" content="关系型数据库基本原理 本文所述内容主要针对的是关系型数据库，nosql 数据库并不适用。    1. 索引 1.1. 索引的优点和缺点 1.2. 索引类型 1.3. 索引数据结构 1.4. 索引原则   2. 事务 2.1. ACID 2.2. 并发一致性问题 2.3. 事务隔离级别 2.4. 死锁   3. 并发控制 3.1. 锁粒度 3.2. 数据库锁的类型 3.3. 数据库锁的协议   4.">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/B-TREE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/B+TREE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/带有顺序访问指针的B+Tree.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库事务.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库ACID.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-丢失修改.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-脏数据.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-不可重复读.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-幻读.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_insert.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_delete.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_update.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库水平拆分.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库垂直拆分.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库范式.png">
<meta property="og:updated_time" content="2019-03-06T08:43:45.533Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关系型数据库基本原理">
<meta name="twitter:description" content="关系型数据库基本原理 本文所述内容主要针对的是关系型数据库，nosql 数据库并不适用。    1. 索引 1.1. 索引的优点和缺点 1.2. 索引类型 1.3. 索引数据结构 1.4. 索引原则   2. 事务 2.1. ACID 2.2. 并发一致性问题 2.3. 事务隔离级别 2.4. 死锁   3. 并发控制 3.1. 锁粒度 3.2. 数据库锁的类型 3.3. 数据库锁的协议   4.">
<meta name="twitter:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/B-TREE.png">



  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">




  <link rel="canonical" href="https://dunwu.github.io/2019/03/06/database/sql/关系型数据库基本原理/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>关系型数据库基本原理 | 张鹏的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
            
            
            
              
              

  
  
    
  
  <li class="menu-item menu-item-docs">

    
    
    
      
    

    

    <a href="/blog/docs/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i> <br>docs</a>

  </li>


            
          
            
            
            
          
        

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2019/03/06/database/sql/关系型数据库基本原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">关系型数据库基本原理<a href="https://github.com/dunwu/blog/blob/master/source/_posts/database/sql/关系型数据库基本原理.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-06 00:00:00 / 修改时间：16:43:45" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">2019-03-06</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">14k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">13 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="关系型数据库基本原理"><a href="#关系型数据库基本原理" class="headerlink" title="关系型数据库基本原理"></a>关系型数据库基本原理</h1><blockquote>
<p>本文所述内容主要针对的是关系型数据库，nosql 数据库并不适用。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-索引">1. 索引</a><ul>
<li><a href="#11-索引的优点和缺点">1.1. 索引的优点和缺点</a></li>
<li><a href="#12-索引类型">1.2. 索引类型</a></li>
<li><a href="#13-索引数据结构">1.3. 索引数据结构</a></li>
<li><a href="#14-索引原则">1.4. 索引原则</a></li>
</ul>
</li>
<li><a href="#2-事务">2. 事务</a><ul>
<li><a href="#21-acid">2.1. ACID</a></li>
<li><a href="#22-并发一致性问题">2.2. 并发一致性问题</a></li>
<li><a href="#23-事务隔离级别">2.3. 事务隔离级别</a></li>
<li><a href="#24-死锁">2.4. 死锁</a></li>
</ul>
</li>
<li><a href="#3-并发控制">3. 并发控制</a><ul>
<li><a href="#31-锁粒度">3.1. 锁粒度</a></li>
<li><a href="#32-数据库锁的类型">3.2. 数据库锁的类型</a></li>
<li><a href="#33-数据库锁的协议">3.3. 数据库锁的协议</a></li>
</ul>
</li>
<li><a href="#4-多版本并发控制">4. 多版本并发控制</a><ul>
<li><a href="#41-版本号">4.1. 版本号</a></li>
<li><a href="#42-undo-日志">4.2. Undo 日志</a></li>
<li><a href="#43-实现过程">4.3. 实现过程</a></li>
<li><a href="#44-快照读与当前读">4.4. 快照读与当前读</a></li>
</ul>
</li>
<li><a href="#5-分库分表">5. 分库分表</a><ul>
<li><a href="#51-水平拆分">5.1. 水平拆分</a></li>
<li><a href="#52-垂直拆分">5.2. 垂直拆分</a></li>
<li><a href="#53-sharding-策略">5.3. Sharding 策略</a></li>
<li><a href="#54-分库分表的问题及解决方案">5.4. 分库分表的问题及解决方案</a></li>
<li><a href="#55-常用的分库分表中间件">5.5. 常用的分库分表中间件</a></li>
</ul>
</li>
<li><a href="#6-sql-优化">6. sql 优化</a><ul>
<li><a href="#61-使用执行计划进行分析">6.1. 使用执行计划进行分析</a></li>
<li><a href="#62-优化数据访问">6.2. 优化数据访问</a></li>
<li><a href="#63-重构查询方式">6.3. 重构查询方式</a></li>
</ul>
</li>
<li><a href="#7-关系数据库设计理论">7. 关系数据库设计理论</a><ul>
<li><a href="#71-函数依赖">7.1. 函数依赖</a></li>
<li><a href="#72-异常">7.2. 异常</a></li>
<li><a href="#73-范式">7.3. 范式</a></li>
</ul>
</li>
<li><a href="#8-er-图">8. ER 图</a><ul>
<li><a href="#81-实体的三种联系">8.1. 实体的三种联系</a></li>
<li><a href="#82-表示出现多次的关系">8.2. 表示出现多次的关系</a></li>
<li><a href="#83-联系的多向性">8.3. 联系的多向性</a></li>
<li><a href="#84-表示子类">8.4. 表示子类</a></li>
</ul>
</li>
<li><a href="#9-资料">9. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h2><p>索引能够轻易将查询性能提升几个数量级。</p>
<ul>
<li>数据量小的表，使用全表扫描比建立索引更高效。</li>
<li>数据量大的表，使用索引更高效。</li>
<li>数据量特大的表，建立和维护索引的代价将会随之增长，可以使用分区技术。</li>
</ul>
<h3 id="1-1-索引的优点和缺点"><a href="#1-1-索引的优点和缺点" class="headerlink" title="1.1. 索引的优点和缺点"></a>1.1. 索引的优点和缺点</h3><p>优点：</p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机 I/O 变为顺序 I/O。</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h3 id="1-2-索引类型"><a href="#1-2-索引类型" class="headerlink" title="1.2. 索引类型"></a>1.2. 索引类型</h3><p>主流的关系型数据库一般都支持以下索引类型：</p>
<ul>
<li>普通索引：最基本的索引，没有任何限制。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>
<li>主键索引：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</li>
<li>组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</li>
</ul>
<h3 id="1-3-索引数据结构"><a href="#1-3-索引数据结构" class="headerlink" title="1.3. 索引数据结构"></a>1.3. 索引数据结构</h3><p><strong>主流数据库的索引一般使用的数据结构为：B-Tree 或 B+Tree。</strong></p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>B-Tree 不同于 Binary Tree（二叉树，最多有两个子树），它是平衡搜索树。</p>
<p>一棵 M 阶的 B-Tree 满足以下条件：</p>
<ul>
<li>每个结点至多有 M 个孩子；</li>
<li>除根结点和叶结点外，其它每个结点至少有 M/2 个孩子；</li>
<li>根结点至少有两个孩子（除非该树仅包含一个结点）；</li>
<li>所有叶结点在同一层，叶结点不包含任何关键字信息；</li>
<li>有 K 个关键字的非叶结点恰好包含 K+1 个孩子；</li>
</ul>
<p>对于任意结点，其内部的关键字 Key 是升序排列的。每个节点中都包含了 data。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/B-TREE.png"><br></div>

<p>对于每个结点，主要包含一个关键字数组 Key[]，一个指针数组（指向儿子）Son[]。</p>
<p>在 B-Tree 内，查找的流程是：</p>
<ol>
<li>使用顺序查找（数组长度较短时）或折半查找方法查找 Key[]数组，若找到关键字 K，则返回该结点的地址及 K 在 Key[]中的位置；</li>
<li>否则，可确定 K 在某个 Key[i]和 Key[i+1]之间，则从 Son[i]所指的子结点继续查找，直到在某结点中查找成功；</li>
<li>或直至找到叶结点且叶结点中的查找仍不成功时，查找过程失败。</li>
</ol>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B+Tree 是 B-Tree 的变种：</p>
<ul>
<li>每个节点的指针上限为 2d 而不是 2d+1（d 为节点的出度）。</li>
<li>非叶子节点不存储 data，只存储 key；叶子节点不存储指针。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/B+TREE.png"><br></div>

<p>由于并不是所有节点都具有相同的域，因此 B+Tree 中叶节点和内节点一般大小不同。这点与 B-Tree 不同，虽然 B-Tree 中不同节点存放的 key 和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中 B-Tree 往往对每个节点申请同等大小的空间。</p>
<h5 id="带有顺序访问指针的-B-Tree"><a href="#带有顺序访问指针的-B-Tree" class="headerlink" title="带有顺序访问指针的 B+Tree"></a>带有顺序访问指针的 B+Tree</h5><p>一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 的基础上进行了优化，增加了顺序访问指针。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/带有顺序访问指针的B+Tree.png"><br></div>

<p>在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree。</p>
<p>这个优化的目的是为了提高区间访问的性能，例如上图中如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Hash 索引只有精确匹配索引所有列的查询才有效。</p>
<p>对于每一行数据，对所有的索引列计算一个 hashcode。哈希索引将所有的 hashcode 存储在索引中，同时在 Hash 表中保存指向每个数据行的指针。</p>
<p>哈希索引的优点：</p>
<ul>
<li>因为索引数据结构紧凑，所以查询速度非常快。</li>
</ul>
<p>哈希索引的缺点：</p>
<ul>
<li>哈希索引数据不是按照索引值顺序存储的，所以无法用于排序。</li>
<li>哈希索引不支持部分索引匹配查找。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li>哈希索引只支持等值比较查询，不支持任何范围查询，如 WHERE price &gt; 100。</li>
<li>哈希索引有可能出现哈希冲突，出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
</ul>
<h3 id="1-4-索引原则"><a href="#1-4-索引原则" class="headerlink" title="1.4. 索引原则"></a>1.4. 索引原则</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>如果查询中的列不是独立的列，则数据库不会使用索引。</p>
<p>“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。</p>
<p>:x: 错误示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(CURRENT_DAT) - <span class="keyword">TO_DAYS</span>(date_col) &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>有时候需要索引很长的字符列，这会让索引变得大且慢。</p>
<p>解决方法是：可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。</p>
<p>索引的选择性是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<p>对于 BLOB/TEXT/VARCHAR 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p>
<p>要选择足够长的前缀以保证较高的选择性，同时又不能太长（节约空间）。</p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>不要为每个列创建独立的索引。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>经验法则：将选择性高的列或基数大的列优先排在多列索引最前列。</p>
<p>但有时，也需要考虑 WHERE 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>聚簇表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>索引最好既满足排序，又用于查找行。这样，就可以使用索引来对结果排序。</p>
<h4 id="和-in-可以乱序"><a href="#和-in-可以乱序" class="headerlink" title="= 和 in 可以乱序"></a>= 和 in 可以乱序</h4><p>比如 a = 1 and b = 2 and c = 3 建立（a,b,c）索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。</p>
<h4 id="尽量的扩展索引，不要新建索引"><a href="#尽量的扩展索引，不要新建索引" class="headerlink" title="尽量的扩展索引，不要新建索引"></a>尽量的扩展索引，不要新建索引</h4><p>比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2. 事务"></a>2. 事务</h2><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库事务.png"><br></div>

<p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<h3 id="2-1-ACID"><a href="#2-1-ACID" class="headerlink" title="2.1. ACID"></a>2.1. ACID</h3><h4 id="原子性（Automicity）"><a href="#原子性（Automicity）" class="headerlink" title="原子性（Automicity）"></a>原子性（Automicity）</h4><p>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。</p>
<p>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</p>
<h4 id="ACID-小结"><a href="#ACID-小结" class="headerlink" title="ACID 小结"></a>ACID 小结</h4><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库奔溃的情况。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库ACID.png"><br></div>

<h3 id="2-2-并发一致性问题"><a href="#2-2-并发一致性问题" class="headerlink" title="2.2. 并发一致性问题"></a>2.2. 并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-丢失修改.png"><br></div>

<h4 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h4><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-脏数据.png"><br></div>

<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-不可重复读.png"><br></div>

<h4 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h4><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-幻读.png"><br></div>

<h4 id="并发一致性解决方案"><a href="#并发一致性解决方案" class="headerlink" title="并发一致性解决方案"></a>并发一致性解决方案</h4><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p>
<p>并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h3 id="2-3-事务隔离级别"><a href="#2-3-事务隔离级别" class="headerlink" title="2.3. 事务隔离级别"></a>2.3. 事务隔离级别</h3><ul>
<li>未提交读（READ UNCOMMITTED） - 事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>提交读（READ COMMITTED） - 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li>可重复读（REPEATABLE READ） - 保证在同一个事务中多次读取同样数据的结果是一样的。</li>
<li>可串行化（SERIALIXABLE） - 强制事务串行执行。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">提交读</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">可串行化</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
</tbody>
</table>
<h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4. 死锁"></a>2.4. 死锁</h3><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定一个资源时，也会产生死锁。</p>
<h2 id="3-并发控制"><a href="#3-并发控制" class="headerlink" title="3. 并发控制"></a>3. 并发控制</h2><p>无论何时，只要有多个查询需要在同一时刻修改数据，就会产生并发控制的问题。</p>
<h3 id="3-1-锁粒度"><a href="#3-1-锁粒度" class="headerlink" title="3.1. 锁粒度"></a>3.1. 锁粒度</h3><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</p>
<p>但是加锁需要消耗资源，锁的各种操作，包括获取锁、释放锁、以及检查锁状态等，都会增加系统开销。因此锁粒度越小，系统开销就越大。</p>
<p>所谓锁策略，就是在锁的开销和并发程度之间寻求平衡，这种平衡自然也会影响到性能。</p>
<p>很多数据库都提供了表级锁和行级锁。</p>
<ul>
<li><strong>表级锁（table lock）</strong> - 锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。</li>
<li><strong>行级锁（row lock）</strong> - 仅对指定的行记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。</li>
</ul>
<h3 id="3-2-数据库锁的类型"><a href="#3-2-数据库锁的类型" class="headerlink" title="3.2. 数据库锁的类型"></a>3.2. 数据库锁的类型</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">S</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">IX</th>
<th style="text-align:center">S</th>
<th style="text-align:center">IS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">IX</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">IS</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h3 id="3-3-数据库锁的协议"><a href="#3-3-数据库锁的协议" class="headerlink" title="3.3. 数据库锁的协议"></a>3.3. 数据库锁的协议</h3><h4 id="三级锁协议"><a href="#三级锁协议" class="headerlink" title="三级锁协议"></a>三级锁协议</h4><p><strong>一级锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=21</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-x(A)</td>
</tr>
</tbody>
</table>
<p><strong>二级锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-s(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">rollback</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-s(A)</td>
</tr>
</tbody>
</table>
<p><strong>三级锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-s(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-s(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-X(A)</td>
</tr>
</tbody>
</table>
<h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>
<h2 id="4-多版本并发控制"><a href="#4-多版本并发控制" class="headerlink" title="4. 多版本并发控制"></a>4. 多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是实现隔离级别的一种具体方式。</p>
<p>Mysql、Oracle、PostgreSQL 等数据库都实现了 MVCC，但各自的实现机制不尽相同。</p>
<p>MVCC 用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p>MVCC 可以视为行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。</p>
<p>MVCC 的实现，是通过保存数据在某个时间的快照来实现的。</p>
<h3 id="4-1-版本号"><a href="#4-1-版本号" class="headerlink" title="4.1. 版本号"></a>4.1. 版本号</h3><ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<h3 id="4-2-Undo-日志"><a href="#4-2-Undo-日志" class="headerlink" title="4.2. Undo 日志"></a>4.2. Undo 日志</h3><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<h3 id="4-3-实现过程"><a href="#4-3-实现过程" class="headerlink" title="4.3. 实现过程"></a>4.3. 实现过程</h3><p>以下实现过程针对可重复读隔离级别。</p>
<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p>
<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。</p>
<p>除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p>将当前系统版本号作为数据行快照的创建版本号。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_insert.png"><br></div>

<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>将当前系统版本号作为数据行快照的删除版本号。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_delete.png"><br></div>

<h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>将当前系统版本号作为更新后的数据行快照的创建版本号，同时将当前系统版本号作为更新前的数据行快照的删除版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_update.png"><br></div>

<h3 id="4-4-快照读与当前读"><a href="#4-4-快照读与当前读" class="headerlink" title="4.4. 快照读与当前读"></a>4.4. 快照读与当前读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-分库分表"><a href="#5-分库分表" class="headerlink" title="5. 分库分表"></a>5. 分库分表</h2><p>分库分表的基本思想就要把一个数据库切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。</p>
<p>当然，现实中更多是这两种情况混杂在一起，这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列。</p>
<h3 id="5-1-水平拆分"><a href="#5-1-水平拆分" class="headerlink" title="5.1. 水平拆分"></a>5.1. 水平拆分</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库水平拆分.jpg" width="500"><br></div>

<p>对于海量数据的数据库，如果表并不多，但每张表的数据非常多，这时候适合水平切分，即把表的数据按某种规则（比如按 ID 散列）切分到多个数据库(server)上。</p>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<h3 id="5-2-垂直拆分"><a href="#5-2-垂直拆分" class="headerlink" title="5.2. 垂直拆分"></a>5.2. 垂直拆分</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库垂直拆分.jpg" width="500"><br></div>

<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个 server 上。</p>
<h3 id="5-3-Sharding-策略"><a href="#5-3-Sharding-策略" class="headerlink" title="5.3. Sharding 策略"></a>5.3. Sharding 策略</h3><ul>
<li>哈希取模：hash(key) % NUM_DB</li>
<li>范围：可以是 ID 范围也可以是时间范围</li>
<li>映射表：使用单独的一个数据库来存储映射关系</li>
</ul>
<h3 id="5-4-分库分表的问题及解决方案"><a href="#5-4-分库分表的问题及解决方案" class="headerlink" title="5.4. 分库分表的问题及解决方案"></a>5.4. 分库分表的问题及解决方案</h3><h4 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h4><p>方案一：使用分布式事务</p>
<ul>
<li>优点：交由数据库管理，简单有效</li>
<li>缺点：性能代价高，特别是 shard 越来越多时</li>
</ul>
<p>方案二：由应用程序和数据库共同控制</p>
<ul>
<li>原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。</li>
<li>优点：性能上有优势</li>
<li>缺点：需要应用程序在事务控制上做灵活设计。如果使用了 spring 的事务管理，改动起来会面临一定的困难。</li>
</ul>
<h4 id="跨节点-Join-的问题"><a href="#跨节点-Join-的问题" class="headerlink" title="跨节点 Join 的问题"></a>跨节点 Join 的问题</h4><p>只要是进行切分，跨节点 Join 的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的 id，根据这些 id 发起第二次请求得到关联数据。</p>
<h4 id="跨节点的-count-order-by-group-by-以及聚合函数问题"><a href="#跨节点的-count-order-by-group-by-以及聚合函数问题" class="headerlink" title="跨节点的 count,order by,group by 以及聚合函数问题"></a>跨节点的 count,order by,group by 以及聚合函数问题</h4><p>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。</p>
<p>解决方案：与解决跨节点 join 问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和 join 不同的是每个节点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
<h4 id="ID-唯一性"><a href="#ID-唯一性" class="headerlink" title="ID 唯一性"></a>ID 唯一性</h4><p>一旦数据库被切分到多个物理节点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID，以便进行 SQL 路由。</p>
<p>一些常见的主键生成策略：</p>
<ul>
<li>使用全局唯一 ID：GUID。</li>
<li>为每个分片指定一个 ID 范围。</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)。</li>
</ul>
<h4 id="数据迁移，容量规划，扩容等问题"><a href="#数据迁移，容量规划，扩容等问题" class="headerlink" title="数据迁移，容量规划，扩容等问题"></a>数据迁移，容量规划，扩容等问题</h4><p>来自淘宝综合业务平台团队，它利用对 2 的倍数取余具有向前兼容的特性（如对 4 取余得 1 的数对 2 取余也是 1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了 Sharding 扩容的难度。</p>
<h4 id="分库数量"><a href="#分库数量" class="headerlink" title="分库数量"></a>分库数量</h4><p>分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。</p>
<h4 id="跨分片的排序分页"><a href="#跨分片的排序分页" class="headerlink" title="跨分片的排序分页"></a>跨分片的排序分页</h4><ul>
<li>如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</li>
<li>如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</li>
<li>分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</li>
</ul>
<h3 id="5-5-常用的分库分表中间件"><a href="#5-5-常用的分库分表中间件" class="headerlink" title="5.5. 常用的分库分表中间件"></a>5.5. 常用的分库分表中间件</h3><h4 id="简单易用的组件："><a href="#简单易用的组件：" class="headerlink" title="简单易用的组件："></a>简单易用的组件：</h4><ul>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="noopener">当当 sharding-jdbc</a></li>
<li><a href="https://github.com/baihui212/tsharding" target="_blank" rel="noopener">蘑菇街 TSharding</a></li>
</ul>
<h4 id="强悍重量级的中间件："><a href="#强悍重量级的中间件：" class="headerlink" title="强悍重量级的中间件："></a>强悍重量级的中间件：</h4><ul>
<li><a href="https://github.com/go-pg/sharding" target="_blank" rel="noopener">sharding </a></li>
<li><a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">TDDL Smart Client 的方式（淘宝）</a></li>
<li><a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">Atlas(Qihoo 360)</a></li>
<li><a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">alibaba.cobar(是阿里巴巴（B2B）部门开发)</a></li>
<li><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">MyCAT（基于阿里开源的 Cobar 产品而研发）</a></li>
<li><a href="https://github.com/58code/Oceanus" target="_blank" rel="noopener">Oceanus(58 同城数据库中间件)</a></li>
<li><a href="http://www.cnblogs.com/youge-OneSQL/articles/4208583.html" target="_blank" rel="noopener">OneProxy(支付宝首席架构师楼方鑫开发)</a></li>
<li><a href="https://github.com/youtube/vitess" target="_blank" rel="noopener">vitess（谷歌开发的数据库中间件）</a></li>
</ul>
<h2 id="6-sql-优化"><a href="#6-sql-优化" class="headerlink" title="6. sql 优化"></a>6. sql 优化</h2><h3 id="6-1-使用执行计划进行分析"><a href="#6-1-使用执行计划进行分析" class="headerlink" title="6.1. 使用执行计划进行分析"></a>6.1. 使用执行计划进行分析</h3><p>执行计划 Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<p>更多内容请参考：<a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p>
<h3 id="6-2-优化数据访问"><a href="#6-2-优化数据访问" class="headerlink" title="6.2. 优化数据访问"></a>6.2. 优化数据访问</h3><h4 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h4><p>（一）只返回必要的列</p>
<p>最好不要使用 SELECT * 语句。</p>
<p>（二）只返回必要的行</p>
<p>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。</p>
<p>（三）缓存重复查询的数据</p>
<p>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。</p>
<h4 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p>
<h3 id="6-3-重构查询方式"><a href="#6-3-重构查询方式" class="headerlink" title="6.3. 重构查询方式"></a>6.3. 重构查询方式</h3><h4 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h4><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELEFT FROM messages WHERE <span class="keyword">create</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">rows_affected = <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    <span class="string">"<span class="keyword">DELETE</span> FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; while rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h4><p>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id=tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>
<h2 id="7-关系数据库设计理论"><a href="#7-关系数据库设计理论" class="headerlink" title="7. 关系数据库设计理论"></a>7. 关系数据库设计理论</h2><h3 id="7-1-函数依赖"><a href="#7-1-函数依赖" class="headerlink" title="7.1. 函数依赖"></a>7.1. 函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖；</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递依赖。</p>
<h3 id="7-2-异常"><a href="#7-2-异常" class="headerlink" title="7.2. 异常"></a>7.2. 异常</h3><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 学生-2 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li>
<li>插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h3 id="7-3-范式"><a href="#7-3-范式" class="headerlink" title="7.3. 范式"></a>7.3. 范式</h3><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库范式.png"><br></div>

<h4 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 (1NF)"></a>第一范式 (1NF)</h4><p>属性不可分；</p>
<h4 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 (2NF)"></a>第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><font size="4"> <strong>分解前</strong> </font><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><font size="4"> <strong>分解后</strong> </font><br></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept, Mname</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade</li>
</ul>
<h4 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 (3NF)"></a>第三范式 (3NF)</h4><p>非主属性不传递依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<h2 id="8-ER-图"><a href="#8-ER-图" class="headerlink" title="8. ER 图"></a>8. ER 图</h2><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h3 id="8-1-实体的三种联系"><a href="#8-1-实体的三种联系" class="headerlink" title="8.1. 实体的三种联系"></a>8.1. 实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p>
<p>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。</p>
<h3 id="8-2-表示出现多次的关系"><a href="#8-2-表示出现多次的关系" class="headerlink" title="8.2. 表示出现多次的关系"></a>8.2. 表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<h3 id="8-3-联系的多向性"><a href="#8-3-联系的多向性" class="headerlink" title="8.3. 联系的多向性"></a>8.3. 联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<p>一般只使用二元联系，可以把多元关系转换为二元关系。</p>
<h3 id="8-4-表示子类"><a href="#8-4-表示子类" class="headerlink" title="8.4. 表示子类"></a>8.4. 表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<h2 id="9-资料"><a href="#9-资料" class="headerlink" title="9. 资料"></a>9. 资料</h2><ul>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/数据库系统原理.md" target="_blank" rel="noopener">数据库系统原理</a></li>
<li><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">分库分表需要考虑的问题及方案</a></li>
<li><a href="https://blog.csdn.net/bluishglc/article/details/7710738" target="_blank" rel="noopener">数据库分库分表(sharding)系列(二) 全局主键生成策略</a></li>
<li><a href="https://blog.csdn.net/bluishglc/article/details/7970268" target="_blank" rel="noopener">一种支持自由规划无须数据迁移和修改路由代码的 Sharding 扩容方案</a></li>
</ul>

      
    </div>

    
      


    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2019/03/06/programming/java/javaweb/javaee/jsp/taglib/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2019/03/06/programming/shell/" rel="prev" title="一篇文章让你彻底掌握 shell 语言">
                一篇文章让你彻底掌握 shell 语言 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">381</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/blog/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/blog/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">76</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/dunwu" title="GitHub &rarr; https://github.com/dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:forbreak@163.com" title="E-Mail &rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关系型数据库基本原理"><span class="nav-text">关系型数据库基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-索引"><span class="nav-text">1. 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-索引的优点和缺点"><span class="nav-text">1.1. 索引的优点和缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-索引类型"><span class="nav-text">1.2. 索引类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-索引数据结构"><span class="nav-text">1.3. 索引数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Tree"><span class="nav-text">B-Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Tree-1"><span class="nav-text">B+Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash"><span class="nav-text">Hash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-索引原则"><span class="nav-text">1.4. 索引原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#独立的列"><span class="nav-text">独立的列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前缀索引和索引选择性"><span class="nav-text">前缀索引和索引选择性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多列索引"><span class="nav-text">多列索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择合适的索引列顺序"><span class="nav-text">选择合适的索引列顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚簇索引"><span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖索引"><span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用索引扫描来做排序"><span class="nav-text">使用索引扫描来做排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#和-in-可以乱序"><span class="nav-text">= 和 in 可以乱序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#尽量的扩展索引，不要新建索引"><span class="nav-text">尽量的扩展索引，不要新建索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-事务"><span class="nav-text">2. 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-ACID"><span class="nav-text">2.1. ACID</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性（Automicity）"><span class="nav-text">原子性（Automicity）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性（Consistency）"><span class="nav-text">一致性（Consistency）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隔离性（Isolation）"><span class="nav-text">隔离性（Isolation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#持久性（Durability）"><span class="nav-text">持久性（Durability）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID-小结"><span class="nav-text">ACID 小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-并发一致性问题"><span class="nav-text">2.2. 并发一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#丢失修改"><span class="nav-text">丢失修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#脏数据"><span class="nav-text">脏数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可重复读"><span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#幻影读"><span class="nav-text">幻影读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发一致性解决方案"><span class="nav-text">并发一致性解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-事务隔离级别"><span class="nav-text">2.3. 事务隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-死锁"><span class="nav-text">2.4. 死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-并发控制"><span class="nav-text">3. 并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-锁粒度"><span class="nav-text">3.1. 锁粒度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-数据库锁的类型"><span class="nav-text">3.2. 数据库锁的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#读写锁"><span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#意向锁"><span class="nav-text">意向锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-数据库锁的协议"><span class="nav-text">3.3. 数据库锁的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三级锁协议"><span class="nav-text">三级锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两段锁协议"><span class="nav-text">两段锁协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-多版本并发控制"><span class="nav-text">4. 多版本并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-版本号"><span class="nav-text">4.1. 版本号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Undo-日志"><span class="nav-text">4.2. Undo 日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-实现过程"><span class="nav-text">4.3. 实现过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT"><span class="nav-text">SELECT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#INSERT"><span class="nav-text">INSERT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DELETE"><span class="nav-text">DELETE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UPDATE"><span class="nav-text">UPDATE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-快照读与当前读"><span class="nav-text">4.4. 快照读与当前读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#快照读"><span class="nav-text">快照读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当前读"><span class="nav-text">当前读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-分库分表"><span class="nav-text">5. 分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-水平拆分"><span class="nav-text">5.1. 水平拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-垂直拆分"><span class="nav-text">5.2. 垂直拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Sharding-策略"><span class="nav-text">5.3. Sharding 策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-分库分表的问题及解决方案"><span class="nav-text">5.4. 分库分表的问题及解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事务问题"><span class="nav-text">事务问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨节点-Join-的问题"><span class="nav-text">跨节点 Join 的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨节点的-count-order-by-group-by-以及聚合函数问题"><span class="nav-text">跨节点的 count,order by,group by 以及聚合函数问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ID-唯一性"><span class="nav-text">ID 唯一性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据迁移，容量规划，扩容等问题"><span class="nav-text">数据迁移，容量规划，扩容等问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分库数量"><span class="nav-text">分库数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨分片的排序分页"><span class="nav-text">跨分片的排序分页</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-常用的分库分表中间件"><span class="nav-text">5.5. 常用的分库分表中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单易用的组件："><span class="nav-text">简单易用的组件：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强悍重量级的中间件："><span class="nav-text">强悍重量级的中间件：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-sql-优化"><span class="nav-text">6. sql 优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-使用执行计划进行分析"><span class="nav-text">6.1. 使用执行计划进行分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-优化数据访问"><span class="nav-text">6.2. 优化数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#减少请求的数据量"><span class="nav-text">减少请求的数据量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#减少服务器端扫描的行数"><span class="nav-text">减少服务器端扫描的行数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-重构查询方式"><span class="nav-text">6.3. 重构查询方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#切分大查询"><span class="nav-text">切分大查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分解大连接查询"><span class="nav-text">分解大连接查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-关系数据库设计理论"><span class="nav-text">7. 关系数据库设计理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-函数依赖"><span class="nav-text">7.1. 函数依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-异常"><span class="nav-text">7.2. 异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-范式"><span class="nav-text">7.3. 范式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一范式-1NF"><span class="nav-text">第一范式 (1NF)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二范式-2NF"><span class="nav-text">第二范式 (2NF)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三范式-3NF"><span class="nav-text">第三范式 (3NF)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-ER-图"><span class="nav-text">8. ER 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-实体的三种联系"><span class="nav-text">8.1. 实体的三种联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-表示出现多次的关系"><span class="nav-text">8.2. 表示出现多次的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-联系的多向性"><span class="nav-text">8.3. 联系的多向性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-表示子类"><span class="nav-text">8.4. 表示子类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-资料"><span class="nav-text">9. 资料</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.1m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">31:18</span>
  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>











  



  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/blog/js/src/utils.js?v=7.0.1"></script>

  <script src="/blog/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/blog/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/blog/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/blog/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/blog/js/src/bootstrap.js?v=7.0.1"></script>


  
  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      
        background-color: #eee;
        background-image: linear-gradient(#fcfcfc, #eee);
        border: 1px solid #d5d5d5;
        border-radius: 3px;
      
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      
        right: 4px;
        top: 8px;
      
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1;
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; // Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.readOnly = true;
        ta.value = code;
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, code.length);
        ta.readOnly = false;
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); // For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


</body>
</html>
