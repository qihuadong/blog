<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张鹏的博客</title>
  
  <subtitle>大道至简，知易行难</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://dunwu.github.io/"/>
  <updated>2019-03-06T08:43:45.844Z</updated>
  <id>https://dunwu.github.io/</id>
  
  <author>
    <name>Zhang Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 快速入门</title>
    <link href="https://dunwu.github.io/2019/03/06/frontend/mvc/react/react/"/>
    <id>https://dunwu.github.io/2019/03/06/frontend/mvc/react/react/</id>
    <published>2019-03-06T08:38:11.317Z</published>
    <updated>2019-03-06T08:43:45.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-快速入门"><a href="#React-快速入门" class="headerlink" title="React 快速入门"></a>React 快速入门</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#安装">安装</a></li><li><a href="#introducing-jsx">Introducing JSX</a><ul><li><a href="#jsx-中嵌入表达式">JSX 中嵌入表达式</a></li><li><a href="#jsx-也是一个表达式">JSX 也是一个表达式</a></li><li><a href="#用-jsx-指定属性值">用 JSX 指定属性值</a></li><li><a href="#用-jsx-指定子元素">用 JSX 指定子元素</a></li><li><a href="#jsx-防止注入攻击">JSX 防止注入攻击</a></li><li><a href="#jsx-表示对象">JSX 表示对象</a></li></ul></li><li><a href="#渲染元素">渲染元素</a><ul><li><a href="#渲染一个元素到-dom">渲染一个元素到 DOM</a></li><li><a href="#更新已渲染的元素">更新已渲染的元素</a></li><li><a href="#react-只更新必需要更新的部分">React 只更新必需要更新的部分</a></li></ul></li><li><a href="#组件components-和-属性props">组件(Components) 和 属性(Props)</a><ul><li><a href="#函数式组件和类组件">函数式组件和类组件</a></li><li><a href="#渲染一个组件">渲染一个组件</a></li><li><a href="#构成组件">构成组件</a></li><li><a href="#提取组件">提取组件</a></li><li><a href="#props-是只读的">Props 是只读的</a></li></ul></li><li><a href="#把函数式组件转化为类组件">把函数式组件转化为类组件</a></li><li><a href="#在类组件中添加本地状态state">在类组件中添加本地状态(state)</a></li><li><a href="#在类中添加生命周期方法">在类中添加生命周期方法</a></li><li><a href="#正确地使用-state状态">正确地使用 State(状态)</a><ul><li><a href="#不要直接修改-state状态">不要直接修改 state(状态)</a></li><li><a href="#state状态-更新可能是异步的">state(状态) 更新可能是异步的</a></li><li><a href="#state状态更新会被合并">state(状态)更新会被合并</a></li></ul></li><li><a href="#数据向下流动">数据向下流动</a><ul><li><a href="#元素变量">元素变量</a></li><li><a href="#使用逻辑--操作符的内联-if-用法">使用逻辑 &amp;&amp; 操作符的内联 if 用法</a></li><li><a href="#使用条件操作符的内联-if-else">使用条件操作符的内联 If-Else</a></li><li><a href="#防止组件渲染">防止组件渲染</a></li><li><a href="#多组件渲染">多组件渲染</a></li><li><a href="#基本列表组件">基本列表组件</a></li></ul></li><li><a href="#键keys">键(Keys)</a><ul><li><a href="#使用-keys-提取组件">使用 keys 提取组件</a></li><li><a href="#keys-在同辈元素中必须是唯一的">keys 在同辈元素中必须是唯一的</a></li><li><a href="#在-jsx-中嵌入-map">在 JSX 中嵌入 map()</a></li></ul></li><li><a href="#受控组件controlled-components">受控组件(Controlled Components)</a></li><li><a href="#textare-标签">textare 标签</a></li><li><a href="#select-标签">select 标签</a></li><li><a href="#处理多个输入元素">处理多个输入元素</a></li><li><a href="#受控组件的替代方案">受控组件的替代方案</a></li><li><a href="#添加第二个输入">添加第二个输入</a></li><li><a href="#编写转换函数">编写转换函数</a></li><li><a href="#状态提升lifting-state-up">状态提升(Lifting State Up)</a></li><li><a href="#经验总结">经验总结</a></li><li><a href="#包含">包含</a></li><li><a href="#特例">特例</a></li><li><a href="#如何看待">如何看待？</a></li></ul><!-- /TOC --><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>直接下载使用</li></ol><p>React 可以直接下载使用，下载包中也提供了很多学习的实例。</p><p>你可以在官网  <a href="http://facebook.github.io/react/" target="_blank" rel="noopener">http://facebook.github.io/react/</a>  下载最新版。</p><ol start="2"><li>通过 npm 使用 React</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install -S react react-dom</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 yarn 使用 React</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn add react react-dom</span><br></pre></td></tr></table></figure><ol start="4"><li><p>使用各种快速构建工具</p><p>目前最流行的构建工具应该是 create-react-app，它使得用户可以通过命令就能快速构建 React 开发环境。</p><p>create-react-app 自动创建的项目是基于 Webpack + ES6 。</p></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br><span class="line">$ create-react-app my-app</span><br><span class="line">$ <span class="built_in">cd</span> my-app/</span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><h2 id="Introducing-JSX"><a href="#Introducing-JSX" class="headerlink" title="Introducing JSX"></a>Introducing JSX</h2><p>考虑一下这个变量的声明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>这种有趣的标签语法既不是字符串也不是 HTML。</p><p>这就是 JSX ，他是 JavaScrip 的一种扩展语法。我们推荐在 React 中使用这种语法来描述 UI 信息。JSX 可能会让你想起某种模板语言，但是它具有 JavaScrip 的全部能力。</p><p>JSX 可以生成 React “元素”。我们将在<a href="http://www.css88.com/react/docs/rendering-elements.html" target="_blank" rel="noopener">下一章</a>探索如何把它渲染到 DOM 上。下面你可以找到 JSX 的基础知识，以帮助您开始使用。</p><h3 id="JSX-中嵌入表达式"><a href="#JSX-中嵌入表达式" class="headerlink" title="JSX 中嵌入表达式"></a>JSX 中嵌入表达式</h3><p>你可以用 花括号 把任意的  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript 表达式</a>  嵌入到 JSX 中。</p><p>例如，<code>2 + 2</code>， <code>user.firstName</code>， 和  <code>formatName(user)</code>，这些都是可用的表达式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/PGEjdG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>为便于阅读，我们将 JSX 分割成多行。我们推荐使用括号将 JSX 包裹起来，虽然这不是必须的，但这样做可以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">分号自动插入</a>的陷阱。</p><h3 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h3><p>编译之后，JSX 表达式就变成了常规的 JavaScript 对象。</p><p>这意味着你可以在  <code>if</code>  语句或者是  <code>for</code>  循环中使用 JSX，用它给变量赋值，当做参数接收，或者作为函数的返回值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-JSX-指定属性值"><a href="#用-JSX-指定属性值" class="headerlink" title="用 JSX 指定属性值"></a>用 JSX 指定属性值</h3><p>您可以使用双引号来指定字符串字面量作为属性值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>您也可以用花括号嵌入一个 JavaScript 表达式作为属性值:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>在属性中嵌入 JavaScript 表达式时，不要使用引号来包裹大括号。否则，JSX 将该属性视为字符串字面量而不是表达式。对于字符串值你应该使用引号，对于表达式你应该使用大括号，但两者不能同时用于同一属性。</p><h3 id="用-JSX-指定子元素"><a href="#用-JSX-指定子元素" class="headerlink" title="用 JSX 指定子元素"></a>用 JSX 指定子元素</h3><p>如果是空标签，您应该像 XML 一样，使用  <code>/&gt;</code>立即闭合它：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>JSX 标签可能包含子元素：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p><strong>警告：</strong></p><p>比起 HTML ， JSX 更接近于 JavaScript ， 所以 React DOM 使用驼峰(<code>camelCase</code>)属性命名约定, 而不是 HTML 属性名称。</p><p>例如，<code>class</code>  在 JSX 中变为<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className" target="_blank" rel="noopener"><code>className</code></a>，<code>tabindex</code>  变为  <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex" target="_blank" rel="noopener"><code>tabIndex</code></a>。</p></blockquote><h3 id="JSX-防止注入攻击"><a href="#JSX-防止注入攻击" class="headerlink" title="JSX 防止注入攻击"></a>JSX 防止注入攻击</h3><p>在 JSX 中嵌入用户输入是安全的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>默认情况下， 在渲染之前, React DOM 会格式化(<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a>) JSX 中的所有值. 从而保证用户无法注入任何应用之外的代码. 在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免  <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站脚本)</a>  攻击。</p><h3 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h3><p>Babel 将 JSX 编译成  <code>React.createElement()</code>  调用。</p><p>下面的两个例子是是完全相同的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const element</span> = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;className: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>React.createElement()</code>  会执行一些检查来帮助你编写没有 bug 的代码，但基本上它会创建一个如下所示的对象：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意: 这是简化的结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'h1'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'greeting'</span>,</span><br><span class="line">    children: <span class="string">'Hello, world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些对象被称作“React 元素”。你可以把他们想象成为你想在屏幕上显示内容的一种描述。React 会读取这些对象，用他们来构建 DOM，并且保持它们的不断更新。</p><p>我们将在下一节中来探索如何将 React 元素渲染到 DOM 上。</p><blockquote><p><strong>提示:</strong></p><p>我们建议你去搜一下你用的编辑器的 “Babel” 语法方案, 以便 ES6 和 JSX 代码都能够被正确高亮的显示。</p></blockquote><h2 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h2><p>元素(Elements)是 React 应用中最小的建造部件（或者说构建块，building blocks）。</p><p>一个元素用于描述你在将在屏幕上看到的内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>不同于浏览器的 DOM 元素， React 元素是普通的对象，非常容易创建。React DOM 会负责更新 DOM ，以匹配 React 元素（愚人码头注：DOM 元素与 React 元素保持一致）。</p><blockquote><p><strong>注意：</strong></p><p>有人可能会将元素与更广为人知的 “组件(Components)” 概念相混淆。我们将在<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">下一节</a>介绍组件。元素是构成组件的”材料”， 所以我们建议你看完本节再进入下一节。</p></blockquote><h3 id="渲染一个元素到-DOM"><a href="#渲染一个元素到-DOM" class="headerlink" title="渲染一个元素到 DOM"></a>渲染一个元素到 DOM</h3><p>我们假设你的 HTML 文件中的什么地方有这么一个<code></code>：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>我们称这个是一个 “根” DOM 节点，因为该节点内的所有内容都由 React DOM 管理。</p><p>单纯用 React 构建的应用程序通常只有一个单独的 根 DOM 节点。但如果你要把 React 整合进现有的 app 中 ，那你可能会有多个相互独立的根 DOM 节点。</p><p>要渲染一个 React 元素到一个 根 DOM 节点，吧它们传递给  <code>ReactDOM.render()</code>  方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/rrpgNB?editors=1010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>上面代码会在页面上显示 “Hello, world” 。</p><h3 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h3><p>React 元素是  <a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可突变（immutable）</a>  的. 一旦你创建了一个元素, 就不能再修改其子元素或任何属性。一个元素就像电影里的一帧: 它表示在某一特定时间点的 UI 。</p><p>就我们所知, 更新 UI 的唯一方法是创建一个新的元素, 并将其传入<code>ReactDOM.render()</code>方法.</p><p>思考以下时钟例子:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>以上代码每隔 1 秒, 就会通过  <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener"><code>setInterval()</code></a>  回调  <code>ReactDOM.render()</code>  方法来重新渲染元素。</p><blockquote><p><strong>注意：</strong></p><p>实际上，大多数 React 应用只会调用  <code>ReactDOM.render()</code>  一次。在接下来的章节中，我们将学习如何将这些代码封装到<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">有状态的组件中</a>。</p><p>我们建议您不要跳过任何一节，因为每一节之间都是彼此有联系的。</p></blockquote><h3 id="React-只更新必需要更新的部分"><a href="#React-只更新必需要更新的部分" class="headerlink" title="React 只更新必需要更新的部分"></a>React 只更新必需要更新的部分</h3><p>React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。</p><p>你可以用浏览器工具对  <a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">上一个例子</a>  进行检查来验证这一点:</p><p><br><div align="center"><img src="http://www.css88.com/react/img/docs/granular-dom-updates.gif"></div><br></p><p>即使我们我们每隔 1 秒都重建了整个元素, 但实际上 React DOM 只更新了修改过的文本节点.</p><p>在我们的经验中, 关注每个时间点 UI 的表现, 而不是关注随着时间不断更新 UI 的状态, 可以减少很多奇怪的 bug 。</p><h2 id="组件-Components-和-属性-Props"><a href="#组件-Components-和-属性-Props" class="headerlink" title="组件(Components) 和 属性(Props)"></a>组件(Components) 和 属性(Props)</h2><p>组件使你可以将 UI 划分为一个一个独立，可复用的小部件，并可以对每个部件进行单独的设计。</p><p>从定义上来说， 组件就像 JavaScript 的函数。组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容。</p><blockquote><p>愚人码头注：Props ， 即属性(Property)， 在代码中写作 props ， 故可用 props 指代 properties .</p></blockquote><h3 id="函数式组件和类组件"><a href="#函数式组件和类组件" class="headerlink" title="函数式组件和类组件"></a>函数式组件和类组件</h3><p>最简单的定义组件的方法是写一个 JavaScript 函数:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是一个合法的 React 组件，因为它接收一个  <code>props</code>  参数, 并返回一个 React 元素。 我们把此类组件称为”函数式(Functional)”组件， 因为从字面上看来它就是一个 JavaScript 函数。</p><p>你也可以用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 的 class</a>  来定义一个组件:</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;<span class="type">Hello</span>, &#123;<span class="keyword">this</span>.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个组件从 React 的角度来看是等效的。</p><p>类组件有一些额外的特性，我们将在<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一节</a>讨论。在此之前, 我们先用函数式组件，因为它们更加简洁。</p><h3 id="渲染一个组件"><a href="#渲染一个组件" class="headerlink" title="渲染一个组件"></a>渲染一个组件</h3><p>在前面, 我们只遇到代表 DOM 标签的 React 元素：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;<span class="keyword">div</span> /&gt;;</span><br></pre></td></tr></table></figure><p>然而，元素也可以代表用户定义的组件：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const element</span> = &lt;Welcome name=<span class="string">"Sara"</span> /&gt;;</span><br></pre></td></tr></table></figure><p>当 React 遇到一个代表用户定义组件的元素时，它将 JSX 属性以一个单独对象的形式传递给相应的组件。 我们将其称为 “props” 对象。</p><p>比如, 以下代码在页面上渲染 “Hello, Sara” ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  element,</span></span><br><span class="line"><span class="xml">  document.getElementById('root')</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/YGYmEG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>我们简单扼要重述一下上面这个例子:</p><ol><li>我们调用了  <code>ReactDOM.render()</code>  方法并向其中传入了  <code></code>  元素。</li><li>React 调用  <code>Welcome</code>  组件，并向其中传入了  <code>{name: &#39;Sara&#39;}</code>  作为 props 对象。</li><li><code>Welcome</code>  组件返回  <code>Hello, Sara</code>。</li><li>React DOM 迅速更新 DOM ，使其显示为  <code>Hello, Sara</code>。</li></ol><blockquote><p><strong>警告：</strong></p><p>组件名称总是以大写字母开始。</p><p>举例来说, <code>代表一个 DOM 标签，而</code>  则代表一个组件，并且需要在作用域中有一个  <code>Welcome</code>  组件。</p></blockquote><h3 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h3><p>组件可以在它们的输出中引用其它组件。这使得我们可以使用同样的组件来抽象到任意层级。一个按钮，一个表单，一个对话框，一个屏幕：在 React 应用中，所有这些都通常描述为组件。</p><p>例如，我们可以创建一个  <code>App</code>  组件，并在其内部多次渲染  <code>Welcome</code>：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Welcome(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="xquery">&#123;props<span class="built_in">.name</span>&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> App() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Cahal"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Edite"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/KgQKPr?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>通常，新的 React apps 都有一个单独的顶层  <code>App</code>  组件。然而，如果你在已有的应用中整合 React，你可以需要由下至上地, 从类似于  <code>Button</code>  这样的小组件开始, 逐渐整合到视图层的顶层。</p><blockquote><p><strong>警告：</strong></p><p>组件必须返回一个单独的根元素。这就是为什么我们添加一个  <code>来包含所有</code>  元素的原因。</p></blockquote><h3 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h3><p>不要害怕把一个组件分为多个更小的组件。</p><p>举个例子，思考下名  <code>Comment</code>  组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;img className=<span class="string">"Avatar"</span></span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/VKQwEo?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>它接受  <code>author</code>（一个对象），<code>text</code>（一个字符串）和  <code>date</code>（一个日期）作为 props，并用于在某社交网站中描述一条评论。</p><p>这个组件修改起来很麻烦，因为它是被嵌套的，而且很难复用其中的某个部分。让我们从其中提取一些组件。</p><p>首先，提取头像  <code>Avatar</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;img className=<span class="string">"Avatar"</span></span><br><span class="line">      src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">      alt=&#123;props.user.name&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Avatar</code>  组件不用关心它在  <code>Comment</code>  中是如何渲染的。这是为什么我们它的 prop 一个更通用的属性名: <code>user</code>, 而不是  <code>author</code>  的原因。</p><p>我们建议从组件本身的角度来命名 props 而不是它被使用的上下文环境。</p><p>我们可以稍微简化一下  <code>Comment</code>  组件:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来，我们提取用户信息  <code>UserInfo</code>  组件， 用于将  <code>Avatar</code>  显示在用户名旁边：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">        &#123;props.user.name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使我们可以进一步简化  <code>Comment</code>  组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/rrJNJY?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>提取组件可能看起来是一个繁琐的工作，但是在大型的 Apps 中可以回报给我们的是大量的可复用组件。一个好的经验准则是如果你 UI 的一部分需要用多次 (<code>Button</code>，<code>Panel</code>，<code>Avatar</code>)，或者本身足够复杂(<code>App</code>，<code>FeedStory</code>，<code>Comment</code>)，最好的做法是使其成为可复用组件。</p><h3 id="Props-是只读的"><a href="#Props-是只读的" class="headerlink" title="Props 是只读的"></a>Props 是只读的</h3><p>无论你用<a href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">函数或类</a>的方法来声明组件, 它都无法修改其自身 props. 思考下列  <code>sum</code> (求和)函数:</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">sum</span>(a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">a</span> + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种函数称为  <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“纯函数”</a> ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。</p><p>反之， 以下是非纯函数， 因为它改变了自身的输入值：</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span><span class="params">(account, amount)</span> </span>&#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 React 很灵活，但是它有一条严格的规则：</p><p><strong>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</strong></p><p>当然， 应用 UI 总是动态的，并且随时有可以改变。 所以在<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一节</a>, 我们会介绍一个新的概念<code>state</code>(状态) 。<code>state</code>  允许 React 组件在不违反上述规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。</p><h1 id="状态-State-和生命周期"><a href="#状态-State-和生命周期" class="headerlink" title="状态(State) 和生命周期"></a>状态(State) 和生命周期</h1><p>思考<a href="http://www.css88.com/react/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">前面章节</a>中提到过的时钟例子.</p><p>目前为止我们只学了一种更新 UI 的方式。</p><p>我们通过调  <code>ReactDOM.render()</code>  方法来更新渲染的输出:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在本节中，我们将学习如何使  <code>Clock</code>  组件变得真正可复用 和 封装的更好。它将设置自己的计时器，并在每秒更新自身。</p><p>我们可以从封装时钟开始：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/dpdoYR?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>然而，它没有满足一个关键的要求：<code>Clock</code>  设置定时器并每秒更新 UI ，事实上应该是  <code>Clock</code>自身实现的一部分。</p><p>理想情况下，我们应该只引用一个  <code>Clock</code> , 然后让它自动计时并更新:</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>要实现这点，我们需要添加  <code>state</code>  到  <code>Clock</code>  组件。</p><p><code>state</code>  和  <code>props</code>  类似，但是它是私有的，并且由组件本身完全控制。</p><p>我们<a href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">之前提到过</a>, 用类定义的组件有一些额外的特性。 这个”类专有的特性”， 指的就是局部状态。</p><h2 id="把函数式组件转化为类组件"><a href="#把函数式组件转化为类组件" class="headerlink" title="把函数式组件转化为类组件"></a>把函数式组件转化为类组件</h2><p>你可以遵从以下 5 步, 把一个类似  <code>Clock</code>  这样的函数式组件转化为类组件：</p><ol><li>创建一个继承自  <code>React.Component</code>  类的  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>  同名类。</li><li>添加一个名为  <code>render()</code>  的空方法。</li><li>把原函数中的所有内容移至  <code>render()</code>  中。</li><li>在  <code>render()</code>  方法中使用  <code>this.props</code>  替代  <code>props</code>。</li><li>删除保留的空函数声明。</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/zKRGpo?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p><code>Clock</code>  现在被定为类组件，而不是函数式组件。</p><p>类允许我们在其中添加本地状态(state)和生命周期钩子。</p><h2 id="在类组件中添加本地状态-state"><a href="#在类组件中添加本地状态-state" class="headerlink" title="在类组件中添加本地状态(state)"></a>在类组件中添加本地状态(state)</h2><p>我们现在通过以下 3 步, 把<code>date</code>从属性(<code>props</code>) 改为 状态(<code>state</code>)：</p><p>We will move the <code>date</code> from props to state in three steps:</p><ol><li>替换  <code>render()</code>  方法中的  <code>this.props.date</code>  为  <code>this.state.date</code>：</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor" target="_blank" rel="noopener">类构造函数(class constructor)</a>  初始化  <code>this.state</code>:</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;date: <span class="keyword">new</span> <span class="type">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们如何将  <code>props</code>  传递给基础构造函数：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(props)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  super(props);</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.state = &#123;date: new Date()&#125;</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件应始终使用  <code>props</code>  调用基础构造函数。</p><ol start="3"><li>移除  <code></code>  元素中的  <code>date</code>  属性：</li></ol><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们稍后再把 计时器代码 添加到组件内部。</p><p>现有的结果是这样:</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;date: <span class="keyword">new</span> <span class="type">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(</span><br><span class="line">  &lt;<span class="type">Clock</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>接下来，我们将使  <code>Clock</code>  设置自己的计时器，并每秒更新一次。</p><h2 id="在类中添加生命周期方法"><a href="#在类中添加生命周期方法" class="headerlink" title="在类中添加生命周期方法"></a>在类中添加生命周期方法</h2><p>在一个具有许多组件的应用程序中，在组件被销毁时释放所占用的资源是非常重要的。</p><p>当  <code>Clock</code>  第一次渲染到 DOM 时，我们要<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">设置一个定时器</a> 。 这在 React 中称为 “挂载(mounting)” 。</p><p>当  <code>Clock</code>  产生的 DOM 被销毁时，我们也想<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">清除该计时器</a>。 这在 React 中称为 “卸载(unmounting)” 。</p><p>当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来运行一些代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;date: <span class="keyword">new</span> <span class="type">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法称为 “生命周期钩子”。</p><p><code>componentDidMount()</code>  钩子在组件输出被渲染到 DOM 之后运行。这是设置时钟的不错的位置：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">    () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们把计时器 ID 直接存在  <code>this</code>  中。</p><p><code>this.props</code>  由 React 本身设定, 而  <code>this.state</code>  具有特殊的含义，但如果需要存储一些不用于视觉输出的内容，则可以手动向类中添加额外的字段。</p><p>如果在  <code>render()</code>  方法中没有被引用, 它不应该出现在 state 中。</p><p>我们在<code>componentWillUnmount()</code>生命周期钩子中取消这个计时器：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们将会实现每秒运行的  <code>tick()</code>  方法。</p><p>它将使用  <code>this.setState()</code>  来来周期性地更新组件本地状态：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>现在这个时钟每秒都会走了。</p><p>我们来快速回顾一下该过程，以及调用方法的顺序：</p><ol><li>当  <code></code>  被传入  <code>ReactDOM.render()</code>  时, React 会调用  <code>Clock</code>组件的构造函数。 因为<code>Clock</code>  要显示的是当前时间，所以它将使用包含当前时间的对象来初始化  <code>this.state</code>。我们稍后会更新此状态。</li><li>然后 React 调用了  <code>Clock</code>  组件的  <code>render()</code>  方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配  <code>Clock</code>  的渲染输出。</li><li>当  <code>Clock</code>  输出被插入到 DOM 中时，React 调用  <code>componentDidMount()</code>  生命周期钩子。在该方法中，<code>Clock</code>  组件请求浏览器设置一个定时器来一次调用  <code>tick()</code>。</li><li>浏览器会每隔一秒调用一次  <code>tick()</code>方法。在该方法中， <code>Clock</code>  组件通过  <code>setState()</code>  方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过  <code>setState()</code>, React 得知了组件  <code>state</code>(状态)的变化, 随即再次调用  <code>render()</code>  方法，获取了当前应该显示的内容。 这次，<code>render()</code>  方法中的  <code>this.state.date</code>  的值已经发生了改变， 从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。</li><li>如果通过其他操作将  <code>Clock</code>  组件从 DOM 中移除了, React 会调用<code>componentWillUnmount()</code>  生命周期钩子, 所以计时器也会被停止。</li></ol><h2 id="正确地使用-State-状态"><a href="#正确地使用-State-状态" class="headerlink" title="正确地使用 State(状态)"></a>正确地使用 State(状态)</h2><p>关于  <code>setState()</code>  有三件事是你应该知道的。</p><h3 id="不要直接修改-state-状态"><a href="#不要直接修改-state-状态" class="headerlink" title="不要直接修改 state(状态)"></a>不要直接修改 state(状态)</h3><p>例如，这样将不会重新渲染一个组件：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">// 错误</span><br><span class="line">this.<span class="keyword">state</span>.comment = 'Hello';</span><br></pre></td></tr></table></figure><p>用  <code>setState()</code>  代替：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="string">comment:</span> <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure><p>唯一可以分配  <code>this.state</code>  的地方是构造函数。</p><h3 id="state-状态-更新可能是异步的"><a href="#state-状态-更新可能是异步的" class="headerlink" title="state(状态) 更新可能是异步的"></a>state(状态) 更新可能是异步的</h3><p>React 为了优化性能，有可能会将多个  <code>setState()</code>  调用合并为一次更新。</p><p>因为  <code>this.props</code>  和  <code>this.state</code>  可能是异步更新的，你不能依赖他们的值计算下一个 state(状态)。</p><p>例如, 以下代码可能导致  <code>counter</code>(计数器)更新失败：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要解决这个问题，应该使用第 2 种  <code>setState()</code>  的格式，它接收一个函数，而不是一个对象。该函数接收前一个状态值作为第 1 个参数， 并将更新后的值作为第 21 个参数:</p><p>要弥补这个问题，使用另一种 setState() 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 正确</span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">(prevState, props)</span> =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>我们在上面使用了一个<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，但是也可以使用一个常规的函数：</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span><span class="params">(prevState, props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="state-状态-更新会被合并"><a href="#state-状态-更新会被合并" class="headerlink" title="state(状态)更新会被合并"></a>state(状态)更新会被合并</h3><p>当你调用  <code>setState()</code>， React 将合并你提供的对象到当前的状态中。</p><p>例如，你的状态可能包含几个独立的变量：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(props)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  super(props);</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    posts: [],</span></span></span><br><span class="line"><span class="function"><span class="comment">    comments: []</span></span></span><br><span class="line"><span class="function"><span class="comment">  &#125;</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过调用独立的  <code>setState()</code>  调用分别更新它们:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">componentDidMount</span>() &#123;</span><br><span class="line">  <span class="selector-tag">fetchPosts</span>()<span class="selector-class">.then</span>(response =&gt; &#123;</span><br><span class="line">    <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">      <span class="attribute">posts</span>: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">fetchComments</span>()<span class="selector-class">.then</span>(response =&gt; &#123;</span><br><span class="line">    <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">      <span class="attribute">comments</span>: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并是浅合并，所以  <code>this.setState({comments})</code>  不会改变  <code>this.state.posts</code>  的值，但会完全替换<code>this.state.comments</code>  的值。</p><h2 id="数据向下流动"><a href="#数据向下流动" class="headerlink" title="数据向下流动"></a>数据向下流动</h2><p>无论作为父组件还是子组件，它都无法获悉一个组件是否有状态，同时也不需要关心另一个组件是定义为函数组件还是类组件。</p><p>这就是 state(状态) 经常被称为 本地状态 或 封装状态的原因。 它不能被拥有并设置它的组件 以外的任何组件访问。</p><p>一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="variable">&lt;h2&gt;</span>It is &#123;this.<span class="keyword">state</span>.date.<span class="keyword">to</span>LocaleTimeString()&#125;.&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>同样适用于用户定义组件:</p><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">&lt;FormattedDate <span class="keyword">date</span>=&#123;<span class="keyword">this</span>.state.<span class="keyword">date</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p><code>FormattedDate</code>  组件通过 props(属性) 接收了  <code>date</code>  的值，但它仍然不能获知该值是来自于<code>Clock</code>的 state(状态) ，还是  <code>Clock</code>  的 props(属性)，或者是直接手动创建的：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">FormattedDate</span>(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">&lt;h2&gt;It</span> <span class="keyword">is</span> &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/zKRqNB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这通常称为一个“从上到下”，或者“单向”的数据流。任何 state(状态) 始终由某个特定组件所有，并且从该 state(状态) 导出的任何数据 或 UI 只能影响树中 “下方” 的组件。</p><p>如果把组件树想像为 props(属性) 的瀑布，所有组件的 state(状态) 就如同一个额外的水源汇入主流，且只能随着主流的方向向下流动。</p><p>要证明所有组件都是完全独立的， 我们可以创建一个  <code>App</code>  组件，并在其中渲染 3 个<code></code>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>每个  <code>Clock</code>  都设置它自己的计时器并独立更新。</p><p>在 React 应用中，一个组件是否是有状态或者无状态的，被认为是组件的一个实现细节，随着时间推移可能发生改变。你可以在有状态的组件中使用无状态组件，反之亦然。</p><p>通过 React 元素处理事件跟在 DOM 元素上处理事件非常相似。但是有一些语法上的区别：</p><ul><li>React 事件使用驼峰命名，而不是全部小写。</li><li>通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。</li></ul><p>例如，HTML：</p><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure><p>在 React 中略有不同：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个区别是，在 React 中你不能通过返回  <code>false</code>（愚人码头注：即  <code>return false;</code>  语句） 来阻止默认行为。必须明确调用  <code>preventDefault</code> 。例如，对于纯 HTML ，要阻止链接打开一个新页面的默认行为，可以这样写：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 React 中, 应该这么写:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这里， e 是一个合成的事件。 React 根据  <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>  定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。查看  <a href="http://www.css88.com/react/docs/events.html" target="_blank" rel="noopener"><code>SyntheticEvent</code></a>  参考指南了解更多。</p><p>当使用 React 时，你一般不需要调用  <code>addEventListener</code>  在 DOM 元素被创建后添加事件监听器。相反，只要当元素被初始渲染的时候提供一个监听器就可以了。</p><p>当使用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 类</a>  定义一个组件时，通常的一个事件处理程序是类上的一个方法。例如，<code>Toggle</code>  组件渲染一个按钮，让用户在 “ON” 和 “OFF” 状态之间切换：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;isToggleOn: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个绑定是必要的，使`this`在回调中起作用</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(prevState =&gt; (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="symbol">'O</span>N' : <span class="symbol">'OF</span>F'&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(</span><br><span class="line">  &lt;<span class="type">Toggle</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/xEmzGg?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在 JSX 回调中你必须注意  <code>this</code>  的指向。 在 JavaScript 中，类方法默认没有  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">绑定</a>  的。如果你忘记绑定  <code>this.handleClick</code>  并将其传递给<code>onClick</code>，那么在直接调用该函数时，<code>this</code>  会是<code>undefined</code> 。</p><p>这不是 React 特有的行为；这是  <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/" target="_blank" rel="noopener">JavaScript 中的函数如何工作</a>的一部分。 一般情况下，如果你引用一个后面没跟  <code>()</code>  的方法，例如  <code>onClick={this.handleClick}</code> ，那你就应该 绑定(bind) 该方法。</p><p>如果调用  <code>bind</code>  令你烦恼，有两种方法可以解决这个问题。 如果您使用实验性的  <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">属性初始化语法</a> ，那么你可以使用属性初始值设置来正确地 绑定(bind) 回调：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个语法确保 `this` 绑定在 handleClick 中。</span></span><br><span class="line">  <span class="comment">// 警告：这是 *实验性的* 语法。</span></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语法在  <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">创建 React App</a>  中是默认开启的。</p><p>如果你没有使用属性初始化语法，可以在回调中使用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 这个语法确保 `this` 被绑定在 handleClick 中</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语法的问题是，每次  <code>LoggingButton</code>  渲染时都创建一个不同的回调。在多数情况下，没什么问题。然而，如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们通常建议在构造函数中进行绑定，以避免这类性能问题。</p><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p>在 React 中，你可以创建不同的组件封装你所需要的行为。然后，只渲染它们之中的一些，取决于你的应用的状态。</p><p>React 中的条件渲染就和在 JavaScript 中的条件语句一样。使用 JavaScript 操作符如  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" target="_blank" rel="noopener"><code>if</code></a>  或者<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener">条件操作符</a>来创建渲染当前状态的元素，并且让 React 更新匹配的 UI 。</p><p>思考以下两个组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要创建一个  <code>Greeting</code>  组件, 用来根据用户是否登录, 判断并显示上述两个组件之一：</p><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// 修改为 isLoggedIn=&#123;true&#125; 试试:</span></span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;<span class="literal">false</span>&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/ZpVxNq?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这个例子根据  <code>isLoggedIn</code> prop 渲染了不同的问候语 。</p><h3 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h3><p>你可以用变量来存储元素。这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。</p><p>思考以下两个新组件，分别用于显示登出和登入按钮：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      Login</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function LogoutButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">      Logout</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来的例子中，我们将会创建一个<a href="http://www.css88.com/react/docs/state-and-lifecycle.html#adding-local-state-to-a-class" target="_blank" rel="noopener">有状态组件</a>，叫做  <code>LoginControl</code> 。</p><p>它将渲染  <code>或者</code> ，取决于当前状态。同时渲染前面提到的<code></code>  组件:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleLoginClick = <span class="keyword">this</span>.handleLoginClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleLogoutClick = <span class="keyword">this</span>.handleLogoutClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;isLoggedIn: <span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;isLoggedIn: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;isLoggedIn: <span class="literal">false</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"></span><br><span class="line">    let button = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;LoginControl /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/QKzAgB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>虽然声明一个变量并使用一个  <code>if</code>  语句是一个有条件地渲染组件的好方法，有时你可能想要使用一个更简短的语法。在 JSX 中有几种内联条件的方法，如下所述。</p><h3 id="使用逻辑-amp-amp-操作符的内联-if-用法"><a href="#使用逻辑-amp-amp-操作符的内联-if-用法" class="headerlink" title="使用逻辑 &amp;&amp; 操作符的内联 if 用法"></a>使用逻辑 &amp;&amp; 操作符的内联 if 用法</h3><p>您可以  <a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">在 JSX 中嵌入任何表达式</a> ，方法是将其包裹在花括号中。这也包括 JavaScript 逻辑<code>&amp;&amp;</code>  运算符。 它有助于有条件地包含一个元素：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">'React'</span>, <span class="string">'Re: React'</span>, <span class="string">'Re:Re: React'</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/ozJddz?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>它可以正常运行，因为在 JavaScript 中， <code>true &amp;&amp; expression</code>  总是会评估为  <code>expression</code> ，而<code>false &amp;&amp; expression</code>  总是执行为  <code>false</code> 。</p><p>因此，如果条件为  <code>true</code> ，则  <code>&amp;&amp;</code>  后面的元素将显示在输出中。 如果是  <code>false</code>，React 将会忽略并跳过它。</p><h3 id="使用条件操作符的内联-If-Else"><a href="#使用条件操作符的内联-If-Else" class="headerlink" title="使用条件操作符的内联 If-Else"></a>使用条件操作符的内联 If-Else</h3><p>另一个用于条件渲染元素的内联方法是使用 JavaScript 的条件操作符  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener"><code>condition ? true : false</code></a> 。</p><p>在下面这个例子中，我们使用它来进行条件渲染一个小的文本块：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user <span class="keyword">is</span> &lt;b&gt;&#123;isLoggedIn ? <span class="string">'currently'</span> : <span class="string">'not'</span>&#125;&lt;/b&gt; logged <span class="keyword">in</span>.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也可以用于更大的表达式，虽然不太明显发生了什么：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像 JavaScript 一样，你可以根据你和你的团队认为更易于阅读的方式选择合适的风格。还要记住，无论何时何地，当条件变得太复杂时，可能是<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取组件</a>的好时机。</p><h3 id="防止组件渲染"><a href="#防止组件渲染" class="headerlink" title="防止组件渲染"></a>防止组件渲染</h3><p>在极少数情况下，您可能希望组件隐藏自身，即使它是由另一个组件渲染的。为此，返回<code>null</code>  而不是其渲染输出。</p><p>在下面的例子中，根据名为<code>warn</code>的 prop 值，呈现  <code></code> 。如果 prop 值为  <code>false</code>，则该组件不渲染：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"warning"</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Page extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;showWarning: true&#125;</span></span><br><span class="line"><span class="regexp">    this.handleToggleClick = this.handleToggleClick.bind(this);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleToggleClick() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">      showWarning: !prevState.showWarning</span></span><br><span class="line"><span class="regexp">    &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.showWarning ? <span class="string">'Hide'</span> : <span class="string">'Show'</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/Xjoqwm?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>从组件的  <code>render</code>  方法返回  <code>null</code>  不会影响组件生命周期方法的触发。 例如，<code>componentWillUpdate</code>  和  <code>componentDidUpdate</code>  仍将被调用。</p><h1 id="列表-Lists-和-键-Keys"><a href="#列表-Lists-和-键-Keys" class="headerlink" title="列表(Lists) 和 键(Keys)"></a>列表(Lists) 和 键(Keys)</h1><p>首先，让我们回顾一下在 JavaScript 中如何转换列表。</p><p>给定下面的代码，我们使用  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a>  函数使  <code>numbers</code>  数组中的元素值翻倍。我们将  <code>map()</code>  返回的新数组分配给变量  <code>doubled</code>，并且打印这个它：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(doubled);</span><br></pre></td></tr></table></figure><p>这段代码在控制台中打印为  <code>[2, 4, 6, 8, 10]</code>。</p><p>在 React 中，转换数组为  <a href="http://www.css88.com/react/docs/rendering-elements.html" target="_blank" rel="noopener">元素列表</a>  的方式，和上述方法基本相同。</p><h3 id="多组件渲染"><a href="#多组件渲染" class="headerlink" title="多组件渲染"></a>多组件渲染</h3><p>可以创建元素集合，并用一对大括号  <code>{}</code> <a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">在 JSX 中直接将其引用</a>即可。</p><p>下面，我们用 JavaScript 的  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a>  函数将  <code>numbers</code>  数组循环处理。对于每一项，我们返回一个  <code></code>  元素。最终，我们将结果元素数组分配给  <code>listItems</code>：</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">const listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>把整个  <code>listItems</code>  数组包含到一个  <code></code>  元素，并<a href="http://www.css88.com/react/docs/rendering-elements.html#rendering-an-element-into-the-dom" target="_blank" rel="noopener">渲染到 DOM</a>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;listItems&#125;&lt;<span class="regexp">/ul&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/GjPyQr?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这段代码显示从 1 到 5 的数字列表。</p><h3 id="基本列表组件"><a href="#基本列表组件" class="headerlink" title="基本列表组件"></a>基本列表组件</h3><p>通常情况下，我们会在一个<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">组件</a>中渲染列表。</p><p>我们可以重构前面的例子到一个组件，它接受一个  <code>numbers</code>  数组，并输出一个元素的无序列表。</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.<span class="keyword">map</span>(<span class="built_in">(number</span>) =&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="xquery"><span class="built_in">&#123;number</span>&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><span class="xquery">&#123;listItems&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当运行上述代码的时候，将会收到一个警告：a key should be provided for list items（应该为列表元素提供一个键）（愚人码头注 ：CodeOpen 中没有报警告，是因为其示例中使用的是 min 版本的 React，换成非 min 版本的就可以看到）。当创建元素列表时，“key” 是一个你需要包含的特殊字符串属性。我们将在下一节讨论它的重要性。</p><p>我们在  <code>numbers.map()</code>  中赋值一个  <code>key</code>  给我们的列表元素，解决丢失 key 的问题。</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.<span class="keyword">map</span>(<span class="built_in">(number</span>) =&gt;</span><br><span class="line">    &lt;li<span class="built_in"> key</span>=<span class="built_in">&#123;number</span>.toString()&#125;&gt;</span><br><span class="line">      <span class="built_in">&#123;number</span>&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><span class="xquery">&#123;listItems&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/jrXYRR?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="键-Keys"><a href="#键-Keys" class="headerlink" title="键(Keys)"></a>键(Keys)</h2><p>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识：</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">const listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li <span class="type">key</span>=&#123;number.toString()&#125;&gt;</span><br><span class="line">    &#123;number&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>挑选 key 最好的方式是使用一个在它的同辈元素中不重复的标识字符串。多数情况你可以使用数据中的 IDs 作为 keys：</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">const todoItems = todos.map((todo) =&gt;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=</span></span><span class="template-variable">&#123;todo.id&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;todo.text&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure><p>当要渲染的列表项中没有稳定的 IDs 时，你可以使用数据项的索引值作为 key 的最后选择：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const todoItems = todos.map(<span class="function"><span class="params">(todo, index)</span> =&gt;</span></span><br><span class="line">  <span class="regexp">//</span> Only <span class="keyword">do</span> <span class="keyword">this</span> <span class="keyword">if</span> items have <span class="literal">no</span> stable IDs</span><br><span class="line">  &lt;li key=&#123;index&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果列表项可能被重新排序时，我们不建议使用索引作为 keys，因为这导致一定的性能问题，会很慢。如果感兴趣，你可以阅读一下<a href="http://www.css88.com/react/docs/reconciliation.html#recursing-on-children" target="_blank" rel="noopener">深入的介绍关于为什么 keys 是必须的</a>。</p><h3 id="使用-keys-提取组件"><a href="#使用-keys-提取组件" class="headerlink" title="使用 keys 提取组件"></a>使用 keys 提取组件</h3><p>keys 只在数组的上下文中存在意义。</p><p>例如，如果你<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取</a>  一个  <code>ListItem</code>  组件，应该把 key 放置在数组处理的  <code>元素中，不能放在 `ListItem` 组件自身中的</code>  根元素上。</p><p><strong>例子：错误的 key 用法</strong></p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> ListItem(props) &#123;</span><br><span class="line">  const <span class="keyword">value</span> = props.<span class="keyword">value</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    // 错误！不需要在这里指定<span class="built_in"> key</span>：</span><br><span class="line">    &lt;li<span class="built_in"> key</span>=&#123;<span class="keyword">value</span>.toString()&#125;&gt;</span><br><span class="line">      &#123;<span class="keyword">value</span>&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.<span class="keyword">map</span>(<span class="built_in">(number</span>) =&gt;</span><br><span class="line">    // 错误<span class="built_in">！key</span> 应该在这里指定：</span><br><span class="line">    &lt;ListItem <span class="keyword">value</span>=<span class="built_in">&#123;number</span>&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;listItems&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>错误！key 应该在这里指定：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 正确！这里不需要指定 key ：</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 正确！key 应该在这里被指定</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const numbers = [1, 2, 3, 4, 5];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;NumberList numbers=&#123;numbers&#125; /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/rthor/pen/QKzJKG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>一个好的经验准则是元素中调用  <code>map()</code>  需要 keys 。</p><h3 id="keys-在同辈元素中必须是唯一的"><a href="#keys-在同辈元素中必须是唯一的" class="headerlink" title="keys 在同辈元素中必须是唯一的"></a>keys 在同辈元素中必须是唯一的</h3><p>在数组中使用的 keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一。我们可以在操作两个不同数组的时候使用相同的 keys ：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Blog(props) &#123;</span><br><span class="line">  const sidebar = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;props.posts.<span class="keyword">map</span>((post) =&gt;</span></span><br><span class="line"><span class="xquery">        &lt;li<span class="built_in"> key</span>=&#123;post<span class="built_in">.id</span>&#125;</span><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">          </span><span class="xquery">&#123;post.title&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">  const content = props.posts.<span class="keyword">map</span>((post) =&gt;</span><br><span class="line">    &lt;div<span class="built_in"> key</span>=&#123;post<span class="built_in">.id</span>&#125;&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="xquery">&#123;post.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xquery">&#123;post.content&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;sidebar&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;content&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const posts = [</span><br><span class="line">  <span class="built_in">&#123;id</span>: <span class="number">1</span>, title: <span class="string">'Hello World'</span>, content: <span class="string">'Welcome to learning React!'</span>&#125;,</span><br><span class="line">  <span class="built_in">&#123;id</span>: <span class="number">2</span>, title: <span class="string">'Installation'</span>, content: <span class="string">'You can install React from npm.'</span>&#125;</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Blog posts=&#123;posts&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/NRZYGN?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>键是 React 的一个内部映射，但其不会传递给组件的内部。如果你需要在组件中使用相同的值，可以明确使用一个不同名字的 prop 传入。</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> content = posts.map((<span class="keyword">post</span>) =&gt;</span><br><span class="line">  &lt;<span class="keyword">Post</span></span><br><span class="line">    key=&#123;<span class="keyword">post</span>.id&#125;</span><br><span class="line">    id=&#123;<span class="keyword">post</span>.id&#125;</span><br><span class="line">    title=&#123;<span class="keyword">post</span>.title&#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的例子中， <code>Post</code>  组件可以读取  <code>props.id</code>，但是不能读取  <code>props.key</code> 。</p><h3 id="在-JSX-中嵌入-map"><a href="#在-JSX-中嵌入-map" class="headerlink" title="在 JSX 中嵌入 map()"></a>在 JSX 中嵌入 map()</h3><p>在上面的例子中，我们单独声明了一个  <code>listItems</code>  变量，并在 JSX 中引用了该变量：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>JSX 允许在大括号中<a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">嵌入任何表达式</a>，因此可以 内联  <code>map()</code>  结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">                  value=&#123;number&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/BLvYrB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>有时这可以产生清晰的代码，但是这个风格也可能被滥用。就像在 JavaScript 中，是否有必要提取一个变量以提高程序的可读性，这取决于你。但是记住，如果  <code>map()</code>  体中有太多嵌套，可能是<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取组件</a>的好时机。</p><h1 id="表单-Forms"><a href="#表单-Forms" class="headerlink" title="表单(Forms)"></a>表单(Forms)</h1><p>HTML 表单元素与 React 中的其他 DOM 元素有所不同，因为表单元素自然地保留了一些内部状态。例如，这个纯 HTML 表单接受一个单独的 name：</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">label</span>&gt;</span><br><span class="line">    Name:</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">  &lt;/<span class="keyword">label</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure><p>该表单和 HTML 表单的默认行为一致，当用户提交此表单时浏览器会打开一个新页面。如果你希望 React 中保持这个行为，也可以工作。但是多数情况下，用一个处理表单提交并访问用户输入到表单中的数据的 JavaScript 函数也很方便。实现这一点的标准方法是使用一种称为“受控组件(controlled components)”的技术。</p><h2 id="受控组件-Controlled-Components"><a href="#受控组件-Controlled-Components" class="headerlink" title="受控组件(Controlled Components)"></a>受控组件(Controlled Components)</h2><p>在 HTML 中，表单元素如  <code>，</code>  和  <code></code>  表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过  <a href="http://www.css88.com/react/docs/react-component.html#setstate" target="_blank" rel="noopener"><code>setState()</code></a>  更新。</p><p>我们可以通过使 React 的 state 成为 “单一数据源原则” 来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。</p><p>例如，如果我们想使上一个例子在提交时记录名称，我们可以将表单写为受控组件：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;value: <span class="string">''</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/VmmPgp?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>设置表单元素的 value 属性之后，其显示值将由 this.state.value 决定，以满足 React 状态的同一数据理念。每次键盘敲击之后会执行 handleChange 方法以更新 React 状态，显示值也将随着用户的输入改变。</p><p>由于  <code>value</code>  属性设置在我们的表单元素上，显示的值总是  <code>this.state.value</code>，以满足 state 状态的同一数据理念。由于  <code>handleChange</code>  在每次敲击键盘时运行，以更新 React state(状态)，显示的值将更新为用户的输入。</p><p>对于受控组件来说，每一次 state(状态) 变化都会伴有相关联的处理函数。这使得可以直接修改或验证用户的输入。比如，如果我们希望强制 name 的输入都是大写字母，可以这样来写<code>handleChange</code>  方法：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">handleChange(<span class="keyword">event</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="keyword">value</span>: <span class="keyword">event</span>.target.<span class="keyword">value</span>.toUpperCase()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textare-标签"><a href="#textare-标签" class="headerlink" title="textare 标签"></a>textare 标签</h2><p>在 HTML 中，<code></code>  元素通过它的子节点定义了它的文本值：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;</span><br><span class="line">  Hello there, this <span class="keyword">is</span> <span class="keyword">some</span> <span class="built_in">text</span> <span class="keyword">in</span> a <span class="built_in">text</span> area</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>在 React 中，<code>的赋值使用 `value` 属性替代。这样一来，表单中</code>  的书写方式接近于单行文本输入框 ：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EssayForm</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">'Please write an essay about your favorite DOM element.'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'An essay was submitted: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;textarea value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>this.state.value</code>  在构造函数中初始化，所以这些文本一开始就出现在文本域中。</p><h2 id="select-标签"><a href="#select-标签" class="headerlink" title="select 标签"></a>select 标签</h2><p>在 HTML 中，<code></code>  创建了一个下拉列表。例如，这段 HTML 创建一个下拉的口味(flavors)列表：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"grapefruit"</span>&gt;</span>Grapefruit<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"lime"</span>&gt;</span>Lime<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span> <span class="attr">value</span>=<span class="string">"coconut"</span>&gt;</span>Coconut<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"mango"</span>&gt;</span>Mango<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，Coconut 选项是初始化选中的，因为它的  <code>selected</code>  属性。React 中，并不使用这个<code>selected</code>  属性，而是在根  <code>select</code>  标签中使用了一个  <code>value</code>  属性。这使得受控组件使用更方便，因为你只需要更新一处即可。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlavorForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">'coconut'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'Your favorite flavor is: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Pick your favorite La Croix flavor:</span><br><span class="line">          &lt;select value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value=<span class="string">"grapefruit"</span>&gt;Grapefruit&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option value="lime"&gt;Lime&lt;/</span>option&gt;</span><br><span class="line">            &lt;option value=<span class="string">"coconut"</span>&gt;Coconut&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option value="mango"&gt;Mango&lt;/</span>option&gt;</span><br><span class="line">          &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>label&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/JbbEzX?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>总的来说，这使  <code>，</code>  和  <code></code>  都以类似的方式工作 —— 它们都接受一个  <code>value</code>  属性可以用来实现一个受控组件。</p><h2 id="处理多个输入元素"><a href="#处理多个输入元素" class="headerlink" title="处理多个输入元素"></a>处理多个输入元素</h2><p>当您需要处理多个受控的  <code>input</code>  元素时，您可以为每个元素添加一个  <code>name</code>  属性，并且让处理函数根据  <code>event.target.name</code>  的值来选择要做什么。</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isGoing: <span class="literal">true</span>,</span><br><span class="line">      numberOfGuests: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleInputChange = <span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target = event.target;</span><br><span class="line">    const value = target.<span class="keyword">type</span> === <span class="symbol">'checkbo</span>x' ? target.checked : target.value;</span><br><span class="line">    const name = target.name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          <span class="type">Is</span> going:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">"isGoing"</span></span><br><span class="line">            <span class="class"><span class="keyword">type</span></span>=<span class="string">"checkbox"</span></span><br><span class="line">            checked=&#123;<span class="keyword">this</span>.state.isGoing&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          <span class="type">Number</span> of guests:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">"numberOfGuests"</span></span><br><span class="line">            <span class="class"><span class="keyword">type</span></span>=<span class="string">"number"</span></span><br><span class="line">            value=&#123;<span class="keyword">this</span>.state.numberOfGuests&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/wgedvV?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>注意我们如何使用 ES6<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names" target="_blank" rel="noopener">计算的属性名称</a>语法来更新与给定输入名称相对应的 state(状态) 键：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  [<span class="meta">name</span>]: <span class="keyword">value</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码等价于 ES5 代码:</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var partialState = &#123;&#125;<span class="comment">;</span></span><br><span class="line">partialState[name] = value<span class="comment">;</span></span><br><span class="line">this.setState(partialState)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此外，由于  <code>setState()</code>  自动<a href="http://www.css88.com/react/docs/state-and-lifecycle.html#state-updates-are-merged" target="_blank" rel="noopener">将部分状态合并到当前状态</a>，所以我们只需要调用更改的部分即可。</p><h2 id="受控组件的替代方案"><a href="#受控组件的替代方案" class="headerlink" title="受控组件的替代方案"></a>受控组件的替代方案</h2><p>有时使用受控组件有些乏味，因为你需要为每一个可更改的数据提供事件处理器，并通过 React 组件管理所有输入状态。当你将已经存在的代码转换为 React 时，或将 React 应用程序与非 React 库集成时，这可能变得特别烦人。在这些情况下，您可能需要使用<a href="http://www.css88.com/react/docs/uncontrolled-components.html" target="_blank" rel="noopener">不受控的组件</a>，用于实现输入表单的替代技术。</p><h1 id="状态提升-Lifting-State-Up"><a href="#状态提升-Lifting-State-Up" class="headerlink" title="状态提升(Lifting State Up)"></a>状态提升(Lifting State Up)</h1><p>通常情况下，同一个数据的变化需要几个不同的组件来反映。我们建议提升共享的状态到它们最近的祖先组件中。我们看下这是如何运作的。</p><p>在本节，我们将会创建一个温度计算器，用来计算水在一个给定温度下是否会沸腾。</p><p>我们通过一个称为  <code>BoilingVerdict</code>  的组件开始。它接受  <code>celsius</code>（摄氏温度）作为 prop ，并打印是否足以使水沸腾：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would not boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将会创建一个  <code>Calculator</code>  组件。它渲染一个  <code></code>  让你输入温度，并在<code>this.state.temperature</code>  中保存它的值。</p><p>另外，它会根据当前输入的温度来渲染  <code>BoilingVerdict</code> 。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: <span class="string">''</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> Celsius:&lt;/legend&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value=&#123;temperature&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(temperature)&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/VpZJRZ?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="添加第二个输入"><a href="#添加第二个输入" class="headerlink" title="添加第二个输入"></a>添加第二个输入</h2><p>我们新的需求是，除了一个摄氏温度输入之外，我们再提供了一个华氏温度输入，并且两者保持自动同步。</p><p>我们可以从  <code>Calculator</code>  中提取一个  <code>TemperatureInput</code>  组件开始。我们将添加一个新的  <code>scale</code>属性，值可能是  <code>&quot;c&quot;</code>  或者  <code>&quot;f&quot;</code> ：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">  c: <span class="string">'Celsius'</span>,</span><br><span class="line">  f: <span class="string">'Fahrenheit'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: <span class="string">''</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以修改  <code>Calculator</code>  来渲染两个独立的温度输入：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;<span class="type">TemperatureInput</span> scale=<span class="string">"c"</span> /&gt;</span><br><span class="line">        &lt;<span class="type">TemperatureInput</span> scale=<span class="string">"f"</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/GWKbao?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>我们现在有两个 (input)输入框 了，但是当你输入其中一个温度时，另一个输入并没有更新。这是跟我们的需要不符的：我们希望它们保持同步。</p><p>我们也不能在  <code>Calculator</code>  中显示  <code>BoilingVerdict</code> 。 <code>Calculator</code>  不知道当前的温度，因为它是在  <code>TemperatureInput</code>  中隐藏的。</p><h2 id="编写转换函数"><a href="#编写转换函数" class="headerlink" title="编写转换函数"></a>编写转换函数</h2><p>首先，我们编写两个函数来在摄氏温度和华氏温度之间转换：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">toCelsius</span>(fahrenheit) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">(fahrenheit</span> - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(celsius) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">(celsius</span> * <span class="number">9</span> / <span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数用来转化数字。接下来再编写一个函数用来接收一个字符串  <code>temperature</code>  和一个 转化器函数 作为参数，并返回一个字符串。这个函数用来在两个输入之间进行相互转换。</p><p>对于无效的  <code>temperature</code>  值，它返回一个空字符串，输出结果保留 3 位小数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">temperature, convert</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(temperature);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> output = convert(input);</span><br><span class="line">  <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> rounded.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如， <code>tryConvert(&#39;abc&#39;, toCelsius)</code>  将返回一个空字符串，而  <code>tryConvert(&#39;10.22&#39;, toFahrenheit)</code>  返回  <code>&#39;50.396&#39;</code> 。</p><h2 id="状态提升-Lifting-State-Up-1"><a href="#状态提升-Lifting-State-Up-1" class="headerlink" title="状态提升(Lifting State Up)"></a>状态提升(Lifting State Up)</h2><p>目前，两个  <code>TemperatureInput</code>  组件都将其值保持在本地状态中：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: ''&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = <span class="keyword">this</span>.state.temperature;</span><br></pre></td></tr></table></figure><p>但是，我们希望这两个输入是相互同步的。当我们更新摄氏温度输入时，华氏温度输入应反映转换后的温度，反之亦然。</p><p>在 React 中，共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。我们将从  <code>TemperatureInput</code>  中移除相关状态本地状态，并将其移动到  <code>Calculator</code>  中。</p><p>如果  <code>Calculator</code>  拥有共享状态，那么它将成为两个输入当前温度的“单一数据来源”。它可以指示他们具有彼此一致的值。由于两个  <code>TemperatureInput</code>  组件的 props 都来自同一个父级<code>Calculator</code>组件，两个输入将始终保持同步。</p><p>让我们一步一步看看这是如何工作的。</p><p>首先，我们将在  <code>TemperatureInput</code>  组件中用  <code>this.props.temperature</code>  替换<code>this.state.temperature</code> 。 现在，我们假装  <code>this.props.temperature</code>  已经存在，虽然我们将来需要从  <code>Calculator</code>  传递过来：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 之前是: const temperature = this.<span class="keyword">state</span>.temperature;</span><br><span class="line">  const temperature = this.props.temperature;</span><br></pre></td></tr></table></figure><p>我们知道  <a href="http://www.css88.com/react/docs/components-and-props.html#props-are-read-only" target="_blank" rel="noopener">props(属性) 是只读的</a>。 当  <code>temperature</code>  是 本地 state(状态)时， <code>TemperatureInput</code>可以调用  <code>this.setState()</code>  来更改它。 然而，现在  <code>temperature</code>  来自父级作为 prop(属性) ，<code>TemperatureInput</code>  就无法控制它。</p><p>在 React 中，通常通过使组件“受控”的方式来解决。就像 DOM <code></code>一样接受一个  <code>value</code>和一个  <code>onChange</code> prop(属性) ，所以可以定制  <code>TemperatureInput</code>  接受来自其父级  <code>Calculator</code>  的<code>temperature</code>  和  <code>onTemperatureChange</code> 。</p><p>现在，当  <code>TemperatureInput</code>  想要更新其温度时，它就会调用<code>this.props.onTemperatureChange</code>：</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">handleChange(e) &#123;</span><br><span class="line">  // 之前是: this.setState(&#123;temperature: e.<span class="keyword">target</span>.<span class="keyword">value</span>&#125;);</span><br><span class="line">  this.props.onTemperatureChange(e.<span class="keyword">target</span>.<span class="keyword">value</span>);</span><br></pre></td></tr></table></figure><p>请注意，自定义组件中的  <code>temperature</code>  或  <code>onTemperatureChange</code> prop(属性) 名称没有特殊的含义。我们可以命名为任何其他名称，像命名他们为  <code>value</code>  和  <code>onChange</code>，是一个常见的惯例。</p><p><code>onTemperatureChange</code> prop(属性) 和  <code>temperature</code> prop(属性) 一起由父级的  <code>Calculator</code>  组件提供。它将通过修改自己的本地 state(状态) 来处理变更，从而通过新值重新渲染两个输入。我们将很快看到新的  <code>Calculator</code>  实现。</p><p>在修改  <code>Calculator</code>  之前，让我们回顾一下对  <code>TemperatureInput</code>  组件的更改。我们已经从中删除了本地 state(状态) ，不是读取<code>this.state.temperature</code> ，我们现在读取<code>this.props.temperature</code> 。当我们想要更改时， 不是调用  <code>this.setState()</code> ，而是调用<code>this.props.onTemperatureChange()</code>， 这将由  <code>Calculator</code>  提供：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:<span class="xml"><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在我们来看一下  <code>Calculator</code>  组件。</p><p>我们将当前输入的  <code>temperature</code>  和  <code>scale</code>  存储在本地 state(状态) 中。这是我们从输入 “提升” 的 state(状态) ，它将作为两个输入的 “单一数据来源” 。为了渲染两个输入，我们需要知道的所有数据的最小表示。</p><p>例如，如果我们在摄氏度输入框中输入 37 ，则  <code>Calculator</code>  组件的状态将是：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">temperature</span>: <span class="string">'37'</span>,</span><br><span class="line">  scale: <span class="string">'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们稍后将华氏温度字段编辑为 212 ，则  <code>Calculator</code>  组件的状态将是：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">temperature</span>: <span class="string">'212'</span>,</span><br><span class="line">  scale: <span class="string">'f'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以存储两个输入框的值，但事实证明是不必要的。存储最近更改的输入框的值，以及它所表示的度量衡就够了。然后，我们可以基于当前的  <code>temperature</code>(温度) 和  <code>scale</code>(度量衡) 来推断其他输入的值。</p><p>输入框保持同步，因为它们的值是从相同的 state(状态) 计算出来的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleCelsiusChange = <span class="keyword">this</span>.handleCelsiusChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleFahrenheitChange = <span class="keyword">this</span>.handleFahrenheitChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: <span class="string">''</span>, scale: <span class="string">'c'</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;scale: <span class="string">'c'</span>, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;scale: <span class="string">'f'</span>, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.state.scale;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> celsius = scale === <span class="string">'f'</span> ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    <span class="keyword">const</span> fahrenheit = scale === <span class="string">'c'</span> ? tryConvert(temperature, toFahrenheit) : temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=<span class="string">"c"</span></span><br><span class="line">          temperature=&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleCelsiusChange&#125; /&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=<span class="string">"f"</span></span><br><span class="line">          temperature=&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleFahrenheitChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(celsius)&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/jBNjja?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>现在，无论你编辑哪个输入框，<code>Calculator</code>  中的  <code>this.state.temperature</code>  和  <code>this.state.scale</code>都会更新。其中一个输入框获取值，所以任何用户输入都被保留，并且另一个输入总是基于它重新计算值。</p><p>让我们回顾一下编辑输入时会发生什么：</p><ul><li>React 调用在 DOM <code></code>  上的  <code>onChange</code>  指定的函数。在我们的例子中，这是<code>TemperatureInput</code>  组件中的  <code>handleChange</code>  方法。</li><li><code>TemperatureInput</code>  组件中的  <code>handleChange</code>  方法使用 新的期望值 调用<code>this.props.onTemperatureChange()</code>。<code>TemperatureInput</code>  组件中的 props(属性) ，包括<code>onTemperatureChange</code>，由其父组件  <code>Calculator</code>  提供。</li><li>当它预先呈现时， <code>Calculator</code>  指定了摄氏  <code>TemperatureInput</code>  的  <code>onTemperatureChange</code>  是<code>Calculator</code>  的  <code>handleCelsiusChange</code>  方法，并且华氏  <code>TemperatureInput</code>  的<code>onTemperatureChange</code>  是  <code>Calculator</code>  的  <code>handleFahrenheitChange</code>  方法。因此，会根据我们编辑的输入框，分别调用这两个  <code>Calculator</code>  方法。</li><li>在这些方法中， <code>Calculator</code>  组件要求 React 通过使用 新的输入值 和 刚刚编辑的输入框的当前度量衡 来调用  <code>this.setState()</code>  来重新渲染自身。</li><li>React 调用  <code>Calculator</code>  组件的  <code>render</code>  方法来了解 UI 外观应该是什么样子。基于当前温度和激活的度量衡来重新计算两个输入框的值。这里进行温度转换。</li><li>React 使用  <code>Calculator</code>  指定的新 props(属性) 调用各个  <code>TemperatureInput</code>  组件的  <code>render</code>方法。 它了解 UI 外观应该是什么样子。</li><li>React DOM 更新 DOM 以匹配期望的输入值。我们刚刚编辑的输入框接收当前值，另一个输入框更新为转换后的温度。</li></ul><p>每个更新都会执行相同的步骤，以便输入保持同步。</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>在一个 React 应用中，对于任何可变的数据都应该循序“单一数据源”原则。通常情况下，state 首先被添加到需要它进行渲染的组件。然后，如果其它的组件也需要它，你可以提升状态到它们最近的祖先组件。你应该依赖  <a href="http://www.css88.com/react/docs/state-and-lifecycle.html#the-data-flows-down" target="_blank" rel="noopener">从上到下的数据流向</a> ，而不是试图在不同的组件中同步状态。</p><p>提升状态相对于双向绑定方法需要写更多的“模板”代码，但是有一个好处，它可以更方便的找到和隔离 bugs。由于任何 state(状态) 都 “存活” 在若干的组件中，而且可以分别对其独立修改，所以发生错误的可能大大减少。另外，你可以实现任何定制的逻辑来拒绝或者转换用户输入。</p><p>如果某个东西可以从 props(属性) 或者 state(状态) 得到，那么它可能不应该在 state(状态) 中。例如，我们只保存最后编辑的  <code>temperature</code>  和它的  <code>scale</code>，而不是保存  <code>celsiusValue</code>  和<code>fahrenheitValue</code> 。另一个输入框的值总是在  <code>render()</code>  方法中计算得来的。这使我们对其进行清除和四舍五入到其他字段同时不会丢失用户输入的精度。</p><p>当你看到 UI 中的错误，你可以使用  <a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">React 开发者工具</a>来检查 props ，并向上遍历树，直到找到负责更新状态的组件。这使你可以跟踪到 bug 的源头：</p><h1 id="组合和继承对比（Composition-vs-Inheritance）"><a href="#组合和继承对比（Composition-vs-Inheritance）" class="headerlink" title="组合和继承对比（Composition vs Inheritance）"></a>组合和继承对比（Composition vs Inheritance）</h1><p>React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用。</p><p>在本节中，我们将考虑几个问题，即 React 新手经常会使用继承，并展示我们如何通过组合来解决它们。</p><h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><p>一些组件在设计前无法获知自己要使用什么子组件，尤其在  <code>Sidebar</code>  和  <code>Dialog</code>  等通用 “容器” 中比较常见。</p><p>我们建议这种组件使用特别的  <code>children</code> prop 来直接传递 子元素到他们的输出中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这允许其他组件通过嵌套 JSX 传递任意子组件给他们：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        Thank you for visiting our spacecraft!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/ozqNOV?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在  <code>JSX 标签中的任何内容被传递到 `FancyBorder` 组件中，作为一个 `children`prop(属性)。由于 `FancyBorder` 渲染 `{props.children}` 到一个</code>  中，传递的元素会呈现在最终的输出中。</p><p>然而这并不常见，有时候，在一个组件中你可能需要多个 “占位符” 。在这种情况下，你可以使用自定义的 prop(属性)，而不是使用  <code>children</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"SplitPane"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"SplitPane-left"</span>&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="SplitPane-right"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.right&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;SplitPane</span></span><br><span class="line"><span class="regexp">      left=&#123;</span></span><br><span class="line"><span class="regexp">        &lt;Contacts /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwZOJp?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>如  <code>和</code>  等 React 元素本质上也是对象，所以可以将其像其他数据一样作为 props(属性) 传递使用。</p><h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><p>有时候，我们考虑组件作为其它组件的“特殊情况”。例如，我们可能说一个  <code>WelcomeDialog</code>  是<code>Dialog</code>  的一个特殊用例。</p><p>在 React 中，也可以使用组合来实现，一个偏“特殊”的组件渲染出一个偏“通用”的组件，通过 props(属性) 配置它：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Dialog</span></span><br><span class="line"><span class="regexp">      title="Welcome"</span></span><br><span class="line"><span class="regexp">      message="Thank you for visiting our spacecraft!" /</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/kkEaOZ?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>对于用类定义的组件组合也同样适用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class SignUpDialog extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.handleChange = this.handleChange.bind(this);</span></span><br><span class="line"><span class="regexp">    this.handleSignUp = this.handleSignUp.bind(this);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;login: ''&#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Dialog title="Mars Exploration Program"</span></span><br><span class="line"><span class="regexp">              message="How should we refer to you?"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;this.state.login&#125;</span></span><br><span class="line"><span class="regexp">               onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">login</span>: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSignUp() &#123;</span><br><span class="line">    alert(<span class="string">`Welcome aboard, <span class="subst">$&#123;<span class="keyword">this</span>.state.login&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwZbYa?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="如何看待？"><a href="#如何看待？" class="headerlink" title="如何看待？"></a>如何看待？</h2><p>在 Facebook ，我们在千万的组件中使用 React，我们还没有发现任何用例，值得我们建议你用继承层次结构来创建组件。</p><p>使用 props(属性) 和 组合已经足够灵活来明确、安全的定制一个组件的外观和行为。切记，组件可以接受任意的 props(属性) ，包括原始值、React 元素，或者函数。</p><p>如果要在组件之间重用非 UI 功能，我们建议将其提取到单独的 JavaScript 模块中。组件可以导入它并使用该函数，对象或类，而不扩展它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-快速入门&quot;&gt;&lt;a href=&quot;#React-快速入门&quot; class=&quot;headerlink&quot; title=&quot;React 快速入门&quot;&gt;&lt;/a&gt;React 快速入门&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>附录</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javacore/appendix/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javacore/appendix/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a><a href="resources.html">资源</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;附录&quot;&gt;&lt;a href=&quot;#附录&quot; class=&quot;headerlink&quot; title=&quot;附录&quot;&gt;&lt;/a&gt;附录&lt;/h1&gt;&lt;h2 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;&lt;a href=&quot;reso
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法和数据结构</title>
    <link href="https://dunwu.github.io/2019/03/06/algorithm/README/"/>
    <id>https://dunwu.github.io/2019/03/06/algorithm/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h1><blockquote><p>:dart: 所有配套源码整理归档在 <a href="https://github.com/dunwu/algorithm-tutorial" target="_blank" rel="noopener"><strong>algorithm-tutorial</strong></a> 项目中。</p></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote><p><code>数据结构</code> 是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。</p><p>记为：<code>Data_Structure=(D,R)</code>。其中 D 是数据元素的集合，R 是该集合中所有元素之间的关系的有限集合。</p></blockquote><ul><li><strong>常用结构</strong><ul><li><a href="data-structure/array.md">数组</a></li><li><a href="data-structure/stack.md">栈</a></li><li><a href="data-structure/queue.md">队列</a></li><li><a href="data-structure/list.md">链表</a></li><li><a href="data-structure/tree">树</a> - <a href="data-structure/tree/tree.md">树</a>、<a href="data-structure/tree/binary-tree.md">二叉树</a>、<a href="data-structure/tree/red-black-tree.md">红黑树</a></li><li><a href="data-structure/graph.md">图</a></li><li><a href="data-structure/heap.md">堆</a></li><li><a href="data-structure/hash.md">散列表</a></li></ul></li><li><strong>结构算法</strong><ul><li><a href="data-structure/search">查找</a></li><li><a href="data-structure/sort">排序</a> - <a href="data-structure/sort/bubble-sort.md">冒泡排序</a>、<a href="data-structure/sort/quick-sort.md">快速排序</a>、<a href="data-structure/sort/insert-sort.md">直接插入排序</a>、<a href="data-structure/sort/shell-sort.md">希尔排序</a>、<a href="data-structure/sort/selection-sort.md">简单选择排序</a>、<a href="data-structure/sort/heap-sort.md">堆排序</a>、<a href="data-structure/sort/merge-sort.md">归并排序</a>、<a href="data-structure/sort/radix-sort.md">基数排序</a></li></ul></li></ul><h2 id="books-学习资源"><a href="#books-学习资源" class="headerlink" title=":books: 学习资源"></a>:books: 学习资源</h2><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><h4 id="刷题必备"><a href="#刷题必备" class="headerlink" title="刷题必备"></a>刷题必备</h4><ul><li>《剑指 offer》</li><li>《编程之美》</li><li>《编程之法:面试和算法心得》</li><li>《算法谜题》 都是思维题</li></ul><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li>《<a href="https://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00SFZH0DC&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">编程珠玑（第 2 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B0150BMQDM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0150BMQDM&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">编程珠玑（续）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B01LDG2DSG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01LDG2DSG&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">数据结构与算法分析 : C++描述（第 4 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B002WC7NGS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B002WC7NGS&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">数据结构与算法分析 : C 语言描述（第 2 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B01CNP0CG6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01CNP0CG6&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">数据结构与算法分析 : Java 语言描述（第 2 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B009OCFQ0O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B009OCFQ0O&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">算法（第 4 版）</a>》- 这本近千页的书只有 6 章,其中四章分别是排序，查找，图，字符串，足见介绍细致</li></ul><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><ul><li>《<a href="https://www.amazon.cn/gp/product/B00S4HCQUI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00S4HCQUI&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">算法设计与分析基础（第 3 版）</a>》</li><li>《算法引论》 - 告诉你如何创造算法 断货</li><li>《Algorithm Design Manual》 - 算法设计手册 红皮书</li><li><a href="https://www.amazon.cn/gp/product/B00AK7BYJY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00AK7BYJY&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">《算法导论》</a> - 是一本对算法介绍比较全面的经典书籍</li><li>《Algorithms on Strings,Trees and Sequences》</li><li>《Advanced Data Structures》 - 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树 600 块</li></ul><h3 id="参考链接和学习网站"><a href="#参考链接和学习网站" class="headerlink" title="参考链接和学习网站"></a>参考链接和学习网站</h3><ul><li><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">https://github.com/nonstriater/Learn-Algorithms</a></li><li><a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms</a></li><li><a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">https://github.com/kdn251/interviews/blob/master/README-zh-cn.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</a></li><li><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="noopener">July 博客</a><ul><li>《数学建模十大经典算法》</li><li>《数据挖掘领域十大经典算法》</li><li>《十道海量数据处理面试题》</li><li>《数字图像处理领域的二十四个经典算法》</li><li>《精选微软等公司经典的算法面试 100 题》</li></ul></li><li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="noopener">The-Art-Of-Programming-By-July</a></li><li><a href="http://blog.csdn.net/column/details/ms100.html" target="_blank" rel="noopener">微软面试 100 题</a></li><li><a href="http://blog.csdn.net/v_JULY_v/article/details/6460494" target="_blank" rel="noopener">程序员编程艺术</a></li></ul><h3 id="基本算法演示"><a href="#基本算法演示" class="headerlink" title="基本算法演示"></a>基本算法演示</h3><ul><li><a href="http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html" target="_blank" rel="noopener">http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html</a></li><li><a href="http://www.cs.usfca.edu/\~galles/visualization/Algorithms.html" target="_blank" rel="noopener">http://www.cs.usfca.edu/\~galles/visualization/Algorithms.html</a></li></ul><h3 id="编程网站"><a href="#编程网站" class="headerlink" title="编程网站"></a>编程网站</h3><ul><li><a href="http://leetcode.com/" target="_blank" rel="noopener">leetcode</a></li><li><a href="http://openjudge.cn/" target="_blank" rel="noopener">openjudge</a> 开放在线程序评测平台，可以创建自己的 OJ 小组 <a href="http://ac.jobdu.com/index.php" target="_blank" rel="noopener">九度 OJ</a></li><li>这有个<a href="http://www.java3z.com/cwbwebhome/article/article19/res041.html" target="_blank" rel="noopener">ACM 训练方案</a></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/" target="_blank" rel="noopener">高级数据结构和算法</a> 北大教授张铭老师在 coursera 上的课程。完成这门课之时，你将掌握多维数组、广义表、Trie 树、AVL 树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然 coursera 上也还有很多其它算法方面的视频课程。</li><li><a href="https://class.coursera.org/algorithms-001/lecture" target="_blank" rel="noopener">算法设计与分析 Design and Analysis of Algorithms</a> 由北大教授 Wanling Qu 在 coursera 讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf 文件）以便阅读和复习。</li></ul><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法和数据结构&quot;&gt;&lt;a href=&quot;#算法和数据结构&quot; class=&quot;headerlink&quot; title=&quot;算法和数据结构&quot;&gt;&lt;/a&gt;算法和数据结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;:dart: 所有配套源码整理归档在 &lt;a href=&quot;https://g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="https://dunwu.github.io/2019/03/06/bigdata/README/"/>
    <id>https://dunwu.github.io/2019/03/06/bigdata/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><ul><li><a href="MapReduce.md">MapReduce</a></li><li><a href="HDFS.md">HDFS</a></li><li><a href="YARN.md">YARN</a></li><li><a href="hbase">HBase</a><ul><li><a href="hbase/hbase-cli.md">HBase 命令</a></li><li><a href="hbase/hbase-ops.md">HBase 配置</a></li></ul></li></ul><h2 id="books-学习资源"><a href="#books-学习资源" class="headerlink" title=":books: 学习资源"></a>:books: 学习资源</h2><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><p><a href="https://book.douban.com/subject/6523762/" target="_blank" rel="noopener">Hadoop 权威指南</a></p><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大数据&quot;&gt;&lt;a href=&quot;#大数据&quot; class=&quot;headerlink&quot; title=&quot;大数据&quot;&gt;&lt;/a&gt;大数据&lt;/h1&gt;&lt;h2 id=&quot;memo-知识点&quot;&gt;&lt;a href=&quot;#memo-知识点&quot; class=&quot;headerlink&quot; title=&quot;:memo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven 快速指南</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/maven-quickstart/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/maven-quickstart/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven-快速指南"><a href="#Maven-快速指南" class="headerlink" title="Maven 快速指南"></a>Maven 快速指南</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#简介">简介</a><ul><li><a href="#maven-是什么">Maven 是什么</a></li><li><a href="#maven-的生命周期">Maven 的生命周期</a></li><li><a href="#maven-的标准工程结构">Maven 的标准工程结构</a></li><li><a href="#maven-的约定优于配置">Maven 的”约定优于配置”</a></li><li><a href="#maven-的版本规范">Maven 的版本规范</a></li></ul></li><li><a href="#安装">安装</a><ul><li><a href="#配置环境变量">配置环境变量</a></li><li><a href="#本地仓储配置">本地仓储配置</a></li></ul></li><li><a href="#第一个-maven-工程">第一个 Maven 工程</a><ul><li><a href="#在-eclipse-中创建-maven-工程">在 Eclipse 中创建 Maven 工程</a></li><li><a href="#使用-maven-进行构建">使用 Maven 进行构建</a></li></ul></li><li><a href="#使用指导">使用指导</a><ul><li><a href="#如何添加外部依赖-jar-包">如何添加外部依赖 jar 包</a></li><li><a href="#如何寻找-jar-包">如何寻找 jar 包</a></li><li><a href="#如何使用-maven-插件plugin">如何使用 Maven 插件(Plugin)</a></li><li><a href="#如何一次编译多个工程">如何一次编译多个工程</a></li><li><a href="#常用-maven-插件">常用 Maven 插件</a></li><li><a href="#常用-maven-命令">常用 Maven 命令</a></li></ul></li><li><a href="#常见问题">常见问题</a></li><li><a href="#引用和引申">引用和引申</a></li></ul><!-- /TOC --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Maven-是什么"><a href="#Maven-是什么" class="headerlink" title="Maven 是什么"></a>Maven 是什么</h3><p>Maven  是一个项目管理工具。它负责管理项目开发过程中的几乎所有的东西。</p><ul><li><strong>版本</strong> - maven 有自己的版本定义和规则。</li><li><strong>构建</strong> - maven 支持许多种的应用程序类型，对于每一种支持的应用程序类型都定义好了一组构建规则和工具集。</li><li><strong>输出物管理</strong> - maven 可以管理项目构建的产物，并将其加入到用户库中。这个功能可以用于项目组和其他部门之间的交付行为。</li><li><strong>依赖关系</strong> - maven 对依赖关系的特性进行细致的分析和划分，避免开发过程中的依赖混乱和相互污染行为</li><li><strong>文档和构建结果</strong> - maven 的 site 命令支持各种文档信息的发布，包括构建过程的各种输出，javadoc，产品文档等。</li><li><strong>项目关系</strong> - 一个大型的项目通常有几个小项目或者模块组成，用 maven 可以很方便地管理。</li><li><strong>移植性管理</strong> - maven 可以针对不同的开发场景，输出不同种类的输出结果。</li></ul><h3 id="Maven-的生命周期"><a href="#Maven-的生命周期" class="headerlink" title="Maven 的生命周期"></a>Maven 的生命周期</h3><p>maven 把项目的构建划分为不同的生命周期(lifecycle)。粗略一点的话，它这个过程(phase)包括：编译、测试、打包、集成测试、验证、部署。maven 中所有的执行动作(goal)都需要指明自己在这个过程中的执行位置，然后 maven 执行的时候，就依照过程的发展依次调用这些 goal 进行各种处理。</p><p>这个也是 maven 的一个基本调度机制。一般来说，位置稍后的过程都会依赖于之前的过程。当然，maven 同样提供了配置文件，可以依照用户要求，跳过某些阶段。</p><h3 id="Maven-的标准工程结构"><a href="#Maven-的标准工程结构" class="headerlink" title="Maven 的标准工程结构"></a>Maven 的标准工程结构</h3><p>Maven 的标准工程结构如下：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">|-- pom.xml(maven的核心配置文件)</span></span><br><span class="line"><span class="string">|-- src</span></span><br><span class="line"><span class="string">|-- main</span></span><br><span class="line"><span class="string">|-- java(java源代码目录)</span></span><br><span class="line"><span class="string">|-- resources(资源文件目录)</span></span><br><span class="line"><span class="string">|-- test</span></span><br><span class="line">    <span class="string">|-- java(单元测试代码目录)</span></span><br><span class="line"><span class="string">|-- target(输出目录，所有的输出物都存放在这个目录下)</span></span><br><span class="line">    <span class="string">|-- classes(编译后的class文件存放处)</span></span><br></pre></td></tr></table></figure><h3 id="Maven-的”约定优于配置”"><a href="#Maven-的”约定优于配置”" class="headerlink" title="Maven 的”约定优于配置”"></a>Maven 的”约定优于配置”</h3><p>所谓的”约定优于配置”，在 maven 中并不是完全不可以修改的，他们只是一些配置的默认值而已。但是除非必要，并不需要去修改那些约定内容。maven 默认的文件存放结构如下：</p><p>每一个阶段的任务都知道怎么正确完成自己的工作，比如 compile 任务就知道从 src/main/java 下编译所有的 java 文件，并把它的输出 class 文件存放到 target/classes 中。</p><p>对 maven 来说，采用”约定优于配置”的策略可以减少修改配置的工作量，也可以降低学习成本，更重要的是，给项目引入了统一的规范。</p><h3 id="Maven-的版本规范"><a href="#Maven-的版本规范" class="headerlink" title="Maven 的版本规范"></a>Maven 的版本规范</h3><p>maven 使用如下几个要素来唯一定位某一个输出物：</p><ul><li><strong>groupId</strong> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 JAVA 的包的结构。例如 org.apache</li><li><strong>artifactId</strong> - 单独项目的唯一标识符。比如我们的 tomcat, commons 等。不要在 artifactId 中包含点号(.)。</li><li><strong>version</strong> - 一个项目的特定版本。</li><li><strong>packaging</strong> - 项目的类型，默认是 jar，描述了项目打包后的输出。类型为 jar 的项目产生一个 JAR 文件，类型为 war 的项目产生一个 web 应用。</li></ul><p>maven 有自己的版本规范，一般是如下定义  <code>&lt;major version&gt;</code>、<code>&lt;minor version&gt;</code>、<code>&lt;incremental version&gt;-&lt;qualifier&gt;</code> ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major,minor,incremental 部分用数字比   较，qualifier 部分用字符串比较，所以要小心  alpha-2 和 alpha-15 的比较关系，最好用  alpha-02 的格式。</p><p>maven 在版本管理时候可以使用几个特殊的字符串  SNAPSHOT，LATEST，RELEASE。比如”1.0-SNAPSHOT”。各个部分的含义和处理逻辑如下说明：</p><ul><li><strong>SNAPSHOT</strong> - 这个版本一般用于开发过程中，表示不稳定的版本。</li><li><strong>LATEST</strong> - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。</li><li><strong>RELEASE</strong> - 指最后一个发布版。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">官网下载地址</a></p></blockquote><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><blockquote><p><strong>注意：安装 maven 之前，必须先确保你的机器中已经安装了 JDK。</strong></p></blockquote><p>1．解压压缩包（以 apache-maven-3.3.9-bin.zip 为例）</p><p>2．添加环境变量 MAVEN_HOME，值为 apache-maven-3.3.9 的安装路径</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195009.png"></div><br></p><p>3．在 Path 环境变量的变量值末尾添加%MAVEN_HOME%\bin</p><p>4．在 cmd 输入 mvn –version，如果出现 maven 的版本信息，说明配置成功。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195046.png"></div><br></p><h3 id="本地仓储配置"><a href="#本地仓储配置" class="headerlink" title="本地仓储配置"></a>本地仓储配置</h3><p>从中央仓库下载的 jar 包，都会统一存放到本地仓库中。我们需要配置本地仓库的位置。</p><p>打开 maven 安装目录，打开 conf 目录下的 setting.xml 文件。</p><p>可以参照下图配置本地仓储位置。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195104.png"></div><br></p><h2 id="第一个-Maven-工程"><a href="#第一个-Maven-工程" class="headerlink" title="第一个 Maven 工程"></a>第一个 Maven 工程</h2><h3 id="在-Eclipse-中创建-Maven-工程"><a href="#在-Eclipse-中创建-Maven-工程" class="headerlink" title="在 Eclipse 中创建 Maven 工程"></a>在 Eclipse 中创建 Maven 工程</h3><h4 id="Maven-插件"><a href="#Maven-插件" class="headerlink" title="Maven 插件"></a>Maven 插件</h4><p>在 Eclipse 中创建 Maven 工程，需要安装 Maven 插件。</p><p>一般较新版本的 Eclipse 都会带有 Maven 插件，如果你的 Eclipse 中已经有 Maven 插件，可以跳过这一步骤。</p><p>点击 Help -&gt; Eclipse Marketplace，搜索 maven 关键字，选择安装红框对应的 Maven 插件。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195117.png"></div><br></p><h4 id="Maven-环境配置"><a href="#Maven-环境配置" class="headerlink" title="Maven 环境配置"></a>Maven 环境配置</h4><p>点击 Window -&gt; Preferences</p><p>如下图所示，配置 settings.xml 文件的位置</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195128.png"></div><br></p><h4 id="创建-Maven-工程"><a href="#创建-Maven-工程" class="headerlink" title="创建 Maven 工程"></a>创建 Maven 工程</h4><p>File -&gt; New -&gt; Maven Project -&gt; Next，在接下来的窗口中会看到一大堆的项目模板，选择合适的模板。</p><p>接下来设置项目的参数，如下：</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195151.png"></div><br></p><p><strong>groupId</strong>是项目组织唯一的标识符，实际对应 JAVA 的包的结构，是 main 目录里 java 的目录结构。</p><p><strong>artifactId</strong>就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。</p><p>点击 Finish，Eclipse 会创建一个 Maven 工程。</p><h3 id="使用-Maven-进行构建"><a href="#使用-Maven-进行构建" class="headerlink" title="使用 Maven 进行构建"></a>使用 Maven 进行构建</h3><p><strong>Eclipse 中构建方式</strong></p><p>在 Elipse 项目上右击  -&gt; Run As  就能看到很多 Maven 操作。这些操作和 maven 命令是等效的。例如 Maven clean，等同于 mvn clean 命令。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195208.png"></div><br></p><p>你也可以点击 Maven build，输入组合命令，并保存下来。如下图：</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195219.png"></div><br></p><p><strong>Maven 命令构建方式</strong></p><p>当然，你也可以直接使用 maven 命令进行构建。</p><p>进入工程所在目录，输入 maven 命令就可以了。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195243.png"></div><br></p><h2 id="使用指导"><a href="#使用指导" class="headerlink" title="使用指导"></a>使用指导</h2><h3 id="如何添加外部依赖-jar-包"><a href="#如何添加外部依赖-jar-包" class="headerlink" title="如何添加外部依赖 jar 包"></a>如何添加外部依赖 jar 包</h3><p>在 Maven 工程中添加依赖 jar 包，很简单，只要在 POM 文件中引入对应的<code>&lt;dependency&gt;</code>标签即可。</p><p>参考下例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zp.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MavenDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>MavenDemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;dependency&gt;</code> 标签最常用的四个属性标签：</p><ul><li><code>&lt;groupId&gt;</code> - 项目组织唯一的标识符，实际对应 JAVA 的包的结构。</li><li><code>&lt;artifactId&gt;</code> - 项目唯一的标识符，实际对应项目的名称，就是项目根目录的名称。</li><li><code>&lt;version&gt;</code> - jar 包的版本号。可以直接填版本数字，也可以在 properties 标签中设置属性值。</li><li><code>&lt;scope&gt;</code> - jar 包的作用范围。可以填写 compile、runtime、test、system 和 provided。用来在编译、测试等场景下选择对应的 classpath。</li></ul><h3 id="如何寻找-jar-包"><a href="#如何寻找-jar-包" class="headerlink" title="如何寻找 jar 包"></a>如何寻找 jar 包</h3><p>可以在 <a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a> 站点搜寻你想要的 jar 包版本</p><p>例如，想要使用 log4j，可以找到需要的版本号，然后拷贝对应的 maven 标签信息，将其添加到 pom .xml 文件中。</p><p><br><div align="center"><img src="http://oyz7npk35.bkt.clouddn.com//image/java/libs/maven/maven-quickstart-10.png"></div><br></p><h3 id="如何使用-Maven-插件-Plugin"><a href="#如何使用-Maven-插件-Plugin" class="headerlink" title="如何使用 Maven 插件(Plugin)"></a>如何使用 Maven 插件(Plugin)</h3><p>要添加 Maven 插件，可以在 pom.xml 文件中添加 <code>&lt;plugin&gt;</code> 标签。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;configuration&gt;</code> 标签用来配置插件的一些使用参数。</p><h3 id="如何一次编译多个工程"><a href="#如何一次编译多个工程" class="headerlink" title="如何一次编译多个工程"></a>如何一次编译多个工程</h3><p>在 Maven 中，允许一个 Maven Project 中有多个 Maven Module</p><p>1.创建 maven 父工程步骤：new–&gt;other–&gt;选择 maven project–&gt;next–&gt;勾选 create a simple project–&gt;next–&gt;填写 Group Id、Artifact Id、Version –&gt; packaging 选择 pom–&gt;finish。</p><p><br><div align="center"><img src="http://oyz7npk35.bkt.clouddn.com//image/java/libs/maven/maven-quickstart-11.png"></div><br></p><p>2.创建 maven 子工程步骤：选中刚才创建的父工程右键–&gt;new–&gt;other–&gt;选择 maven module–&gt;next–&gt;勾选 create a simple project–&gt;填写 module name（其实就是 artifact id）–&gt;next–&gt;GAV 继承父工程–&gt;packaging 选择你需要的–&gt;finish。</p><p><br><div align="center"><img src="http://oyz7npk35.bkt.clouddn.com//image/java/libs/maven/maven-quickstart-12.png"></div><br></p><p>3.完成，刷新父工程；如有多个子工程，继续按照第二步骤创建。</p><p><br><div align="center"><img src="http://oyz7npk35.bkt.clouddn.com//image/java/libs/maven/maven-quickstart-13.png"></div><br></p><p>这时打开 XXX 中的 pom.xml 可以看到其中有以下标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>xxx1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>选择编译 XXX 时，会依次对它的所有 Module 执行相同操作。</p><h3 id="常用-Maven-插件"><a href="#常用-Maven-插件" class="headerlink" title="常用 Maven 插件"></a>常用 Maven 插件</h3><h4 id="maven-antrun-plugin"><a href="#maven-antrun-plugin" class="headerlink" title="maven-antrun-plugin"></a>maven-antrun-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-antrun-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-antrun-plugin/</a></p><p>maven-antrun-plugin 能让用户在 Maven 项目中运行 Ant 任务。用户可以直接在该插件的配置以 Ant 的方式编写 Target，  然后交给该插件的 run 目标去执行。在一些由 Ant 往 Maven 迁移的项目中，该插件尤其有用。此外当你发现需要编写一些自定义程度很高的任务，同时又觉   得 Maven 不够灵活时，也可以以 Ant 的方式实现之。maven-antrun-plugin 的 run 目标通常与生命周期绑定运行。</p><h4 id="maven-archetype-plugin"><a href="#maven-archetype-plugin" class="headerlink" title="maven-archetype-plugin"></a>maven-archetype-plugin</h4><p><a href="http://maven.apache.org/archetype/maven-archetype-plugin/" target="_blank" rel="noopener">http://maven.apache.org/archetype/maven-archetype-plugin/</a></p><p>Archtype 指项目的骨架，Maven 初学者最开始执行的 Maven 命令可能就是<strong>mvn archetype:generate</strong>，这实际上就是让 maven-archetype-plugin 生成一个很简单的项目骨架，帮助开发者快速上手。可能也有人看到一些文档写了<strong>mvn archetype:create</strong>，  但实际上 create 目标已经被弃用了，取而代之的是 generate 目标，该目标使用交互式的方式提示用户输入必要的信息以创建项目，体验更好。 maven-archetype-plugin 还有一些其他目标帮助用户自己定义项目原型，例如你由一个产品需要交付给很多客户进行二次开发，你就可以为   他们提供一个 Archtype，帮助他们快速上手。</p><h4 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="maven-assembly-plugin"></a>maven-assembly-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-assembly-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-assembly-plugin/</a></p><p>maven-assembly-plugin 的用途是制作项目分发包，该分发包可能包含了项目的可执行文件、源代码、readme、平台脚本等等。 maven-assembly-plugin 支持各种主流的格式如 zip、tar.gz、jar 和 war 等，具体打包哪些文件是高度可控的，例如用户可以   按文件级别的粒度、文件集级别的粒度、模块级别的粒度、以及依赖级别的粒度控制打包，此外，包含和排除配置也是支持的。maven-assembly- plugin 要求用户使用一个名为<code>assembly.xml</code>的元数据文件来表述打包，它的 single 目标可以直接在命令行调用，也可以被绑定至生命周期。</p><h4 id="maven-dependency-plugin"><a href="#maven-dependency-plugin" class="headerlink" title="maven-dependency-plugin"></a>maven-dependency-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-dependency-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-dependency-plugin/</a></p><p>maven-dependency-plugin 最大的用途是帮助分析项目依赖，<strong>dependency:list</strong>能够列出项目最终解析到的依赖列表，<strong>dependency:tree</strong>能进一步的描绘项目依赖树，<strong>dependency:analyze</strong>可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin 还有很多目标帮助你操作依赖文件，例如<strong>dependency:copy-dependencies</strong>能将项目依赖从本地 Maven 仓库复制到某个特定的文件夹下面。</p><h4 id="maven-enforcer-plugin"><a href="#maven-enforcer-plugin" class="headerlink" title="maven-enforcer-plugin"></a>maven-enforcer-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-enforcer-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-enforcer-plugin/</a></p><p>在一个稍大一点的组织或团队中，你无法保证所有成员都熟悉 Maven，那他们做一些比较愚蠢的事情就会变得很正常，例如给项目引入了外部的  SNAPSHOT 依赖而导致构建不稳定，使用了一个与大家不一致的 Maven 版本而经常抱怨构建出现诡异问题。maven-enforcer- plugin 能够帮助你避免之类问题，它允许你创建一系列规则强制大家遵守，包括设定 Java 版本、设定 Maven 版本、禁止某些依赖、禁止  SNAPSHOT 依赖。只要在一个父 POM 配置规则，然后让大家继承，当规则遭到破坏的时候，Maven 就会报错。除了标准的规则之外，你还可以扩展该插   件，编写自己的规则。maven-enforcer-plugin 的 enforce 目标负责检查规则，它默认绑定到生命周期的 validate 阶段。</p><h4 id="maven-help-plugin"><a href="#maven-help-plugin" class="headerlink" title="maven-help-plugin"></a>maven-help-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-help-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-help-plugin/</a><br>maven-help-plugin 是一个小巧的辅助工具，最简单的<strong>help:system</strong>可以打印所有可用的环境变量和 Java 系统属性。<strong>help:effective-pom</strong>和<strong>help:effective-settings</strong>最   为有用，它们分别打印项目的有效 POM 和有效 settings，有效 POM 是指合并了所有父 POM（包括 Super POM）后的 XML，当你不确定 POM 的某些信息从何而来时，就可以查看有效 POM。有效 settings 同理，特别是当你发现自己配置的  settings.xml 没有生效时，就可以用<strong>help:effective-settings</strong>来验证。此外，maven-help-plugin 的 describe 目标可以帮助你描述任何一个 Maven 插件的信息，还有 all-profiles 目标和 active-profiles 目标帮助查看项目的 Profile。</p><h4 id="maven-release-plugin"><a href="#maven-release-plugin" class="headerlink" title="maven-release-plugin"></a>maven-release-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-release-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-release-plugin/</a></p><p>maven-release-plugin 的用途是帮助自动化项目版本发布，它依赖于 POM 中的 SCM 信息。<strong>release:prepare</strong>用来准备版本发布，具体的工作包括检查是否有未提交代码、检查是否有 SNAPSHOT 依赖、升级项目的 SNAPSHOT 版本至 RELEASE 版本、为项目打标签等等。<strong>release:perform</strong>则   是签出标签中的 RELEASE 源码，构建并发布。版本发布是非常琐碎的工作，它涉及了各种检查，而且由于该工作仅仅是偶尔需要，因此手动操作很容易遗漏一   些细节，maven-release-plugin 让该工作变得非常快速简便，不易出错。maven-release-plugin 的各种目标通常直接在   命令行调用，因为版本发布显然不是日常构建生命周期的一部分。</p><h4 id="maven-resources-plugin"><a href="#maven-resources-plugin" class="headerlink" title="maven-resources-plugin"></a>maven-resources-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-resources-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-resources-plugin/</a></p><p>为了使项目结构更为清晰，Maven 区别对待 Java 代码文件和资源文件，maven-compiler-plugin 用来编译 Java 代码，maven-resources-plugin 则用来处理资源文件。默认的主资源文件目录是<code>src/main/resources</code>，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置 maven-resources-plugin 来实现。此外，资源文件过滤也是 Maven 的一大特性，你可以在资源文件中使用<em>\${propertyName}</em>形式的 Maven 属性，然后配置 maven-resources-plugin 开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者 Profile 传入属性的值，以实现更为灵活的构建。</p><h4 id="maven-surefire-plugin"><a href="#maven-surefire-plugin" class="headerlink" title="maven-surefire-plugin"></a>maven-surefire-plugin</h4><p><a href="http://maven.apache.org/plugins/maven-surefire-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-surefire-plugin/</a></p><p>可能是由于历史的原因，Maven 2/3 中用于执行测试的插件不是 maven-test-plugin，而是 maven-surefire-plugin。其实大部分时间内，只要你的测试   类遵循通用的命令约定（以 Test 结尾、以 TestCase 结尾、或者以 Test 开头），就几乎不用知晓该插件的存在。然而在当你想要跳过测试、排除某些   测试类、或者使用一些 TestNG 特性的时候，了解 maven-surefire-plugin 的一些配置选项就很有用了。例如  <strong>mvn test -Dtest=FooTest</strong>  这样一条命令的效果是仅运行 FooTest 测试类，这是通过控制 maven-surefire-plugin 的 test 参数实现的。</p><h4 id="build-helper-maven-plugin"><a href="#build-helper-maven-plugin" class="headerlink" title="build-helper-maven-plugin"></a>build-helper-maven-plugin</h4><p><a href="http://mojo.codehaus.org/build-helper-maven-plugin/" target="_blank" rel="noopener">http://mojo.codehaus.org/build-helper-maven-plugin/</a></p><p>Maven 默认只允许指定一个主 Java 代码目录和一个测试 Java 代码目录，虽然这其实是个应当尽量遵守的约定，但偶尔你还是会希望能够指定多个   源码目录（例如为了应对遗留项目），build-helper-maven-plugin 的 add-source 目标就是服务于这个目的，通常它被绑定到   默认生命周期的 generate-sources 阶段以添加额外的源码目录。需要强调的是，这种做法还是不推荐的，因为它破坏了  Maven 的约定，而且可能会遇到其他严格遵守约定的插件工具无法正确识别额外的源码目录。</p><p>build-helper-maven-plugin 的另一个非常有用的目标是 attach-artifact，使用该目标你可以以 classifier 的形式选取部分项目文件生成附属构件，并同时 install 到本地仓库，也可以 deploy 到远程仓库。</p><h4 id="exec-maven-plugin"><a href="#exec-maven-plugin" class="headerlink" title="exec-maven-plugin"></a>exec-maven-plugin</h4><p><a href="http://mojo.codehaus.org/exec-maven-plugin/" target="_blank" rel="noopener">http://mojo.codehaus.org/exec-maven-plugin/</a></p><p>exec-maven-plugin 很好理解，顾名思义，它能让你运行任何本地的系统程序，在某些特定情况下，运行一个 Maven 外部的程序可能就是最简单的问题解决方案，这就是<strong>exec:exec</strong>的   用途，当然，该插件还允许你配置相关的程序运行参数。除了 exec 目标之外，exec-maven-plugin 还提供了一个 java 目标，该目标要求你   提供一个 mainClass 参数，然后它能够利用当前项目的依赖作为 classpath，在同一个 JVM 中运行该 mainClass。有时候，为了简单的   演示一个命令行 Java 程序，你可以在 POM 中配置好 exec-maven-plugin 的相关运行参数，然后直接在命令运行<strong>mvn exec:java</strong>  以查看运行效果。</p><h4 id="jetty-maven-plugin"><a href="#jetty-maven-plugin" class="headerlink" title="jetty-maven-plugin"></a>jetty-maven-plugin</h4><p><a href="http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin" target="_blank" rel="noopener">http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin</a></p><p>在进行 Web 开发的时候，打开浏览器对应用进行手动的测试几乎是无法避免的，这种测试方法通常就是将项目打包成 war 文件，然后部署到 Web 容器   中，再启动容器进行验证，这显然十分耗时。为了帮助开发者节省时间，jetty-maven-plugin 应运而生，它完全兼容  Maven 项目的目录结构，能够周期性地检查源文件，一旦发现变更后自动更新到内置的 Jetty Web 容器中。做一些基本配置后（例如 Web 应用的 contextPath 和自动扫描变更的时间间隔），你只要执行  <strong>mvn jetty:run</strong> ，然后在 IDE 中修改代码，代码经 IDE 自动编译后产生变更，再由 jetty-maven-plugin 侦测到后更新至 Jetty 容器，这时你就可以直接   测试 Web 页面了。需要注意的是，jetty-maven-plugin 并不是宿主于 Apache 或 Codehaus 的官方插件，因此使用的时候需要额外   的配置<code>settings.xml</code>的 pluginGroups 元素，将 org.mortbay.jetty 这个 pluginGroup 加入。</p><h4 id="versions-maven-plugin"><a href="#versions-maven-plugin" class="headerlink" title="versions-maven-plugin"></a>versions-maven-plugin</h4><p><a href="http://mojo.codehaus.org/versions-maven-plugin/" target="_blank" rel="noopener">http://mojo.codehaus.org/versions-maven-plugin/</a></p><p>很多 Maven 用户遇到过这样一个问题，当项目包含大量模块的时候，为他们集体更新版本就变成一件烦人的事情，到底有没有自动化工具能帮助完成这件   事情呢？（当然你可以使用 sed 之类的文本操作工具，不过不在本文讨论范围）答案是肯定的，versions-maven- plugin 提供了很多目标帮助你管理 Maven 项目的各种版本信息。例如最常用的，命令  <strong>mvn versions:set -DnewVersion=1.1-SNAPSHOT</strong>  就能帮助你把所有模块的版本更新到 1.1-SNAPSHOT。该插件还提供了其他一些很有用的目标，display-dependency- updates 能告诉你项目依赖有哪些可用的更新；类似的 display-plugin-updates 能告诉你可用的插件更新；然后 use- latest-versions 能自动帮你将所有依赖升级到最新版本。最后，如果你对所做的更改满意，则可以使用  <strong>mvn versions:commit</strong>  提交，不满意的话也可以使用  <strong>mvn versions:revert</strong>  进行撤销。</p><p>更多详情请参考<a href="https://maven.apache.org/plugins/" target="_blank" rel="noopener">https://maven.apache.org/plugins/</a></p><h3 id="常用-Maven-命令"><a href="#常用-Maven-命令" class="headerlink" title="常用 Maven 命令"></a>常用 Maven 命令</h3><table><thead><tr><th><strong>生命周期</strong></th><th><strong>阶段描述</strong></th></tr></thead><tbody><tr><td>mvn validate</td><td>验证项目是否正确，以及所有为了完整构建必要的信息是否可用</td></tr><tr><td>mvn generate-sources</td><td>生成所有需要包含在编译过程中的源代码</td></tr><tr><td>mvn process-sources</td><td>处理源代码，比如过滤一些值</td></tr><tr><td>mvn generate-resources</td><td>生成所有需要包含在打包过程中的资源文件</td></tr><tr><td>mvn process-resources</td><td>复制并处理资源文件至目标目录，准备打包</td></tr><tr><td>mvn compile</td><td>编译项目的源代码</td></tr><tr><td>mvn process-classes</td><td>后处理编译生成的文件，例如对 Java 类进行字节码增强（bytecode enhancement）</td></tr><tr><td>mvn generate-test-sources</td><td>生成所有包含在测试编译过程中的测试源码</td></tr><tr><td>mvn process-test-sources</td><td>处理测试源码，比如过滤一些值</td></tr><tr><td>mvn generate-test-resources</td><td>生成测试需要的资源文件</td></tr><tr><td>mvn process-test-resources</td><td>复制并处理测试资源文件至测试目标目录</td></tr><tr><td>mvn test-compile</td><td>编译测试源码至测试目标目录</td></tr><tr><td>mvn test</td><td>使用合适的单元测试框架运行测试。这些测试应该不需要代码被打包或发布</td></tr><tr><td>mvn prepare-package</td><td>在真正的打包之前，执行一些准备打包必要的操作。这通常会产生一个包的展开的处理过的版本（将会在 Maven 2.1+中实现）</td></tr><tr><td>mvn package</td><td>将编译好的代码打包成可分发的格式，如 JAR，WAR，或者 EAR</td></tr><tr><td>mvn pre-integration-test</td><td>执行一些在集成测试运行之前需要的动作。如建立集成测试需要的环境</td></tr><tr><td>mvn integration-test</td><td>如果有必要的话，处理包并发布至集成测试可以运行的环境</td></tr><tr><td>mvn post-integration-test</td><td>执行一些在集成测试运行之后需要的动作。如清理集成测试环境。</td></tr><tr><td>mvn verify</td><td>执行所有检查，验证包是有效的，符合质量规范</td></tr><tr><td>mvn install</td><td>安装包至本地仓库，以备本地的其它项目作为依赖使用</td></tr><tr><td>mvn deploy</td><td>复制最终的包至远程仓库，共享给其它开发人员和项目（通常和一次正式的发布相关）</td></tr></tbody></table><p><strong>使用参数</strong></p><p><code>-Dmaven.test.skip=true</code>:  跳过单元测试(eg: mcn clean package -Dmaven.test.skip=true)</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>dependencies 和 dependencyManagement，plugins 和 pluginManagement 有什么区别？</p><p>dependencyManagement 是表示依赖 jar 包的声明，即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被继承。</p><p>dependencyManagement 的一个使用案例是当有父子项目的时候，父项目中可以利用 dependencyManagement 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该插件的时候，就可以在子项目中 dependencies 节点只配置  groupId  和  artifactId 就可以完成插件的引用。</p><p>dependencyManagement 主要是为了统一管理插件，确保所有子项目使用的插件版本保持一致，类似的还有 plugins 和 pluginManagement。</p><h2 id="引用和引申"><a href="#引用和引申" class="headerlink" title="引用和引申"></a>引用和引申</h2><ul><li><a href="https://maven.apache.org/index.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="http://www.oschina.net/question/158170_29368" target="_blank" rel="noopener">http://www.oschina.net/question/158170_29368</a></li><li><a href="http://www.cnblogs.com/crazy-fox/archive/2012/02/09/2343722.html" target="_blank" rel="noopener">http://www.cnblogs.com/crazy-fox/archive/2012/02/09/2343722.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven-快速指南&quot;&gt;&lt;a href=&quot;#Maven-快速指南&quot; class=&quot;headerlink&quot; title=&quot;Maven 快速指南&quot;&gt;&lt;/a&gt;Maven 快速指南&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven 之 pom.xml 详解</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/maven-pom/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/maven-pom/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven-之-pom-xml-详解"><a href="#Maven-之-pom-xml-详解" class="headerlink" title="Maven 之 pom.xml 详解"></a>Maven 之 pom.xml 详解</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#简介">简介</a><ul><li><a href="#什么是-pom">什么是 pom？</a></li><li><a href="#pom-配置一览">pom 配置一览</a></li></ul></li><li><a href="#基本配置">基本配置</a><ul><li><a href="#maven-坐标">maven 坐标</a></li></ul></li><li><a href="#依赖配置">依赖配置</a><ul><li><a href="#dependencies">dependencies</a></li><li><a href="#parent">parent</a></li><li><a href="#dependencymanagement">dependencyManagement</a></li><li><a href="#modules">modules</a></li><li><a href="#properties">properties</a></li></ul></li><li><a href="#构建配置">构建配置</a><ul><li><a href="#build">build</a></li><li><a href="#reporting">reporting</a></li></ul></li><li><a href="#项目信息">项目信息</a></li><li><a href="#环境配置">环境配置</a><ul><li><a href="#issuemanagement">issueManagement</a></li><li><a href="#cimanagement">ciManagement</a></li><li><a href="#mailinglists">mailingLists</a></li><li><a href="#scm">scm</a></li><li><a href="#prerequisites">prerequisites</a></li><li><a href="#repositories">repositories</a></li><li><a href="#pluginrepositories">pluginRepositories</a></li><li><a href="#distributionmanagement">distributionManagement</a></li><li><a href="#profiles">profiles</a></li></ul></li></ul><!-- /TOC --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a href="http://maven.apache.org/xsd/maven-4.0.0.xsd" target="_blank" rel="noopener">The POM 4.0.0 XSD</a> and <a href="http://maven.apache.org/ref/current/maven-model/maven.html" target="_blank" rel="noopener">descriptor reference documentation</a></li></ul><h3 id="什么是-pom？"><a href="#什么是-pom？" class="headerlink" title="什么是 pom？"></a>什么是 pom？</h3><p>POM 是 Project Object Model 的缩写，即项目对象模型。</p><p>pom.xml 就是 maven 的配置文件，用以描述项目的各种信息。</p><h3 id="pom-配置一览"><a href="#pom-配置一览" class="headerlink" title="pom 配置一览"></a>pom 配置一览</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- The Basics --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>...<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>...<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>...<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Build Settings --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- More Project Information --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>...<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>...<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>...<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">licenses</span>&gt;</span>...<span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">organization</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">developers</span>&gt;</span>...<span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">contributors</span>&gt;</span>...<span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Environment Settings --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span>...<span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scm</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span>...<span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span>...<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ul><li><strong>project</strong>：<code>project</code> 是 pom.xml 中描述符的根。</li><li><strong>modelVersion</strong>：<code>modelVersion</code> 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。</li></ul><p>一般 jar 包被识别为： <code>groupId:artifactId:version</code> 的形式。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="maven-坐标"><a href="#maven-坐标" class="headerlink" title="maven 坐标"></a>maven 坐标</h3><p>在 maven 中，根据 <code>groupId</code>、<code>artifactId</code>、<code>version</code> 组合成 <code>groupId:artifactId:version</code> 来唯一识别一个 jar 包。</p><ul><li><p><strong>groupId</strong>：团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。</p></li><li><p><strong>artifactId</strong>：单独项目的唯一标识符。比如我们的 tomcat、commons 等。不要在 artifactId 中包含点号(.)。</p></li><li><p><strong>version</strong>：一个项目的特定版本。</p><p>maven 有自己的版本规范，一般是如下定义  major version、minor version、incremental version-qualifier ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major、minor、incremental 部分用数字比较，qualifier 部分用字符串比较，所以要小心  alpha-2 和 alpha-15 的比较关系，最好用 alpha-02 的格式。</p><p>maven 在版本管理时候可以使用几个特殊的字符串  SNAPSHOT、LATEST、RELEASE。比如 “1.0-SNAPSHOT”。各个部分的含义和处理逻辑如下说明：</p><ul><li><strong>SNAPSHOT</strong>：这个版本一般用于开发过程中，表示不稳定的版本。</li><li><strong>LATEST</strong>：指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。</li><li><strong>RELEASE</strong> ：指最后一个发布版。</li></ul></li><li><p><strong>packaging</strong>：项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。</p></li></ul><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-embedder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>groupId</strong>, <strong>artifactId</strong>, <strong>version</strong> ：和基本配置中的 <code>groupId</code>、<code>artifactId</code>、<code>version</code> 意义相同。</li><li><strong>type</strong>：对应 <code>packaging</code> 的类型，如果不使用 <code>type</code> 标签，maven 默认为 jar。</li><li><strong>scope</strong>：此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：<ul><li><strong>compile</strong> - 如果没有指定 <code>scope</code> 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。</li><li><strong>provided</strong> - 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。</li><li><strong>runtime</strong> - 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。</li><li><strong>test</strong> - 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。</li><li><strong>system</strong> - 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。</li></ul></li><li><strong>systemPath</strong>：仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 <code>propertie</code> 来指定特定的路径，如\$ {java.home} / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。</li><li><strong>optional</strong>：<code>optional</code> 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。</li><li><strong>exclusions</strong>：包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 <code>groupId</code> 和 <code>artifactId</code>。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。</li></ul><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><p>maven 支持继承功能。子 POM 可以使用 <code>parent</code> 指定父 POM ，然后继承其配置。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../my-parent<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>relativePath</strong>：注意 <code>relativePath</code> 元素。在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。</li></ul><h3 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h3><p><code>dependencyManagement</code> 是表示依赖 jar 包的声明。即你在项目中的 <code>dependencyManagement</code> 下声明了依赖，maven 不会加载该依赖，<code>dependencyManagement</code> 声明可以被子 POM 继承。</p><p><code>dependencyManagement</code> 的一个使用案例是当有父子项目的时候，父项目中可以利用 <code>dependencyManagement</code> 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 <code>dependencies</code> 节点只配置  <code>groupId</code>  和  <code>artifactId</code> 就可以完成依赖的引用。</p><p><code>dependencyManagement</code> 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有<code>plugins</code>和<code>pluginManagement</code>。</p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>子模块列表。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>another-project<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>third-project/pom-example.xml<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 <code>${propertie}</code> 。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>build 可以分为 “project build” 和 “profile build”。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!-- "Project Build" contains more elements than just the BaseBuild set --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- "Profile Build" contains a subset of "Project Build"s elements --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本构建配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span>install<span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;artifactId&#125;-$&#123;version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span>filters/filter1.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>defaultGoal</strong> : 默认执行目标或阶段。如果给出了一个目标，它应该被定义为它在命令行中（如 jar：jar）。如果定义了一个阶段（如安装），也是如此。</p><p><strong>directory</strong> ：构建时的输出路径。默认为：<code>${basedir}/target</code> 。</p><p><strong>finalName</strong> ：这是项目的最终构建名称（不包括文件扩展名，例如：my-project-1.0.jar）</p><p><strong>filter</strong> ：定义 <code>* .properties</code> 文件，其中包含适用于接受其设置的资源的属性列表（如下所述）。换句话说，过滤器文件中定义的“name = value”对在代码中替换\$ {name}字符串。</p><h4 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h4><p>资源的配置。资源文件通常不是代码，不需要编译，而是在项目需要捆绑使用的内容。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/plexus<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/plexus<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>configuration.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>resources</strong>: 资源元素的列表，每个资源元素描述与此项目关联的文件和何处包含文件。</li><li><strong>targetPath</strong>: 指定从构建中放置资源集的目录结构。目标路径默认为基本目录。将要包装在 jar 中的资源的通常指定的目标路径是 META-INF。</li><li><strong>filtering</strong>: 值为 true 或 false。表示是否要为此资源启用过滤。请注意，该过滤器 <code>* .properties</code> 文件不必定义为进行过滤 - 资源还可以使用默认情况下在 POM 中定义的属性（例如\$ {project.version}），并将其传递到命令行中“-D”标志（例如，“-Dname = value”）或由 properties 元素显式定义。过滤文件覆盖上面。</li><li><strong>directory</strong>: 值定义了资源的路径。构建的默认目录是<code>${basedir}/src/main/resources</code>。</li><li><strong>includes</strong>: 一组文件匹配模式，指定目录中要包括的文件，使用*作为通配符。</li><li><strong>excludes</strong>: 与 <code>includes</code> 类似，指定目录中要排除的文件，使用*作为通配符。注意：如果 <code>include</code> 和 <code>exclude</code> 发生冲突，maven 会以 <code>exclude</code> 作为有效项。</li><li><strong>testResources</strong>: <code>testResources</code>  与 <code>resources</code> 功能类似，区别仅在于：<code>testResources</code>  指定的资源仅用于 test 阶段，并且其默认资源目录为：<code>${basedir}/src/test/resources</code> 。</li></ul><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>test<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span>...<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>groupId</strong>, <strong>artifactId</strong>, <strong>version</strong> ：和基本配置中的 <code>groupId</code>、<code>artifactId</code>、<code>version</code> 意义相同。</p></li><li><p><strong>extensions</strong> ：值为 true  或  false。是否加载此插件的扩展名。默认为 false。</p></li><li><p><strong>inherited</strong> ：值为 true  或  false。这个插件配置是否应该适用于继承自这个插件的 POM。默认值为 true。</p></li><li><p><strong>configuration</strong>：这是针对个人插件的配置，这里不扩散讲解。</p></li><li><p><strong>dependencies</strong> ：这里的 <code>dependencies</code> 是插件本身所需要的依赖。</p></li><li><p><strong>executions</strong> ：需要记住的是，插件可能有多个目标。每个目标可能有一个单独的配置，甚至可能将插件的目标完全绑定到不同的阶段。执行配置插件的目标的执行。</p><ul><li><strong>id</strong>: 执行目标的标识。</li><li><strong>goals</strong>: 像所有多元化的 POM 元素一样，它包含单个元素的列表。在这种情况下，这个执行块指定的插件目标列表。</li><li><strong>phase</strong>: 这是执行目标列表的阶段。这是一个非常强大的选项，允许将任何目标绑定到构建生命周期中的任何阶段，从而改变 maven 的默认行为。</li><li><strong>inherited</strong>: 像上面的继承元素一样，设置这个 false 会阻止 maven 将这个执行传递给它的子代。此元素仅对父 POM 有意义。</li><li><strong>configuration</strong>: 与上述相同，但将配置限制在此特定目标列表中，而不是插件下的所有目标。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>echodir<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">echo</span>&gt;</span>Build Dir: $&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="pluginManagement"><a href="#pluginManagement" class="headerlink" title="pluginManagement"></a>pluginManagement</h4><p>与 <code>dependencyManagement</code> 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置  <code>groupId</code>  和  <code>artifactId</code> 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。</p><p>它的目的在于统一所有子 POM 的插件版本。</p><h4 id="directories"><a href="#directories" class="headerlink" title="directories"></a>directories</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$&#123;basedir&#125;/src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;basedir&#125;/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;basedir&#125;/target/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;basedir&#125;/target/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目录元素集合存在于 <code>build</code> 元素中，它为整个 POM 设置了各种目录结构。由于它们在配置文件构建中不存在，所以这些不能由配置文件更改。</p><p>如果上述目录元素的值设置为绝对路径（扩展属性时），则使用该目录。否则，它是相对于基础构建目录：<code>${basedir}</code>。</p><h4 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h4><p>扩展是在此构建中使用的 artifacts  的列表。它们将被包含在运行构建的 classpath 中。它们可以启用对构建过程的扩展（例如为 Wagon 传输机制添加一个 ftp 提供程序），并使活动的插件能够对构建生命周期进行更改。简而言之，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.wagon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wagon-ftp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-alpha-3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="reporting"><a href="#reporting" class="headerlink" title="reporting"></a>reporting</h3><p>报告包含特定针对 <code>site</code> 生成阶段的元素。某些 maven 插件可以生成 <code>reporting</code> 元素下配置的报告，例如：生成 javadoc 报告。<code>reporting</code> 与 <code>build</code> 元素配置插件的能力相似。明显的区别在于：在执行块中插件目标的控制不是细粒度的，报表通过配置 <code>reportSet</code> 元素来精细控制。而微妙的区别在于 <code>reporting</code>  元素下的 <code>configuration</code> 元素可以用作 <code>build</code> 下的 <code>configuration</code> ，尽管相反的情况并非如此（ <code>build</code> 下的 <code>configuration</code> 不影响 <code>reporting</code>  元素下的 <code>configuration</code> ）。</p><p>另一个区别就是 <code>plugin</code> 下的 <code>outputDirectory</code> 元素。在报告的情况下，默认输出目录为 <code>${basedir}/target/site</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>sunlink<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">report</span>&gt;</span>javadoc<span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">links</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">link</span>&gt;</span>http://java.sun.com/j2se/1.5.0/docs/api/<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">links</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h2><p>项目信息相关的这部分标签<strong>都不是必要的</strong>，也就是说完全可以不填写。</p><p>它的作用仅限于描述项目的详细信息。</p><p>下面的示例是项目信息相关标签的清单：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 项目信息 begin --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven-notes<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目描述--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>maven 学习笔记<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目url--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/dunwu/maven-notes<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目开发年份--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>2017<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--开源协议--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache License, Version 2.0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://www.apache.org/licenses/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--组织信息(如公司、开源组织等)--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>...<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--开发者列表--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>victor<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Zhang Peng<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">email</span>&gt;</span>forbreak at 163.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/dunwu<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organization</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">role</span>&gt;</span>architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">role</span>&gt;</span>developer<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>+8<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span>...<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--代码贡献者列表--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--标签内容和&lt;developer&gt;相同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 项目信息 end --&gt;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这部分标签都非常简单，基本都能做到顾名思义，且都属于可有可无的标签，所以这里仅简单介绍一下：</p><ul><li><p><strong>name</strong>：项目完整名称</p></li><li><p><strong>description</strong>：项目描述</p></li><li><p><strong>url</strong>：一般为项目仓库的 host</p></li><li><p><strong>inceptionYear</strong>：开发年份</p></li><li><p><strong>licenses</strong>：开源协议</p></li><li><p><strong>organization</strong>：项目所属组织信息</p></li><li><p><strong>developers</strong>：项目开发者列表</p></li><li><p><strong>contributors</strong>：项目贡献者列表，<code>&lt;contributor&gt;</code> 的子标签和 <code>&lt;developer&gt;</code> 的完全相同。</p></li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="issueManagement"><a href="#issueManagement" class="headerlink" title="issueManagement"></a>issueManagement</h3><p>这定义了所使用的缺陷跟踪系统（Bugzilla，TestTrack，ClearQuest 等）。虽然没有什么可以阻止插件使用这些信息的东西，但它主要用于生成项目文档。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system</span>&gt;</span>Bugzilla<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1/bugzilla/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ciManagement"><a href="#ciManagement" class="headerlink" title="ciManagement"></a>ciManagement</h3><p>CI 构建系统配置，主要是指定通知机制以及被通知的邮箱。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system</span>&gt;</span>continuum<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8080/continuum<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sendOnError</span>&gt;</span>true<span class="tag">&lt;/<span class="name">sendOnError</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sendOnFailure</span>&gt;</span>true<span class="tag">&lt;/<span class="name">sendOnFailure</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sendOnSuccess</span>&gt;</span>false<span class="tag">&lt;/<span class="name">sendOnSuccess</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sendOnWarning</span>&gt;</span>false<span class="tag">&lt;/<span class="name">sendOnWarning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;<span class="name">address</span>&gt;</span>continuum@127.0.0.1<span class="tag">&lt;/<span class="name">address</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mailingLists"><a href="#mailingLists" class="headerlink" title="mailingLists"></a>mailingLists</h3><p>邮件列表</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>User List<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>user-subscribe@127.0.0.1<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>user-unsubscribe@127.0.0.1<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">post</span>&gt;</span>user@127.0.0.1<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http://127.0.0.1/user/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">otherArchives</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherArchive</span>&gt;</span>http://base.google.com/base/1/127.0.0.1<span class="tag">&lt;/<span class="name">otherArchive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">otherArchives</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="scm"><a href="#scm" class="headerlink" title="scm"></a>scm</h3><p>SCM（软件配置管理，也称为源代码/控制管理或简洁的版本控制）。常见的 scm 有 svn 和 git 。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:svn:http://127.0.0.1/svn/my-project<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:svn:https://127.0.0.1/svn/my-project<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span>HEAD<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1/websvn/my-project<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="prerequisites"><a href="#prerequisites" class="headerlink" title="prerequisites"></a>prerequisites</h3><p>POM 执行的预设条件。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">maven</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="repositories"><a href="#repositories" class="headerlink" title="repositories"></a>repositories</h3><p><code>repositories</code> 是遵循 Maven 存储库目录布局的 artifacts 集合。默认的 Maven 中央存储库位于<a href="https://repo.maven.apache.org/maven2/上。" target="_blank" rel="noopener">https://repo.maven.apache.org/maven2/上。</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>fail<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pluginRepositories"><a href="#pluginRepositories" class="headerlink" title="pluginRepositories"></a>pluginRepositories</h3><p>与 <code>repositories</code> 差不多。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">downloadUrl</span>&gt;</span>http://mojo.codehaus.org/my-project<span class="tag">&lt;/<span class="name">downloadUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">status</span>&gt;</span>deployed<span class="tag">&lt;/<span class="name">status</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="distributionManagement"><a href="#distributionManagement" class="headerlink" title="distributionManagement"></a>distributionManagement</h3><p>它管理在整个构建过程中生成的 artifact 和支持文件的分布。从最后的元素开始：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">downloadUrl</span>&gt;</span>http://mojo.codehaus.org/my-project<span class="tag">&lt;/<span class="name">downloadUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">status</span>&gt;</span>deployed<span class="tag">&lt;/<span class="name">status</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>repository</strong>：与 <code>repositories</code> 相似</p></li><li><p><strong>site</strong>：站点信息</p></li><li><p><strong>relocation</strong>：项目迁移位置</p></li></ul><h3 id="profiles"><a href="#profiles" class="headerlink" title="profiles"></a>profiles</h3><p><code>activation</code> 是一个 <code>profile</code> 的关键。配置文件的功能来自于在某些情况下仅修改基本 POM 的功能。这些情况通过 <code>activation</code> 元素指定。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>sparrow-type<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>African<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven-之-pom-xml-详解&quot;&gt;&lt;a href=&quot;#Maven-之-pom-xml-详解&quot; class=&quot;headerlink&quot; title=&quot;Maven 之 pom.xml 详解&quot;&gt;&lt;/a&gt;Maven 之 pom.xml 详解&lt;/h1&gt;&lt;!-- TOC 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 常见问题</title>
    <link href="https://dunwu.github.io/2019/03/06/os/linux/tool/git/appendix/git-faq/"/>
    <id>https://dunwu.github.io/2019/03/06/os/linux/tool/git/appendix/git-faq/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.251Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">Git 常见问题</a><ul><li><a href="#%E7%BC%96%E8%BE%91%E6%8F%90%E4%BA%A4editting-commits">编辑提交(editting commits)</a><ul><li><a href="#%E6%88%91%E5%88%9A%E6%89%8D%E6%8F%90%E4%BA%A4%E4%BA%86%E4%BB%80%E4%B9%88">我刚才提交了什么</a></li><li><a href="#%E6%88%91%E7%9A%84%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AFcommit-message%E5%86%99%E9%94%99%E4%BA%86">我的提交信息(commit message)写错了</a></li><li><a href="#%E6%88%91%E6%8F%90%E4%BA%A4commit%E9%87%8C%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1%E4%B8%8D%E5%AF%B9">我提交(commit)里的用户名和邮箱不对</a></li><li><a href="#%E6%88%91%E6%83%B3%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BA%A4commit%E9%87%8C%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6">我想从一个提交(commit)里移除一个文件</a></li><li><a href="#%E6%88%91%E6%83%B3%E5%88%A0%E9%99%A4%E6%88%91%E7%9A%84%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4commit">我想删除我的的最后一次提交(commit)</a></li><li><a href="#%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E6%8F%90%E4%BA%A4commit">删除任意提交(commit)</a></li><li><a href="#%E6%88%91%E5%B0%9D%E8%AF%95%E6%8E%A8%E4%B8%80%E4%B8%AA%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84%E6%8F%90%E4%BA%A4amended-commit%E5%88%B0%E8%BF%9C%E7%A8%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E6%8A%A5%E9%94%99%EF%BC%9A">我尝试推一个修正后的提交(amended commit)到远程，但是报错：</a></li><li><a href="#%E6%88%91%E6%84%8F%E5%A4%96%E7%9A%84%E5%81%9A%E4%BA%86%E4%B8%80%E6%AC%A1%E7%A1%AC%E9%87%8D%E7%BD%AEhard-reset%EF%BC%8C%E6%88%91%E6%83%B3%E6%89%BE%E5%9B%9E%E6%88%91%E7%9A%84%E5%86%85%E5%AE%B9">我意外的做了一次硬重置(hard reset)，我想找回我的内容</a></li></ul></li><li><a href="#%E6%9A%82%E5%AD%98staging">暂存(Staging)</a><ul><li><a href="#%E6%88%91%E9%9C%80%E8%A6%81%E6%8A%8A%E6%9A%82%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9%E6%B7%BB%E5%8A%A0%E5%88%B0%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E6%8F%90%E4%BA%A4commit">我需要把暂存的内容添加到上一次的提交(commit)</a></li><li><a href="#%E6%88%91%E6%83%B3%E8%A6%81%E6%9A%82%E5%AD%98%E4%B8%80%E4%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E9%83%A8">我想要暂存一个新文件的一部分，而不是这个文件的全部</a></li><li><a href="#%E6%88%91%E6%83%B3%E6%8A%8A%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84%E5%8F%98%E5%8C%96changes%E5%8A%A0%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%8F%90%E4%BA%A4commit%E9%87%8C">我想把在一个文件里的变化(changes)加到两个提交(commit)里</a></li><li><a href="#%E6%88%91%E6%83%B3%E6%8A%8A%E6%9A%82%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%98%E6%88%90%E6%9C%AA%E6%9A%82%E5%AD%98%EF%BC%8C%E6%8A%8A%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9%E6%9A%82%E5%AD%98%E8%B5%B7%E6%9D%A5">我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</a></li></ul></li><li><a href="#%E6%9C%AA%E6%9A%82%E5%AD%98unstaged%E7%9A%84%E5%86%85%E5%AE%B9">未暂存(Unstaged)的内容</a><ul><li><a href="#%E6%88%91%E6%83%B3%E6%8A%8A%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9%E7%A7%BB%E5%8A%A8%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E5%88%86%E6%94%AF">我想把未暂存的内容移动到一个新分支</a></li><li><a href="#%E6%88%91%E6%83%B3%E6%8A%8A%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%88%86%E6%94%AF">我想把未暂存的内容移动到另一个已存在的分支</a></li><li><a href="#%E6%88%91%E6%83%B3%E4%B8%A2%E5%BC%83%E6%9C%AC%E5%9C%B0%E6%9C%AA%E6%8F%90%E4%BA%A4%E7%9A%84%E5%8F%98%E5%8C%96uncommitted-changes">我想丢弃本地未提交的变化(uncommitted changes)</a></li><li><a href="#%E6%88%91%E6%83%B3%E4%B8%A2%E5%BC%83%E6%9F%90%E4%BA%9B%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9">我想丢弃某些未暂存的内容</a></li></ul></li><li><a href="#%E5%88%86%E6%94%AFbranches">分支(Branches)</a><ul><li><a href="#%E6%88%91%E4%BB%8E%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%86%E6%94%AF%E6%8B%89%E5%8F%96%E4%BA%86%E5%86%85%E5%AE%B9%EF%BC%8C%E6%88%96%E6%8A%8A%E5%86%85%E5%AE%B9%E6%8B%89%E5%8F%96%E5%88%B0%E4%BA%86%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%86%E6%94%AF">我从错误的分支拉取了内容，或把内容拉取到了错误的分支</a></li><li><a href="#%E6%88%91%E6%83%B3%E6%89%94%E6%8E%89%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%8F%90%E4%BA%A4commit%EF%BC%8C%E4%BB%A5%E4%BE%BF%E6%88%91%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8E%E8%BF%9C%E7%A8%8B%E7%9A%84%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4">我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</a></li><li><a href="#%E6%88%91%E9%9C%80%E8%A6%81%E6%8F%90%E4%BA%A4%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E5%88%86%E6%94%AF%EF%BC%8C%E4%BD%86%E9%94%99%E8%AF%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%88%B0%E4%BA%86master">我需要提交到一个新分支，但错误的提交到了master</a></li><li><a href="#%E6%88%91%E6%83%B3%E4%BF%9D%E7%95%99%E6%9D%A5%E8%87%AA%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AAref-ish%E7%9A%84%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6">我想保留来自另外一个ref-ish的整个文件</a></li><li><a href="#%E6%88%91%E6%8A%8A%E5%87%A0%E4%B8%AA%E6%8F%90%E4%BA%A4commit%E6%8F%90%E4%BA%A4%E5%88%B0%E4%BA%86%E5%90%8C%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B%E6%8F%90%E4%BA%A4%E5%BA%94%E8%AF%A5%E5%88%86%E5%B8%83%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E6%94%AF%E9%87%8C">我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</a></li><li><a href="#%E6%88%91%E6%83%B3%E5%88%A0%E9%99%A4%E4%B8%8A%E6%B8%B8upstream%E5%88%86%E6%94%AF%E8%A2%AB%E5%88%A0%E9%99%A4%E4%BA%86%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">我想删除上游(upstream)分支被删除了的本地分支</a></li><li><a href="#%E6%88%91%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%88%A0%E9%99%A4%E4%BA%86%E6%88%91%E7%9A%84%E5%88%86%E6%94%AF">我不小心删除了我的分支</a></li><li><a href="#%E6%88%91%E6%83%B3%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF">我想删除一个分支</a></li><li><a href="#%E6%88%91%E6%83%B3%E4%BB%8E%E5%88%AB%E4%BA%BA%E6%AD%A3%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%AD%BE%E5%87%BAcheckout%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF">我想从别人正在工作的远程分支签出(checkout)一个分支</a></li></ul></li><li><a href="#rebasing-%E5%92%8C%E5%90%88%E5%B9%B6merging">Rebasing 和合并(Merging)</a><ul><li><a href="#%E6%88%91%E6%83%B3%E6%92%A4%E9%94%80rebasemerge">我想撤销rebase/merge</a></li><li><a href="#%E6%88%91%E5%B7%B2%E7%BB%8Frebase%E8%BF%87-%E4%BD%86%E6%98%AF%E6%88%91%E4%B8%8D%E6%83%B3%E5%BC%BA%E6%8E%A8force-push">我已经rebase过, 但是我不想强推(force push)</a></li><li><a href="#%E6%88%91%E9%9C%80%E8%A6%81%E7%BB%84%E5%90%88combine%E5%87%A0%E4%B8%AA%E6%8F%90%E4%BA%A4commit">我需要组合(combine)几个提交(commit)</a><ul><li><a href="#%E5%AE%89%E5%85%A8%E5%90%88%E5%B9%B6merging%E7%AD%96%E7%95%A5">安全合并(merging)策略</a></li><li><a href="#%E6%88%91%E9%9C%80%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BA%A4commit">我需要将一个分支合并成一个提交(commit)</a></li><li><a href="#%E6%88%91%E5%8F%AA%E6%83%B3%E7%BB%84%E5%90%88combine%E6%9C%AA%E6%8E%A8%E7%9A%84%E6%8F%90%E4%BA%A4unpushed-commit">我只想组合(combine)未推的提交(unpushed commit)</a></li></ul></li><li><a href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89%E6%8F%90%E4%BA%A4commit%E9%83%BD%E5%90%88%E5%B9%B6merge%E8%BF%87%E4%BA%86">检查是否分支上的所有提交(commit)都合并(merge)过了</a></li><li><a href="#%E4%BA%A4%E4%BA%92%E5%BC%8Frebaseinteractive-rebase%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98">交互式rebase(interactive rebase)可能出现的问题</a><ul><li><a href="#%E8%BF%99%E4%B8%AArebase-%E7%BC%96%E8%BE%91%E5%B1%8F%E5%B9%95%E5%87%BA%E7%8E%B0noop">这个rebase 编辑屏幕出现’noop’</a></li><li><a href="#%E6%9C%89%E5%86%B2%E7%AA%81%E7%9A%84%E6%83%85%E5%86%B5">有冲突的情况</a></li></ul></li></ul></li><li><a href="#%E6%9D%82%E9%A1%B9miscellaneous-objects">杂项(Miscellaneous Objects)</a><ul><li><a href="#%E5%85%8B%E9%9A%86%E6%89%80%E6%9C%89%E5%AD%90%E6%A8%A1%E5%9D%97">克隆所有子模块</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BEtag">删除标签(tag)</a></li><li><a href="#%E6%81%A2%E5%A4%8D%E5%B7%B2%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BEtag">恢复已删除标签(tag)</a></li><li><a href="#%E5%B7%B2%E5%88%A0%E9%99%A4%E8%A1%A5%E4%B8%81patch">已删除补丁(patch)</a></li></ul></li><li><a href="#%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6tracking-files">跟踪文件(Tracking Files)</a><ul><li><a href="#%E6%88%91%E5%8F%AA%E6%83%B3%E6%94%B9%E5%8F%98%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9">我只想改变一个文件名字的大小写，而不修改内容</a></li><li><a href="#%E6%88%91%E6%83%B3%E4%BB%8Egit%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BD%86%E4%BF%9D%E7%95%99%E8%AF%A5%E6%96%87%E4%BB%B6">我想从Git删除一个文件，但保留该文件</a></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AEconfiguration">配置(Configuration)</a><ul><li><a href="#%E6%88%91%E6%83%B3%E7%BB%99%E4%B8%80%E4%BA%9Bgit%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E5%88%AB%E5%90%8Dalias">我想给一些Git命令添加别名(alias)</a></li><li><a href="#%E6%88%91%E6%83%B3%E7%BC%93%E5%AD%98%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93repository%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81">我想缓存一个仓库(repository)的用户名和密码</a></li></ul></li><li><a href="#%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E6%88%91%E5%81%9A%E9%94%99%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88">我不知道我做错了些什么</a></li><li><a href="#%E8%B5%84%E6%BA%90">资源</a></li></ul></li></ul><!-- /TOC --><h1 id="Git-常见问题"><a href="#Git-常见问题" class="headerlink" title="Git 常见问题"></a>Git 常见问题</h1><h2 id="编辑提交-editting-commits"><a href="#编辑提交-editting-commits" class="headerlink" title="编辑提交(editting commits)"></a>编辑提交(editting commits)</h2><h3 id="我刚才提交了什么"><a href="#我刚才提交了什么" class="headerlink" title="我刚才提交了什么"></a>我刚才提交了什么</h3><p>如果你用 <code>git commit -a</code> 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前<code>HEAD</code>上的最近一次的提交(commit):</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git show</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -n1 -p</span><br></pre></td></tr></table></figure><h3 id="我的提交信息-commit-message-写错了"><a href="#我的提交信息-commit-message-写错了" class="headerlink" title="我的提交信息(commit message)写错了"></a>我的提交信息(commit message)写错了</h3><p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">'xxxxxxx'</span></span><br></pre></td></tr></table></figure><p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p><h3 id="我提交-commit-里的用户名和邮箱不对"><a href="#我提交-commit-里的用户名和邮箱不对" class="headerlink" title="我提交(commit)里的用户名和邮箱不对"></a>我提交(commit)里的用户名和邮箱不对</h3><p>如果这只是单个提交(commit)，修改它：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git commit --amend --author <span class="string">"New Authorname &lt;authoremail@mydomain.com&gt;"</span></span><br></pre></td></tr></table></figure><p>如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页.</p><h3 id="我想从一个提交-commit-里移除一个文件"><a href="#我想从一个提交-commit-里移除一个文件" class="headerlink" title="我想从一个提交(commit)里移除一个文件"></a>我想从一个提交(commit)里移除一个文件</h3><p>通过下面的方法，从一个提交(commit)里移除一个文件:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout HEAD^ myfile</span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。</p><h3 id="我想删除我的的最后一次提交-commit"><a href="#我想删除我的的最后一次提交-commit" class="headerlink" title="我想删除我的的最后一次提交(commit)"></a>我想删除我的的最后一次提交(commit)</h3><p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD^ --hard</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure><p>如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">my</span>-branch*)$ git <span class="keyword">reset</span> --soft HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure><p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是rebase-safe的 (例如： 其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>； 更多, 请参考 <a href="#deleteremove-last-pushed-commit">the above section</a>。</p><h3 id="删除任意提交-commit"><a href="#删除任意提交-commit" class="headerlink" title="删除任意提交(commit)"></a>删除任意提交(commit)</h3><p>同样的警告：不到万不得已的时候不要这么做.</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure><p>或者做一个 <a href="#interactive-rebase">交互式rebase</a> 删除那些你想要删除的提交(commit)里所对应的行。</p><h3 id="我尝试推一个修正后的提交-amended-commit-到远程，但是报错："><a href="#我尝试推一个修正后的提交-amended-commit-到远程，但是报错：" class="headerlink" title="我尝试推一个修正后的提交(amended commit)到远程，但是报错："></a>我尝试推一个修正后的提交(amended commit)到远程，但是报错：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">To https://github.com/yourusername/repo.git</span><br><span class="line">! [rejected]        mybranch -&gt; mybranch (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'https://github.com/tanay1337/webmaker.org.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>注意, rebasing(见下面)和修正(amending)会用一个<strong>新的提交(commit)代替旧的</strong>, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。 注意 &ndash; <em>总是</em> 确保你指明一个分支!</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git push origin mybranch -f</span><br></pre></td></tr></table></figure><p>一般来说, <strong>要避免强推</strong>. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p><h3 id="我意外的做了一次硬重置-hard-reset-，我想找回我的内容"><a href="#我意外的做了一次硬重置-hard-reset-，我想找回我的内容" class="headerlink" title="我意外的做了一次硬重置(hard reset)，我想找回我的内容"></a>我意外的做了一次硬重置(hard reset)，我想找回我的内容</h3><p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reflog</span><br></pre></td></tr></table></figure><p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard SHA1234</span><br></pre></td></tr></table></figure><p>这样就完成了。</p><h2 id="暂存-Staging"><a href="#暂存-Staging" class="headerlink" title="暂存(Staging)"></a>暂存(Staging)</h2><h3 id="我需要把暂存的内容添加到上一次的提交-commit"><a href="#我需要把暂存的内容添加到上一次的提交-commit" class="headerlink" title="我需要把暂存的内容添加到上一次的提交(commit)"></a>我需要把暂存的内容添加到上一次的提交(commit)</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch*)$ git commit --amend</span><br></pre></td></tr></table></figure><h3 id="我想要暂存一个新文件的一部分，而不是这个文件的全部"><a href="#我想要暂存一个新文件的一部分，而不是这个文件的全部" class="headerlink" title="我想要暂存一个新文件的一部分，而不是这个文件的全部"></a>我想要暂存一个新文件的一部分，而不是这个文件的全部</h3><p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git add --patch filename.x</span><br></pre></td></tr></table></figure><p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git add -N filename.x</span><br></pre></td></tr></table></figure><p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p><h3 id="我想把在一个文件里的变化-changes-加到两个提交-commit-里"><a href="#我想把在一个文件里的变化-changes-加到两个提交-commit-里" class="headerlink" title="我想把在一个文件里的变化(changes)加到两个提交(commit)里"></a>我想把在一个文件里的变化(changes)加到两个提交(commit)里</h3><p><code>git add</code> 会把整个文件加入到一个提交. <code>git add -p</code> 允许交互式的选择你想要提交的部分.</p><h3 id="我想把暂存的内容变成未暂存，把未暂存的内容暂存起来"><a href="#我想把暂存的内容变成未暂存，把未暂存的内容暂存起来" class="headerlink" title="我想把暂存的内容变成未暂存，把未暂存的内容暂存起来"></a>我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</h3><p>这个有点困难， 我能想到的最好的方法是先stash未暂存的内容， 然后重置(reset)，再pop第一步stashed的内容, 最后再add它们。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash -k</span><br><span class="line">$ git reset --hard</span><br><span class="line">$ git stash pop</span><br><span class="line">$ git add -A</span><br></pre></td></tr></table></figure><h2 id="未暂存-Unstaged-的内容"><a href="#未暂存-Unstaged-的内容" class="headerlink" title="未暂存(Unstaged)的内容"></a>未暂存(Unstaged)的内容</h2><h3 id="我想把未暂存的内容移动到一个新分支"><a href="#我想把未暂存的内容移动到一个新分支" class="headerlink" title="我想把未暂存的内容移动到一个新分支"></a>我想把未暂存的内容移动到一个新分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -b my-branch</span><br></pre></td></tr></table></figure><h3 id="我想把未暂存的内容移动到另一个已存在的分支"><a href="#我想把未暂存的内容移动到另一个已存在的分支" class="headerlink" title="我想把未暂存的内容移动到另一个已存在的分支"></a>我想把未暂存的内容移动到另一个已存在的分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git checkout my-branch</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h3 id="我想丢弃本地未提交的变化-uncommitted-changes"><a href="#我想丢弃本地未提交的变化-uncommitted-changes" class="headerlink" title="我想丢弃本地未提交的变化(uncommitted changes)"></a>我想丢弃本地未提交的变化(uncommitted changes)</h3><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># one commit</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD^</span><br><span class="line"><span class="comment"># two commits</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD^^</span><br><span class="line"><span class="comment"># four commits</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD~4</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">(master)$ git checkout -f</span><br></pre></td></tr></table></figure><p>重置某个特殊的文件, 你可以用文件名做为参数:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset filename</span><br></pre></td></tr></table></figure><h3 id="我想丢弃某些未暂存的内容"><a href="#我想丢弃某些未暂存的内容" class="headerlink" title="我想丢弃某些未暂存的内容"></a>我想丢弃某些未暂存的内容</h3><p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p><p>签出(checkout)不需要的内容，保留需要的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -p</span><br><span class="line"><span class="comment"># Answer y to all of the snippets you want to drop</span></span><br></pre></td></tr></table></figure><p>另外一个方法是使用 <code>stash</code>， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash -p</span><br><span class="line"><span class="comment"># Select all of the snippets you want to save</span></span><br><span class="line">$ git reset --hard</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><p>或者, stash 你不需要的部分, 然后stash drop。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git stash -p</span><br><span class="line"><span class="comment"># Select all of the snippets you don't want to save</span></span><br><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure><h2 id="分支-Branches"><a href="#分支-Branches" class="headerlink" title="分支(Branches)"></a>分支(Branches)</h2><h3 id="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"><a href="#我从错误的分支拉取了内容，或把内容拉取到了错误的分支" class="headerlink" title="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"></a>我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h3><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前HEAD的指向。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reflog</span><br><span class="line">ab7555f HEAD@&#123;0&#125;: pull origin wrong-branch: Fast-forward</span><br><span class="line">c5bc55a HEAD@&#123;1&#125;: checkout: checkout message goes here</span><br></pre></td></tr></table></figure><p>重置分支到你所需的提交(desired commit):</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset --hard c5bc55a</span><br></pre></td></tr></table></figure><p>完成。</p><h3 id="我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致"><a href="#我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致" class="headerlink" title="我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致"></a>我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</h3><p>先确认你没有推(push)你的内容到远程。</p><p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git status</span><br><span class="line"><span class="comment"># On branch my-branch</span></span><br><span class="line"><span class="comment"># Your branch is ahead of 'origin/my-branch' by 2 commits.</span></span><br><span class="line"><span class="comment">#   (use "git push" to publish your local commits)</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>一种方法是:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard origin/my-branch</span><br></pre></td></tr></table></figure><h3 id="我需要提交到一个新分支，但错误的提交到了master"><a href="#我需要提交到一个新分支，但错误的提交到了master" class="headerlink" title="我需要提交到一个新分支，但错误的提交到了master"></a>我需要提交到一个新分支，但错误的提交到了master</h3><p>在master下创建一个新分支，不切换到新分支,仍在master下:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git branch my-branch</span><br></pre></td></tr></table></figure><p>把master分支重置到前一个提交:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p><p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的hash(<code>git log</code> 能够完成)， 然后重置到这个hash。 使用<code>git push</code> 同步内容到远程。</p><p>例如, master分支想重置到的提交的hash为<code>a13b85e</code>:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure><p>签出(checkout)刚才新建的分支继续工作:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout my-branch</span><br></pre></td></tr></table></figure><h3 id="我想保留来自另外一个ref-ish的整个文件"><a href="#我想保留来自另外一个ref-ish的整个文件" class="headerlink" title="我想保留来自另外一个ref-ish的整个文件"></a>我想保留来自另外一个ref-ish的整个文件</h3><p>假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(solution)$ git add -A &amp;&amp; git commit -m <span class="string">"Adding all changes from this spike into one big commit."</span></span><br></pre></td></tr></table></figure><p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p><p>假设你有:</p><ul><li>分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li><li>分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li></ul><p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(develop)$ git checkout solution -- file1.txt</span><br></pre></td></tr></table></figure><p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># On branch develop</span></span><br><span class="line"><span class="comment"># Your branch is up-to-date with 'origin/develop'.</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#  (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        modified:   file1.txt</span></span><br></pre></td></tr></table></figure><p>然后, 正常提交。</p><p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ <a href="https://en.wikipedia.org/wiki/Extreme_programming_practices" target="_blank" rel="noopener">Wikipedia</a>.</p><h3 id="我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里"><a href="#我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里" class="headerlink" title="我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里"></a>我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</h3><p>假设你有一个<code>master</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit e3851e817c451cc36f2e6f3049db528415e3c114</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:27 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#21 - Added CSRF protection</span></span><br><span class="line"></span><br><span class="line">commit 5ea51731d150f7ddc4a365437931cd8be3bf3131</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:12 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#14 - Fixed spacing on title</span></span><br><span class="line"></span><br><span class="line">commit a13b85e984171c6e2a1729bb061994525f626d14</span><br><span class="line">Author: Aki Rose &lt;akirose@example.com&gt;</span><br><span class="line">Date:   Tue Jul 21 01:12:48 2014 -0400</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure><p>让我们用提交hash(commit hash)标记bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p><p>首先, 我们把<code>master</code>分支重置到正确的提交(<code>a13b85e</code>):</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure><p>现在, 我们对 bug #21 创建一个新的分支:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout -b 21</span><br><span class="line">(21)$</span><br></pre></td></tr></table></figure><p>接着, 我们用 <em>cherry-pick</em> 把对bug #21的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(21)$ git cherry-pick e3851e8</span><br></pre></td></tr></table></figure><p>这时候, 这里可能会产生冲突， 参见<a href="#interactive-rebase">交互式 rebasing 章</a> <a href="#merge-conflict"><strong>冲突节</strong></a> 解决冲突.</p><p>再者， 我们为bug #14 创建一个新的分支, 也基于<code>master</code>分支</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(21)$ git checkout master</span><br><span class="line">(master)$ git checkout -b 14</span><br><span class="line">(14)$</span><br></pre></td></tr></table></figure><p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(14)$ git cherry-pick 5ea5173</span><br></pre></td></tr></table></figure><h3 id="我想删除上游-upstream-分支被删除了的本地分支"><a href="#我想删除上游-upstream-分支被删除了的本地分支" class="headerlink" title="我想删除上游(upstream)分支被删除了的本地分支"></a>我想删除上游(upstream)分支被删除了的本地分支</h3><p>一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure><h3 id="我不小心删除了我的分支"><a href="#我不小心删除了我的分支" class="headerlink" title="我不小心删除了我的分支"></a>我不小心删除了我的分支</h3><p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout -b my-branch</span><br><span class="line">(my-branch)$ git branch</span><br><span class="line">(my-branch)$ touch foo.txt</span><br><span class="line">(my-branch)$ ls</span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure><p>添加文件并做一次提交</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git add .</span><br><span class="line">(my-branch)$ git commit -m <span class="string">'foo.txt added'</span></span><br><span class="line">(my-branch)$ foo.txt added</span><br><span class="line"> 1 files changed, 1 insertions(+)</span><br><span class="line"> create mode 100644 foo.txt</span><br><span class="line">(my-branch)$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012</span><br><span class="line">Author: siemiatj &lt;siemiatj@example.com&gt;</span><br><span class="line">Date:   Wed Jul 30 00:34:10 2014 +0200</span><br><span class="line"></span><br><span class="line">    foo.txt added</span><br><span class="line"></span><br><span class="line">commit 69204cdf0acbab201619d95ad8295928e7f411d5</span><br><span class="line">Author: Kate Hudson &lt;katehudson@example.com&gt;</span><br><span class="line">Date:   Tue Jul 29 13:14:46 2014 -0400</span><br><span class="line"></span><br><span class="line">    Fixes <span class="comment">#6: Force pushing after amending commits</span></span><br></pre></td></tr></table></figure><p>现在我们切回到主(master)分支，‘不小心的’删除<code>my-branch</code>分支</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">(master)$ git branch -D my-branch</span><br><span class="line">Deleted branch my-branch (was 4e3cd85).</span><br><span class="line">(master)$ <span class="built_in">echo</span> oh noes, deleted my branch!</span><br><span class="line">oh noes, deleted my branch!</span><br></pre></td></tr></table></figure><p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">(<span class="literal">master</span>)$ git reflog</span><br><span class="line"><span class="number">69204</span>cd HEAD@&#123;<span class="number">0</span>&#125;: checkout: moving from my-branch to <span class="literal">master</span></span><br><span class="line"><span class="number">4</span>e3cd85 HEAD@&#123;<span class="number">1</span>&#125;: commit: foo.txt added</span><br><span class="line"><span class="number">69204</span>cd HEAD@&#123;<span class="number">2</span>&#125;: checkout: moving from <span class="keyword">master</span> <span class="title">to</span> my-branch</span><br></pre></td></tr></table></figure><p>正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout -b my-branch-help</span><br><span class="line">Switched to a new branch <span class="string">'my-branch-help'</span></span><br><span class="line">(my-branch-help)$ git reset --hard 4e3cd85</span><br><span class="line">HEAD is now at 4e3cd85 foo.txt added</span><br><span class="line">(my-branch-help)$ ls</span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure><p>看! 我们把删除的文件找回来了。 Git的 <code>reflog</code> 在rebasing出错的时候也是同样有用的。</p><h3 id="我想删除一个分支"><a href="#我想删除一个分支" class="headerlink" title="我想删除一个分支"></a>我想删除一个分支</h3><p>删除一个远程分支:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git push origin --delete my-branch</span><br></pre></td></tr></table></figure><p>你也可以:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git push origin :my-branch</span><br></pre></td></tr></table></figure><p>删除一个本地分支:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git branch -D my-branch</span><br></pre></td></tr></table></figure><h3 id="我想从别人正在工作的远程分支签出-checkout-一个分支"><a href="#我想从别人正在工作的远程分支签出-checkout-一个分支" class="headerlink" title="我想从别人正在工作的远程分支签出(checkout)一个分支"></a>我想从别人正在工作的远程分支签出(checkout)一个分支</h3><p>首先, 从远程拉取(fetch) 所有分支:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git fetch --all</span><br></pre></td></tr></table></figure><p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout --track origin/daves</span><br><span class="line">Branch daves <span class="built_in">set</span> up to track remote branch daves from origin.</span><br><span class="line">Switched to a new branch <span class="string">'daves'</span></span><br></pre></td></tr></table></figure><p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p><p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p><h2 id="Rebasing-和合并-Merging"><a href="#Rebasing-和合并-Merging" class="headerlink" title="Rebasing 和合并(Merging)"></a>Rebasing 和合并(Merging)</h2><h3 id="我想撤销rebase-merge"><a href="#我想撤销rebase-merge" class="headerlink" title="我想撤销rebase/merge"></a>我想撤销rebase/merge</h3><p>你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git reset --hard ORIG_HEAD</span><br></pre></td></tr></table></figure><h3 id="我已经rebase过-但是我不想强推-force-push"><a href="#我已经rebase过-但是我不想强推-force-push" class="headerlink" title="我已经rebase过, 但是我不想强推(force push)"></a>我已经rebase过, 但是我不想强推(force push)</h3><p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git checkout my-branch</span><br><span class="line">(my-branch)$ git rebase -i master</span><br><span class="line">(my-branch)$ git checkout master</span><br><span class="line">(master)$ git merge --ff-only my-branch</span><br></pre></td></tr></table></figure><p>更多, 参见 <a href="http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push" target="_blank" rel="noopener">this SO thread</a>.</p><h3 id="我需要组合-combine-几个提交-commit"><a href="#我需要组合-combine-几个提交-commit" class="headerlink" title="我需要组合(combine)几个提交(commit)"></a>我需要组合(combine)几个提交(commit)</h3><p>假设你的工作分支将会做对于 <code>master</code> 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 <em>所有</em> 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git reset --soft master</span><br><span class="line">(my-branch)$ git commit -am <span class="string">"New awesome feature"</span></span><br></pre></td></tr></table></figure><p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git rebase -i master</span><br></pre></td></tr></table></figure><p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD\~2</code> 进行rebase， 组合最近3次提交(commit), 相对于<code>HEAD\~3</code>, 等等。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">pick b729ad5 fixup</span><br><span class="line">pick e3851e8 another <span class="keyword">fix</span></span><br><span class="line"></span><br><span class="line"># Rebase <span class="number">8074</span>d12..b729ad5 onto <span class="number">8074</span>d12</span><br><span class="line">#</span><br><span class="line"># Command<span class="variable">s:</span></span><br><span class="line">#  <span class="keyword">p</span>, pick = use commit</span><br><span class="line">#  r, reword = use commit, but <span class="keyword">edit</span> the commit message</span><br><span class="line">#  <span class="keyword">e</span>, <span class="keyword">edit</span> = use commit, but <span class="keyword">stop</span> <span class="keyword">for</span> amending</span><br><span class="line">#  s, squash = use commit, but meld into <span class="keyword">previous</span> commit</span><br><span class="line">#  <span class="keyword">f</span>, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span><br><span class="line"><span class="string">#  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p><p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p><p>例如, 如果你想 <strong>单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面</strong>, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line"><span class="keyword">f</span> b729ad5 fixup</span><br><span class="line"><span class="keyword">f</span> e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure><p>如果你想组合这些提交(commit) <strong>并重命名这个提交(commit)</strong>, 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">s b729ad5 fixup</span><br><span class="line">s e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure><p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Newer, awesomer features</span><br><span class="line"></span><br><span class="line"># Please enter the commit message <span class="keyword">for</span> your <span class="keyword">changes</span>. Lines starting</span><br><span class="line"># with <span class="string">'#'</span> will <span class="keyword">be</span> ignored, <span class="built_in">and</span> <span class="keyword">an</span> <span class="built_in">empty</span> message aborts the commit.</span><br><span class="line"># rebase in progress; onto 8074d12</span><br><span class="line"># You are currently editing <span class="keyword">a</span> commit <span class="keyword">while</span> rebasing branch <span class="string">'master'</span> <span class="keyword">on</span> <span class="string">'8074d12'</span>.</span><br><span class="line">#</span><br><span class="line"># Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">#modified:   README.md</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>如果成功了, 你应该看到类似下面的内容:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure><h4 id="安全合并-merging-策略"><a href="#安全合并-merging-策略" class="headerlink" title="安全合并(merging)策略"></a>安全合并(merging)策略</h4><p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 <code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git merge --no-ff --no-commit my-branch</span><br></pre></td></tr></table></figure><h4 id="我需要将一个分支合并成一个提交-commit"><a href="#我需要将一个分支合并成一个提交-commit" class="headerlink" title="我需要将一个分支合并成一个提交(commit)"></a>我需要将一个分支合并成一个提交(commit)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git merge --squash my-branch</span><br></pre></td></tr></table></figure><h4 id="我只想组合-combine-未推的提交-unpushed-commit"><a href="#我只想组合-combine-未推的提交-unpushed-commit" class="headerlink" title="我只想组合(combine)未推的提交(unpushed commit)"></a>我只想组合(combine)未推的提交(unpushed commit)</h4><p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git rebase -i @&#123;u&#125;</span><br></pre></td></tr></table></figure><p>这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。</p><h3 id="检查是否分支上的所有提交-commit-都合并-merge-过了"><a href="#检查是否分支上的所有提交-commit-都合并-merge-过了" class="headerlink" title="检查是否分支上的所有提交(commit)都合并(merge)过了"></a>检查是否分支上的所有提交(commit)都合并(merge)过了</h3><p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span> --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll</span><br></pre></td></tr></table></figure><p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span> master ^feature/120-on-scroll --no-merges</span><br></pre></td></tr></table></figure><h3 id="交互式rebase-interactive-rebase-可能出现的问题"><a href="#交互式rebase-interactive-rebase-可能出现的问题" class="headerlink" title="交互式rebase(interactive rebase)可能出现的问题"></a>交互式rebase(interactive rebase)可能出现的问题</h3><h4 id="这个rebase-编辑屏幕出现’noop’"><a href="#这个rebase-编辑屏幕出现’noop’" class="headerlink" title="这个rebase 编辑屏幕出现’noop’"></a>这个rebase 编辑屏幕出现’noop’</h4><p>如果你看到的是这样:<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">noop</span></span><br></pre></td></tr></table></figure></p><p>这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 <em>领先(ahead)</em> 当前分支。 你可以尝试:</p><ul><li>检查确保主(master)分支没有问题</li><li>rebase  <code>HEAD\~2</code> 或者更早</li></ul><h4 id="有冲突的情况"><a href="#有冲突的情况" class="headerlink" title="有冲突的情况"></a>有冲突的情况</h4><p>如果你不能成功的完成rebase, 你可能必须要解决冲突。</p><p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git status</span><br><span class="line">On branch my-branch</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br></pre></td></tr></table></figure><p>在这个例子里面, <code>README.md</code> 有冲突。 打开这个文件找到类似下面的内容:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">some code</span><br><span class="line">=========</span><br><span class="line">some code</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="keyword">new</span>-commit</span><br></pre></td></tr></table></figure><p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p><p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master*)$ git mergetool -t opendiff</span><br></pre></td></tr></table></figure><p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续rebase。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git add README.md</span><br><span class="line">(my-branch)$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p><p>任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(my-branch)$ git rebase --abort</span><br></pre></td></tr></table></figure><h2 id="杂项-Miscellaneous-Objects"><a href="#杂项-Miscellaneous-Objects" class="headerlink" title="杂项(Miscellaneous Objects)"></a>杂项(Miscellaneous Objects)</h2><h3 id="克隆所有子模块"><a href="#克隆所有子模块" class="headerlink" title="克隆所有子模块"></a>克隆所有子模块</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive git://github.com/foo/bar.git</span><br></pre></td></tr></table></figure><p>如果已经克隆了:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h3 id="删除标签-tag"><a href="#删除标签-tag" class="headerlink" title="删除标签(tag)"></a>删除标签(tag)</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag -d &lt;tag_name&gt;</span><br><span class="line">$ git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt;</span><br></pre></td></tr></table></figure><h3 id="恢复已删除标签-tag"><a href="#恢复已删除标签-tag" class="headerlink" title="恢复已删除标签(tag)"></a>恢复已删除标签(tag)</h3><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git fsck --unreachable | grep tag</span><br></pre></td></tr></table></figure><p>记下这个标签(tag)的hash，然后用Git的 <a href="http://git-scm.com/docs/git-update-ref" target="_blank" rel="noopener">update-ref</a>:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/tags/&lt;tag_name&gt; &lt;<span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure><p>这时你的标签(tag)应该已经恢复了。</p><h3 id="已删除补丁-patch"><a href="#已删除补丁-patch" class="headerlink" title="已删除补丁(patch)"></a>已删除补丁(patch)</h3><p>如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p><p>做完提交后, 再修改作者，参见<a href="#commit-wrong-author">变更作者</a>。 然后, 应用变化, 再发起一个新的pull request。</p><h2 id="跟踪文件-Tracking-Files"><a href="#跟踪文件-Tracking-Files" class="headerlink" title="跟踪文件(Tracking Files)"></a>跟踪文件(Tracking Files)</h2><h3 id="我只想改变一个文件名字的大小写，而不修改内容"><a href="#我只想改变一个文件名字的大小写，而不修改内容" class="headerlink" title="我只想改变一个文件名字的大小写，而不修改内容"></a>我只想改变一个文件名字的大小写，而不修改内容</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git mv --force myfile MyFile</span><br></pre></td></tr></table></figure><h3 id="我想从Git删除一个文件，但保留该文件"><a href="#我想从Git删除一个文件，但保留该文件" class="headerlink" title="我想从Git删除一个文件，但保留该文件"></a>我想从Git删除一个文件，但保留该文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git rm --cached log.txt</span><br></pre></td></tr></table></figure><h2 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h2><h3 id="我想给一些Git命令添加别名-alias"><a href="#我想给一些Git命令添加别名-alias" class="headerlink" title="我想给一些Git命令添加别名(alias)"></a>我想给一些Git命令添加别名(alias)</h3><p>在 OS X 和 Linux 下, 你的 Git的配置文件储存在 <figure class="highlight plain"><figcaption><span>部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```vim</span><br><span class="line">[alias]</span><br><span class="line">    a = add</span><br><span class="line">    amend = commit --amend</span><br><span class="line">    c = commit</span><br><span class="line">    ca = commit --amend</span><br><span class="line">    ci = commit -a</span><br><span class="line">    co = checkout</span><br><span class="line">    d = diff</span><br><span class="line">    dc = diff --changed</span><br><span class="line">    ds = diff --staged</span><br><span class="line">    f = fetch</span><br><span class="line">    loll = log --graph --decorate --pretty=oneline --abbrev-commit</span><br><span class="line">    m = merge</span><br><span class="line">    one = log --pretty=oneline</span><br><span class="line">    outstanding = rebase -i @&#123;u&#125;</span><br><span class="line">    s = status</span><br><span class="line">    unpushed = log @&#123;u&#125;</span><br><span class="line">    wc = whatchanged</span><br><span class="line">    wip = rebase -i @&#123;u&#125;</span><br><span class="line">    zap = fetch -p</span><br></pre></td></tr></table></figure></p><h3 id="我想缓存一个仓库-repository-的用户名和密码"><a href="#我想缓存一个仓库-repository-的用户名和密码" class="headerlink" title="我想缓存一个仓库(repository)的用户名和密码"></a>我想缓存一个仓库(repository)的用户名和密码</h3><p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper cache</span><br><span class="line"><span class="comment"># Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper <span class="string">'cache --timeout=3600'</span></span><br><span class="line"><span class="comment"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure><h2 id="我不知道我做错了些什么"><a href="#我不知道我做错了些什么" class="headerlink" title="我不知道我做错了些什么"></a>我不知道我做错了些什么</h2><p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p><p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(master)$ git reflog</span><br><span class="line">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD\~2</span><br><span class="line">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class="line">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure><p>上面的reflog展示了从master分支签出(checkout)到2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@{0}</code>标识.</p><p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前master上指向的提交(0254ea7)。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 0254ea7</span><br></pre></td></tr></table></figure><p>然后使用git reset就可以把master改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md" target="_blank" rel="noopener">https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md</a></li><li><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">https://github.com/521xueweihan/git-tips</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&quot;&gt;Git 常见问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BC%96%E8%BE%91%E6%8F%90%E4%BA%A
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven 之 settings.xml 详解</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/maven-settings/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/maven-settings/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven-之-settings-xml-详解"><a href="#Maven-之-settings-xml-详解" class="headerlink" title="Maven 之 settings.xml 详解"></a>Maven 之 settings.xml 详解</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#简介">简介</a><ul><li><a href="#settingsxml-有什么用">settings.xml 有什么用？</a></li><li><a href="#settingsxml-文件位置">settings.xml 文件位置</a></li><li><a href="#配置优先级">配置优先级</a></li></ul></li><li><a href="#settingsxml-元素详解">settings.xml 元素详解</a><ul><li><a href="#顶级元素概览">顶级元素概览</a></li><li><a href="#localrepository">LocalRepository</a></li><li><a href="#interactivemode">InteractiveMode</a></li><li><a href="#usepluginregistry">UsePluginRegistry</a></li><li><a href="#offline">Offline</a></li><li><a href="#plugingroups">PluginGroups</a></li><li><a href="#servers">Servers</a></li><li><a href="#mirrors">Mirrors</a></li><li><a href="#proxies">Proxies</a></li><li><a href="#profiles">Profiles</a></li><li><a href="#activeprofiles">ActiveProfiles</a></li></ul></li></ul><!-- /TOC --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="settings-xml-有什么用？"><a href="#settings-xml-有什么用？" class="headerlink" title="settings.xml 有什么用？"></a>settings.xml 有什么用？</h3><p>如果在 Eclipse 中使用过 Maven 插件，想必会有这个经验：配置 settings.xml 文件的路径。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20181127195810.png"></div><br></p><p><strong>settings.xml 文件有什么用，为什么要配置它？</strong></p><p>从 settings.xml 的文件名就可以看出，它是用来设置 maven 参数的配置文件。settings.xml 中包含类似本地仓储位置、修改远程仓储服务器、认证信息等配置。</p><ul><li>settings.xml 是 maven 的<strong>全局配置文件</strong>。</li><li>pom.xml 文件是本地<strong>项目配置文件</strong>。</li></ul><h3 id="settings-xml-文件位置"><a href="#settings-xml-文件位置" class="headerlink" title="settings.xml 文件位置"></a>settings.xml 文件位置</h3><p>settings.xml 文件一般存在于两个位置：</p><ul><li><strong>全局配置</strong> - <code>${M2_HOME}/conf/settings.xml</code></li><li><strong>用户配置</strong> - <code>${user.home}/.m2/settings.xml</code></li></ul><blockquote><p>注意：用户配置优先于全局配置。<code>${user.home}</code> 和和所有其他系统属性只能在 3.0+版本上使用。请注意 windows 和 Linux 使用变量的区别。</p></blockquote><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><blockquote><p>重要：<strong>局部配置优先于全局配置</strong>。</p></blockquote><p>配置优先级从高到低：pom.xml &gt; user settings &gt; global settings</p><p>如果这些文件同时存在，在应用配置时，会合并它们的内容，如果有重复的配置，优先级高的配置会覆盖优先级低的。</p><h2 id="settings-xml-元素详解"><a href="#settings-xml-元素详解" class="headerlink" title="settings.xml 元素详解"></a>settings.xml 元素详解</h2><h3 id="顶级元素概览"><a href="#顶级元素概览" class="headerlink" title="顶级元素概览"></a>顶级元素概览</h3><p>下面列举了<code>settings.xml</code>中的顶级元素</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                          https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="LocalRepository"><a href="#LocalRepository" class="headerlink" title="LocalRepository"></a>LocalRepository</h3><p><strong>作用</strong>：该值表示构建系统本地仓库的路径。</p><p>其默认值：~/.m2/repository。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>$&#123;user.home&#125;/.m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="InteractiveMode"><a href="#InteractiveMode" class="headerlink" title="InteractiveMode"></a>InteractiveMode</h3><p><strong>作用</strong>：表示 maven 是否需要和用户交互以获得输入。</p><p>如果 maven 需要和用户交互以获得输入，则设置成 true，反之则应为 false。默认为 true。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interactiveMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">interactiveMode</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="UsePluginRegistry"><a href="#UsePluginRegistry" class="headerlink" title="UsePluginRegistry"></a>UsePluginRegistry</h3><p><strong>作用</strong>：maven 是否需要使用 plugin-registry.xml 文件来管理插件版本。</p><p>如果需要让 maven 使用文件~/.m2/plugin-registry.xml 来管理插件版本，则设为 true。默认为 false。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">usePluginRegistry</span>&gt;</span>false<span class="tag">&lt;/<span class="name">usePluginRegistry</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Offline"><a href="#Offline" class="headerlink" title="Offline"></a>Offline</h3><p><strong>作用</strong>：表示 maven 是否需要在离线模式下运行。</p><p>如果构建系统需要在离线模式下运行，则为 true，默认为 false。</p><p>当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">offline</span>&gt;</span>false<span class="tag">&lt;/<span class="name">offline</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PluginGroups"><a href="#PluginGroups" class="headerlink" title="PluginGroups"></a>PluginGroups</h3><p><strong>作用</strong>：当插件的组织 id（groupId）没有显式提供时，供搜寻插件组织 Id（groupId）的列表。</p><p>该元素包含一个 pluginGroup 元素列表，每个子元素包含了一个组织 Id（groupId）。</p><p>当我们使用某个插件，并且没有在命令行为其提供组织 Id（groupId）的时候，Maven 就会使用该列表。默认情况下该列表包含了 <code>org.apache.maven.plugins</code> 和 <code>org.codehaus.mojo</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--plugin的组织Id（groupId） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Servers"><a href="#Servers" class="headerlink" title="Servers"></a>Servers</h3><p><strong>作用</strong>：一般，仓库的下载和部署是在 pom.xml 文件中的 <code>repositories</code> 和 <code>distributionManagement</code> 元素中定义的。然而，一般类似用户名、密码（<strong>有些仓库访问是需要安全认证的</strong>）等信息不应该在 pom.xml 文件中配置，这些信息可以配置在 <code>settings.xml</code> 中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务器元素包含配置服务器时需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>server001<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>my_login<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>my_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是$&#123;user.home&#125;/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>$&#123;usr.home&#125;/.ssh/id_dsa<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--鉴权时使用的私钥密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>some_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filePermissions</span>&gt;</span>664<span class="tag">&lt;/<span class="name">filePermissions</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--目录被创建时的权限。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directoryPermissions</span>&gt;</span>775<span class="tag">&lt;/<span class="name">directoryPermissions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Mirrors"><a href="#Mirrors" class="headerlink" title="Mirrors"></a>Mirrors</h3><p><strong>作用</strong>：为仓库列表配置的下载镜像列表。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给定仓库的下载镜像。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>planetmirror.com<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 镜像名称 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>PlanetMirror Australia<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://downloads.planetmirror.com/pub/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><p><strong>作用</strong>：用来配置不同的代理。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--代理元素包含配置代理时需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>myproxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>proxy.somewhere.com<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>proxyuser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>somepassword<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>*.google.com|ibiblio.org<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h3><p><strong>作用</strong>：根据环境参数来调整构建配置的列表。</p><p><code>settings.xml</code> 中的 <code>profile</code> 元素是 <code>pom.xml</code> 中 <code>profile</code> 元素的<strong>裁剪版本</strong>。</p><p>它包含了<code>id</code>、<code>activation</code>、<code>repositories</code>、<code>pluginRepositories</code> 和 <code>properties</code> 元素。这里的 profile 元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是 settings.xml 文件的角色定位），而非单独的项目对象模型设置。如果一个 <code>settings.xml</code> 中的 <code>profile</code> 被激活，它的值会覆盖任何其它定义在 <code>pom.xml</code> 中带有相同 id 的 <code>profile</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- profile的唯一标识 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 自动触发profile的条件逻辑 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 扩展属性列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 远程仓库列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repositories</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 插件仓库列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pluginRepositories</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h4><p><strong>作用</strong>：自动触发 <code>profile</code> 的条件逻辑。</p><p>如 <code>pom.xml</code> 中的 <code>profile</code> 一样，<code>profile</code> 的作用在于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过 <code>activation</code> 元素指定。<br><code>activation</code> 元素并不是激活 <code>profile</code> 的唯一方式。<code>settings.xml</code> 文件中的 <code>activeProfile</code> 元素可以包含 <code>profile</code> 的 <code>id</code>。<code>profile</code> 也可以通过在命令行，使用 <code>-P</code> 标记和逗号分隔的列表来显式的激活（如，<code>-P test</code>）。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--profile默认是否激活的标识 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;name&#125;引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：在 maven 工程的 pom.xml 所在目录下执行 <code>mvn help:active-profiles</code> 命令可以查看中央仓储的 profile 是否在工程中生效。</p></blockquote><h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><p><strong>作用</strong>：对应<code>profile</code>的扩展属性列表。</p><p>maven 属性和 ant 中的属性一样，可以用来存放一些值。这些值可以在 <code>pom.xml</code> 中的任何地方使用标记\${X}来使用，这里 X 是指属性的名称。属性有五种不同的形式，并且都能在 settings.xml 文件中访问。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  1. env.X: 在一个变量前加上"env."的前缀，会返回一个shell环境变量。例如,"env.PATH"指代了$path环境变量（在Windows上是%PATH%）。</span></span><br><span class="line"><span class="comment">  2. project.x：指代了POM中对应的元素值。例如: &lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;通过$&#123;project.version&#125;获得version的值。</span></span><br><span class="line"><span class="comment">  3. settings.x: 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;通过 $&#123;settings.offline&#125;获得offline的值。</span></span><br><span class="line"><span class="comment">  4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 $&#123;java.home&#125;。</span></span><br><span class="line"><span class="comment">  5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user.install</span>&gt;</span>$&#123;user.home&#125;/our-project<span class="tag">&lt;/<span class="name">user.install</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果该 profile 被激活，则可以在<code>pom.xml</code>中使用\${user.install}。</p></blockquote><h4 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h4><p><strong>作用</strong>：远程仓库列表，它是 maven 用来填充构建系统本地仓库所使用的一组远程仓库。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库唯一标识 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="pluginRepositories"><a href="#pluginRepositories" class="headerlink" title="pluginRepositories"></a>pluginRepositories</h4><p><strong>作用</strong>：发现插件的远程仓库列表。</p><p>和 <code>repository</code> 类似，只是 <code>repository</code> 是管理 jar 包依赖的仓库，<code>pluginRepositories</code> 则是管理插件的仓库。<br>maven 插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。<code>pluginRepositories</code> 元素的结构和 <code>repositories</code> 元素的结构类似。每个 <code>pluginRepository</code> 元素指定一个 Maven 可以用来寻找新插件的远程地址。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ActiveProfiles"><a href="#ActiveProfiles" class="headerlink" title="ActiveProfiles"></a>ActiveProfiles</h3><p><strong>作用</strong>：手动激活 profiles 的列表，按照<code>profile</code>被应用的顺序定义<code>activeProfile</code>。</p><p>该元素包含了一组 <code>activeProfile</code> 元素，每个 <code>activeProfile</code> 都含有一个 profile id。任何在 <code>activeProfile</code> 中定义的 profile id，不论环境设置如何，其对应的 <code>profile</code> 都会被激活。如果没有匹配的 <code>profile</code>，则什么都不会发生。</p><p>例如，env-test 是一个 activeProfile，则在 pom.xml（或者 profile.xml）中对应 id 的 profile 会被激活。如果运行过程中找不到这样一个 profile，Maven 则会像往常一样运行。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要激活的profile id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>env-test<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此，maven settings.xml 中的标签都讲解完毕，希望对大家有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven-之-settings-xml-详解&quot;&gt;&lt;a href=&quot;#Maven-之-settings-xml-详解&quot; class=&quot;headerlink&quot; title=&quot;Maven 之 settings.xml 详解&quot;&gt;&lt;/a&gt;Maven 之 settings.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://dunwu.github.io/2019/03/06/database/README/"/>
    <id>https://dunwu.github.io/2019/03/06/database/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><blockquote><p>:dart: 所有配套源码整理归档在 <a href="https://github.com/dunwu/db-tutorial" target="_blank" rel="noopener"><strong>db-tutorial</strong></a> 项目中。</p></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><ul><li><a href="sql">关系型数据库</a></li><li><a href="nosql">非关系型数据库</a></li></ul><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;:dart: 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/dunwu/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统设计</title>
    <link href="https://dunwu.github.io/2019/03/06/design/README/"/>
    <id>https://dunwu.github.io/2019/03/06/design/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统设计&quot;&gt;&lt;a href=&quot;#系统设计&quot; class=&quot;headerlink&quot; title=&quot;系统设计&quot;&gt;&lt;/a&gt;系统设计&lt;/h1&gt;&lt;h2 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;资源&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端技术</title>
    <link href="https://dunwu.github.io/2019/03/06/frontend/README/"/>
    <id>https://dunwu.github.io/2019/03/06/frontend/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h1><blockquote><p>:dart: 所有配套源码整理归档在 <a href="https://github.com/dunwu/frontend-tutorial" target="_blank" rel="noopener"><strong>frontend-tutorial</strong></a> 项目中。</p></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><blockquote><p>前端 web 技术的基石： <code>html</code> + <code>css</code> + <code>js</code></p><ul><li>HTML 定义了网页的内容。</li><li>CSS 定义了网页的样式。</li><li>JavaScript 定义了网页的行为。</li></ul></blockquote><ul><li><a href="base/html.md">Html</a></li><li><a href="base/css.md">Css</a></li><li><a href="base/js.md">Javascript</a></li></ul><h3 id="Nodejs-Npm-Yarn"><a href="#Nodejs-Npm-Yarn" class="headerlink" title="Nodejs, Npm, Yarn"></a>Nodejs, Npm, Yarn</h3><blockquote><p>Nodejs 和包管理器</p><p>流行： <code>npm</code>, <code>yarn</code></p></blockquote><ul><li><a href="nodejs/nodejs.md">Nodejs</a> - 关键词： <code>nodejs</code>, <code>REPL</code>， <code>require</code>, <code>exports</code></li><li><a href="nodejs/npm.md">Npm</a> - 关键词： <code>nodejs</code>, <code>包管理</code>, <code>npm</code>, <code>cnpm</code>, <code>package.json</code>, <code>node_modules</code></li><li><a href="nodejs/yarn.md">Yarn</a> - 关键词： <code>nodejs</code>, <code>包管理</code>, <code>yarn</code>, <code>yarn.lock</code></li></ul><h3 id="ES6-TypeScript-Babel"><a href="#ES6-TypeScript-Babel" class="headerlink" title="ES6, TypeScript, Babel"></a>ES6, TypeScript, Babel</h3><blockquote><p>下一代 Javascript 语言</p></blockquote><ul><li><a href="es6/ES6.md">ES6</a> - 关键词： <code>ES6</code>, <code>ECMAScript</code>, <code>arrow</code>, <code>this</code>, <code>let</code>, <code>const</code>, <code>class</code>, <code>extends</code>, <code>super</code>, <code>arrow</code> …</li><li><a href="es6/babel.md">Babel</a> - 关键词： <code>babel-cli</code>, <code>.babelrc</code>, <code>preset</code>, <code>polyfill</code></li><li><a href="es6/typescript.md">TypeScript</a> - 关键词： <code>typescript</code>, <code>tsc</code></li></ul><h3 id="Bundlers"><a href="#Bundlers" class="headerlink" title="Bundlers"></a>Bundlers</h3><blockquote><p>捆绑资源管理器</p><p>流行： <code>Webpack</code></p></blockquote><ul><li><a href="webpack/webpack.md">Webpack 入门</a></li><li><a href="webpack/concept.md">Webpack 概念</a></li><li><a href="webpack/asset-management.md">Webpack 资源管理</a></li><li><a href="webpack/code-splitting.md">Webpack 代码分离</a></li><li><a href="webpack/development.md">Webpack 开发工具</a></li></ul><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><blockquote><p>静态检查工具、代码格式化工具</p><p>流行： <code>JSLint</code>, <code>JSHint</code>, <code>ESLint</code>, <code>Prettier</code>, <code>Standard</code>, <code>TSlint</code></p></blockquote><ul><li><a href="qa/qa-summary.md">JavaScript QA 工具总结</a></li><li><a href="qa/eslint.md">eslint</a></li></ul><h3 id="MVC-React-Vue-Angular"><a href="#MVC-React-Vue-Angular" class="headerlink" title="MVC - React, Vue, Angular"></a>MVC - React, Vue, Angular</h3><ul><li><a href="mvc/Angular,React,Vue比较.md">Angular,React,Vue 比较</a></li></ul><h4 id="React-技术栈"><a href="#React-技术栈" class="headerlink" title="React 技术栈"></a>React 技术栈</h4><ul><li><a href="mvc/react/react.md">React</a></li></ul><h4 id="Vue-技术栈"><a href="#Vue-技术栈" class="headerlink" title="Vue 技术栈"></a>Vue 技术栈</h4><h4 id="Angular-技术栈"><a href="#Angular-技术栈" class="headerlink" title="Angular 技术栈"></a>Angular 技术栈</h4><ul><li><a href="mvc/angular/angular.md">Angular</a></li></ul><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端技术&quot;&gt;&lt;a href=&quot;#前端技术&quot; class=&quot;headerlink&quot; title=&quot;前端技术&quot;&gt;&lt;/a&gt;前端技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;:dart: 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/du
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://dunwu.github.io/2019/03/06/network/README/"/>
    <id>https://dunwu.github.io/2019/03/06/network/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p></blockquote><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/network.jpg"></div><br></p><h2 id="bulb-指南"><a href="#bulb-指南" class="headerlink" title=":bulb: 指南"></a>:bulb: 指南</h2><p>学习之前，先看一下入门三问：</p><blockquote><p><strong>一、什么是计算机网络？</strong></p><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p><p>——摘自百度百科</p></blockquote><blockquote><p><strong>二、为什么学习计算机网络？</strong></p><p>计算机网络是计算机科学的基础课程，也是计算机专业考研必考科目，可见其重要性。作为一名程序员，了解计算机网络，对于 Web 领域，通信领域的开发有莫大的帮助。</p><p>在浏览器中访问网页的原理是什么？Wifi 是如何工作的？防火墙是如何保障网络安全的？什么是安全证书？Cookie 和 Session 是什么东西？。。。</p><p>如果你接触过这些技术，如果你想了解这些技术的原理，那么你就有必要学习一下计算机网络了。</p></blockquote><blockquote><p><strong>三、如何学习计算机网络？</strong></p><p>本人有 2 年通信领域开发经验，从事通信设备上的协议开发。就我个人的学习经验来看，学习计算机网络可以分为以下阶段：</p><ul><li><strong>基础阶段——一般性的了解网络协议分层及各层功能</strong><ul><li>了解计算机网络协议分层（OSI）有哪些层，分层的依据是什么（即每层的功能是什么）</li><li>了解每层的主要通信设备有哪些；</li><li>了解每层有哪些重要网络协议，这些协议有什么作用，基本原理是什么？</li><li>了解每层的传输数据形式（如：报文、帧等）</li></ul></li><li><strong>进阶阶段——系统学习计算机网络知识，将各层主要协议功能串联起来</strong><ul><li>学习 TCP/IP 详解 卷 1、卷 2、卷 3（内容详实，但文字较为晦涩，不适合初学者）</li></ul></li><li><strong>专业阶段——根据业务领域，有针对性的学习</strong><ul><li>网络协议很多，而且专业性非常强。精通所有协议，几乎是不可能的，所以有必要根据自己的业务领域，有针对性的深入学习协议。如果你是做 web 开发，那么你很有必要认真学习一下 HTTP、DNS 协议；如果你是做路由器、交换机领域通信开发，那么你应该更深入学习一下 IP/TCP/UDP 协议。。。</li><li>如何深入学习协议，最好的学习方式，就是深入学习 RFC，并结合实际的协议报文去了解。</li></ul></li></ul></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><ul><li><a href="network-guide.md">计算机网络指南</a> - 关键词：核心概念、拓扑结构、作用范围、性能指标、体系结构</li><li><a href="physical">物理层</a> - 关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li><li><a href="data-link-layer.md">数据链路层</a> - 关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li><li><a href="network">网络层</a> - 关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li><li><a href="transport">传输层</a> - 关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li><li><a href="application">应用层</a> - 关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li></ul><h2 id="books-学习资源"><a href="#books-学习资源" class="headerlink" title=":books: 学习资源"></a>:books: 学习资源</h2><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><ul><li>谢希仁, 计算机网络 - 国内很多大学将其作为计算机网络课程的指定教材，通俗易懂，适合作为入门教材。</li><li>W·Richard Stevens, <a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP 详解 卷 1：协议</a> - TCP/IP 详解三部曲，适合作为进阶教材</li><li>W·Richard Stevens, <a href="https://book.douban.com/subject/1087767/" target="_blank" rel="noopener">TCP/IP 详解 卷 2：实现</a></li><li>W·Richard Stevens, <a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP 详解 卷 3：TCP 事务协议、HTTP、NNTP 和 UNIX 域协议</a></li></ul><h3 id="站点"><a href="#站点" class="headerlink" title="站点"></a>站点</h3><ul><li><a href="https://www.rfc-editor.org/" target="_blank" rel="noopener">https://www.rfc-editor.org/</a> - 在线查阅、下载 RFC 文档</li></ul><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络指南</title>
    <link href="https://dunwu.github.io/2019/03/06/network/network-guide/"/>
    <id>https://dunwu.github.io/2019/03/06/network/network-guide/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络指南"><a href="#计算机网络指南" class="headerlink" title="计算机网络指南"></a>计算机网络指南</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#核心概念">核心概念</a></li><li><a href="#拓扑结构">拓扑结构</a></li><li><a href="#作用范围">作用范围</a></li><li><a href="#性能指标">性能指标</a></li><li><a href="#体系结构">体系结构</a></li></ul><!-- /TOC --><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>计算机网络</strong> - 计算机网络（computer network），通常也简称网络，是利用通信设备和线路将地理位置不同的、功能独立的多个<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F" target="_blank" rel="noopener">计算机</a>系统连接起来，以功能完善的网络<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">软件</a>实现网络的<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6" target="_blank" rel="noopener">硬件</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6" target="_blank" rel="noopener">软件</a>及资源<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB" target="_blank" rel="noopener">共享</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">信息</a>传递的系统。简单的说即连接两台或多台计算机进行<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">通信</a>的系统。</li><li><strong>互联网</strong> - 互联网（Internet），即网络的网络。</li></ul><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>计算机网络的拓扑结构可分为：</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/overview/network-topological-structure.gif"></div><br></p><ul><li>网型拓扑网型网（Mesh network）</li><li>环型拓扑环型网（Ring network）</li><li>星型拓扑星型网（Star network）</li><li>树状拓扑树型网（Tree network）</li><li>总线拓扑总线网（Bus network）</li></ul><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><ul><li>广域网 WAN（Wide Area Network）</li><li>城域网 MAN（Metropolitan Area Network）</li><li>局域网 LAN（Local Area Network）</li><li>个人区域网 PAN（Personal Area Network）</li></ul><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ul><li><strong>速率</strong> - 速率的单位是 bit/s（比特每秒）。</li><li><strong>带宽（bandwidth）</strong> - 带宽有以下两种不同的意义。<ul><li>信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫 （或千赫，兆赫，吉赫等）。</li><li>网络的带宽表示在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>。这种意义的带宽的单位是 bit/s（比特每秒）。</li></ul></li><li><strong>吞吐量（throughput）</strong> - 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。例如，对于一个 100 Mbit/s 的以太网，其额定速率是 100 Mbit/s。</li><li><strong>时延（delay）</strong><ul><li>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</li></ul></li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/overview/network-layers.png"></div><br></p><ul><li><strong>物理层（Physical Layer）</strong> - 物理层只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。<ul><li>数据单元：比特流。</li><li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li></ul></li><li><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<ul><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul></li><li><strong>网络层（network layer）</strong> - 为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。<ul><li>主要协议：<code>IP</code>。</li><li>数据单元：IP 数据报（packet）。</li><li>典型设备：网关、路由器。</li></ul></li><li><strong>传输层（transport layer）</strong> - 为两台主机中进程间的通信提供通用的数据传输服务。<ul><li>主要协议：<code>TCP</code>、<code>UDP</code>。</li><li>数据单元：报文段（segment）或用户数据报。</li></ul></li><li><strong>会话层（Session Layer）</strong> - 会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。</li><li><strong>表示层（Presentation Layer）</strong> - 表示层是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。</li><li><strong>应用层（application layer）</strong> - 通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。<ul><li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li><li>数据单元：报文（message）。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络指南&quot;&gt;&lt;a href=&quot;#计算机网络指南&quot; class=&quot;headerlink&quot; title=&quot;计算机网络指南&quot;&gt;&lt;/a&gt;计算机网络指南&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://dunwu.github.io/2019/03/06/os/README/"/>
    <id>https://dunwu.github.io/2019/03/06/os/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>:dart: 所有配套源码整理归档在 <a href="https://github.com/dunwu/os-tutorial" target="_blank" rel="noopener"><strong>os-tutorial</strong></a> 项目中。</p></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><ul><li><a href="linux">Linux</a></li><li><a href="windows">Windows</a></li><li><a href="docker">Docker</a></li></ul><h2 id="books-学习资源"><a href="#books-学习资源" class="headerlink" title=":books: 学习资源"></a>:books: 学习资源</h2><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;:dart: 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/du
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><blockquote><p>:coffee: <strong>编程语言</strong></p><p>任何建筑都是一砖一瓦的堆砌，任何软件都是通过编程语言一行一行编写的。每种编程语言都有自身的优缺点，有适合的应用场景。编程语言那么多，人生苦胆，不可能全部掌握。但是，作为程序员，至少应该精通一门高级编程语言，一门脚本语言。所谓一通百通，万变不离其宗，精通一两门编程语言后，自然会发现语言之间也有很多相似性。</p></blockquote><ul><li><a href="java">Java</a></li><li><a href="python.md">Python</a></li><li><a href="shell.md">Shell</a> - 关键词：解释器、注释、变量、Shell 扩展、数组、运算符、语句、函数、流和重定向、Debugging</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编程语言&quot;&gt;&lt;a href=&quot;#编程语言&quot; class=&quot;headerlink&quot; title=&quot;编程语言&quot;&gt;&lt;/a&gt;编程语言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;:coffee: &lt;strong&gt;编程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何建筑都是一砖一瓦的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>目录规范</title>
    <link href="https://dunwu.github.io/2019/03/06/style/dir-style/"/>
    <id>https://dunwu.github.io/2019/03/06/style/dir-style/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-目录结构规范">1. 目录结构规范</a></li><li><a href="#2-文件管理软件">2. 文件管理软件</a><ul><li><a href="#21-clover">2.1. Clover</a></li><li><a href="#22-everything">2.2. Everything</a></li><li><a href="#23-wox">2.3. Wox</a></li><li><a href="#24-q-dir">2.4. Q-dir</a></li></ul></li></ul><!-- /TOC --><h2 id="1-目录结构规范"><a href="#1-目录结构规范" class="headerlink" title="1. 目录结构规范"></a>1. 目录结构规范</h2><blockquote><p>作为程序员，想必每个人都会有大量的资料、数据。按照条理清晰的目录结构去分类化存储，十分有助于管理文件。</p></blockquote><p>以下是我个人整理的目录结构：</p><figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Codes           <span class="comment">#代码目录</span></span><br><span class="line">│   ├── Other       <span class="comment">#第三方代码目录</span></span><br><span class="line">│   ├── My          <span class="comment">#个人代码目录</span></span><br><span class="line">│   └── Work        <span class="comment">#工作代码目录</span></span><br><span class="line">├── <span class="built_in">Data</span>            <span class="comment">#数据目录</span></span><br><span class="line">├── Downloads       <span class="comment">#下载文件目录</span></span><br><span class="line">├── Docs            <span class="comment">#文档目录</span></span><br><span class="line">│   ├── Books       <span class="comment">#电子书目录</span></span><br><span class="line">│   ├── My          <span class="comment">#个人文档目录</span></span><br><span class="line">│   └── Work        <span class="comment">#工作文档目录</span></span><br><span class="line">├── Movies          <span class="comment">#视频目录</span></span><br><span class="line">├── Music           <span class="comment">#音乐目录</span></span><br><span class="line">├── Pictures        <span class="comment">#图片目录</span></span><br><span class="line">├── Public          <span class="comment">#共享目录</span></span><br><span class="line">├── Temp            <span class="comment">#临时文件目录</span></span><br><span class="line">└── Tools           <span class="comment">#工具软件目录</span></span><br><span class="line">    └── Packages    <span class="comment">#安装包目录</span></span><br></pre></td></tr></table></figure><p>注：如果您使用的操作系统是 Mac 这种可以为目录或文件添加 tag 的操作系统，那么您可以根据自己的喜好更细致化的管理。</p><h2 id="2-文件管理软件"><a href="#2-文件管理软件" class="headerlink" title="2. 文件管理软件"></a>2. 文件管理软件</h2><blockquote><p>选用便利的文件管理软件，可以让你的文件管理如虎添翼。这里推荐几款经典的文件管理工具。</p></blockquote><h3 id="2-1-Clover"><a href="#2-1-Clover" class="headerlink" title="2.1. Clover"></a>2.1. Clover</h3><blockquote><p><a href="http://cn.ejie.me/" target="_blank" rel="noopener">Clover</a> 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。</p></blockquote><div align="center"><br><img src="http://cn.ejie.me/images/clover.jpg" width="640"><br></div><h3 id="2-2-Everything"><a href="#2-2-Everything" class="headerlink" title="2.2. Everything"></a>2.2. Everything</h3><blockquote><p><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> 可以立即在 windows 系统中找到制定名称的文件和文件夹。</p></blockquote><div align="center"><br><img src="http://www.voidtools.com/sssmall2.gif" width="640"><br></div><h3 id="2-3-Wox"><a href="#2-3-Wox" class="headerlink" title="2.3. Wox"></a>2.3. Wox</h3><blockquote><p><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">Wox</a> 是一款简单易用的 Windows 启动器。可以把它视为 windows 版的 Alfred。</p></blockquote><div align="center"><br><img src="https://camo.githubusercontent.com/9db33546d3a905a9ad915e0948d3ba3f47f57b64/687474703a2f2f692e696d6775722e636f6d2f4474784e424a692e676966" width="640"><br></div><h3 id="2-4-Q-dir"><a href="#2-4-Q-dir" class="headerlink" title="2.4. Q-dir"></a>2.4. Q-dir</h3><blockquote><p><a href="http://www.softpedia.com/get/File-managers/Q-Dir.shtml" target="_blank" rel="noopener">Q-dir</a> 是轻量的文件管理器,特点鲜明,各种布局视图切换灵活,默认四个小窗口组成一个大窗口,操作快捷。</p></blockquote><div align="center"><br><img src="http://i1-win.softpedia-static.com/screenshots/q-dir_1.png" width="640"><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目录规范&quot;&gt;&lt;a href=&quot;#目录规范&quot; class=&quot;headerlink&quot; title=&quot;目录规范&quot;&gt;&lt;/a&gt;目录规范&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-目录结构规范&quot;&gt;1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目规范</title>
    <link href="https://dunwu.github.io/2019/03/06/style/project-style/"/>
    <id>https://dunwu.github.io/2019/03/06/style/project-style/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h1><blockquote><p>软件项目开发规范。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#项目结构">项目结构</a><ul><li><a href="#目录">目录</a></li><li><a href="#文件">文件</a></li></ul></li><li><a href="#目录名">目录名</a></li><li><a href="#文件名">文件名</a></li></ul><!-- /TOC --><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>以下为项目根目录下的文件和目录的组织结构：</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><strong>codes</strong>：代码目录。</p><p><strong>configurations</strong>：配置目录。一般存放项目相关的配置文件。如 maven 的 settings.xml，nginx 的 nginx.conf 等。</p><p><strong>demos</strong>：示例目录。</p><p><strong>docs</strong>：文档目录。</p><p><strong>libs</strong>：第三方库文件。</p><p><strong>scripts</strong>：脚本目录。一般存放用于启动、构建项目的可执行脚本文件。</p><p><strong>packages</strong>：打包文件目录。Java 项目中可能是 jar、war 等；前端项目中可能是 zip、rar 等；电子书项目中可能是 pdf 等。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><strong>.gitignore</strong>：git 忽略规则。</p><p><strong>.gitattributes</strong>：git 属性规则。</p><p><strong>.editorconfig</strong>：编辑器书写规则。</p><p><strong>README.md</strong>：项目说明文件。</p><p><strong>LICENSE</strong>：开源协议。如果项目是开源文件，需要添加。</p><h2 id="目录名"><a href="#目录名" class="headerlink" title="目录名"></a>目录名</h2><p>目录名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><p>目录名建议只使用小写字母，不使用大写字母。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">不佳： <span class="keyword">Test</span></span><br><span class="line">正确： <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>目录名可以使用数字，但不应该是首字符。</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">不佳： <span class="number">1</span>-demo</span><br><span class="line">正确： dem<span class="meta">o1</span></span><br></pre></td></tr></table></figure><p>目录名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">不佳： common_demo</span><br><span class="line">正确： <span class="meta">common</span>-demo</span><br></pre></td></tr></table></figure><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">错误： 名词解释<span class="selector-class">.md</span></span><br><span class="line">正确： <span class="selector-tag">glossary</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">错误：<span class="selector-tag">TroubleShooting</span><span class="selector-class">.md</span></span><br><span class="line">正确：<span class="selector-tag">troubleshooting</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>一些约定俗成的习惯可以保持传统写法，如：Java 的文件名一般使用驼峰命名法，且首字母大写；配置文件 <code>applicationContext.xml</code> ；React 中的 JSX 组件文件名一般使用驼峰命名法，且首字母大写等。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">不佳：<span class="selector-tag">advanced_usage</span><span class="selector-class">.md</span></span><br><span class="line">正确：<span class="selector-tag">advanced-usage</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目规范&quot;&gt;&lt;a href=&quot;#项目规范&quot; class=&quot;headerlink&quot; title=&quot;项目规范&quot;&gt;&lt;/a&gt;项目规范&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;软件项目开发规范。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- TOC depthFrom:2 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1. MyBatis Generator (MBG) 指南</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javaweb/standalone/orm/mybatis-generator/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javaweb/standalone/orm/mybatis-generator/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MyBatis-Generator-MBG-指南"><a href="#1-MyBatis-Generator-MBG-指南" class="headerlink" title="1. MyBatis Generator (MBG) 指南"></a>1. MyBatis Generator (MBG) 指南</h1><blockquote><p>MyBatis Generator (MBG) 用于自动生成 Mybatis 代码。</p><p>本文转载自 <a href="https://blog.csdn.net/isea533/article/details/42102297" target="_blank" rel="noopener">MyBatis Generator 详解</a></p></blockquote><!-- TOC depthFrom:2 depthTo:4 --><ul><li><a href="#1-配置详解">1. 配置详解</a><ul><li><a href="#11-文件头">1.1. 文件头</a></li><li><a href="#12-根元素">1.2. 根元素</a></li><li><a href="#13-properties-元素">1.3. properties 元素</a></li><li><a href="#14-classpathentry-元素">1.4. classPathEntry 元素</a></li><li><a href="#15-context-元素">1.5. context 元素</a><ul><li><a href="#151-plugin-元素">1.5.1. plugin 元素</a></li><li><a href="#152-commentgenerator-元素">1.5.2. commentGenerator 元素</a></li><li><a href="#153-jdbcconnection-元素">1.5.3. jdbcConnection 元素</a></li><li><a href="#154-javatyperesolver-元素">1.5.4. javaTypeResolver 元素</a></li><li><a href="#155-javamodelgenerator-元素">1.5.5. javaModelGenerator 元素</a></li></ul></li><li><a href="#16-sqlmapgenerator-元素">1.6. sqlMapGenerator 元素</a></li><li><a href="#17-javaclientgenerator-元素">1.7. javaClientGenerator 元素</a></li><li><a href="#18-table-元素">1.8. table 元素</a><ul><li><a href="#181-generatedkey-元素">1.8.1. generatedKey 元素</a></li><li><a href="#182-columnrenamingrule-元素">1.8.2. columnRenamingRule 元素</a></li><li><a href="#183-columnoverride-元素">1.8.3. columnOverride 元素</a></li><li><a href="#184-ignorecolumn-元素">1.8.4. ignoreColumn 元素</a></li></ul></li></ul></li><li><a href="#2-mybatis-generator-最佳实践">2. MyBatis Generator 最佳实践</a></li><li><a href="#3-引用和引申">3. 引用和引申</a></li></ul><!-- /TOC --><h2 id="1-配置详解"><a href="#1-配置详解" class="headerlink" title="1. 配置详解"></a>1. 配置详解</h2><blockquote><p>MBG 支持 xml 格式的配置文件。</p></blockquote><h3 id="1-1-文件头"><a href="#1-1-文件头" class="headerlink" title="1.1. 文件头"></a>1.1. 文件头</h3><p>配置文件必须包含上面的 <code>DOCTYPE</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-根元素"><a href="#1-2-根元素" class="headerlink" title="1.2. 根元素"></a>1.2. 根元素</h3><p><code>&lt;generatorConfiguration&gt;</code> 是 MBG 的根节点，它没有任何属性。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体配置内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;generatorConfiguration&gt;</code> 元素包含以下子元素（有严格的顺序）：</p><ol><li><code>&lt;properties&gt;</code> (0 个或 1 个)</li><li><code>&lt;classPathEntry&gt;</code> (0 个或多个)</li><li><code>&lt;context&gt;</code> (1 个或多个)</li></ol><h3 id="1-3-properties-元素"><a href="#1-3-properties-元素" class="headerlink" title="1.3. properties 元素"></a>1.3. properties 元素</h3><p>这个元素用来指定外部的属性元素，不是必须的元素。</p><p>元素用于指定一个需要在配置中解析使用的外部属性文件，引入属性文件后，可以在配置中使用 <code>${property}</code> 这种形式的引用，通过这种方式引用属性文件中的属性值。 对于后面需要配置的<strong>jdbc 信息</strong>和 targetProject 属性会很有用。</p><p>这个属性可以通过 <code>resource</code> 或者 <code>url</code> 来指定属性文件的位置，这两个属性只能使用其中一个来指定，同时出现会报错。</p><ul><li><code>resource</code>：指定<strong>classpath</strong>下的属性文件，使用类似 <code>com/myproject/generatorConfig.properties</code> 这样的属性值。</li><li><code>url</code>：可以指定文件系统上的特定位置，例如 <code>file://C:/myfolder/generatorConfig.properties</code></li></ul><h3 id="1-4-classPathEntry-元素"><a href="#1-4-classPathEntry-元素" class="headerlink" title="1.4. classPathEntry 元素"></a>1.4. classPathEntry 元素</h3><p>这个元素可以 0 或多个，不受限制。</p><p>最常见的用法是通过这个属性指定驱动的路径，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">"E:\mysql\mysql-connector-java-5.1.29.jar"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>注意，<code>classPathEntry</code> 只在下面这两种情况下才有效：</p><ul><li>当加载 JDBC 驱动默认数据库时</li><li>当加载根类中的 <code>JavaModelGenerator</code> 检查重写的方法时</li></ul><p>因此，如果你需要加载其他用途的 jar <code>包，classPathEntry</code> 起不到作用，不能这么写，解决的办法就是将你用的 jar 包添加到类路径中，在 Eclipse 等 IDE 中运行的时候，添加 jar 包比较容易。当从命令行执行的时候，需要用 <code>java -cp xx.jar,xx2.jar xxxMainClass</code> 这种方式在-cp 后面指定来使用(注意-jar 会导致-cp 无效)。</p><h3 id="1-5-context-元素"><a href="#1-5-context-元素" class="headerlink" title="1.5. context 元素"></a>1.5. context 元素</h3><p>在 MBG 的配置中，至少需要有一个 <code>&lt;context&gt;</code> 元素。</p><p><code>&lt;context&gt;</code> 元素用于指定生成一组对象的环境。例如指定要连接的数据库，要生成对象的类型和要处理的数据库中的表。运行 MBG 的时候还可以指定要运行的 <code>&lt;context&gt;</code>。</p><p>该元素只有一个<strong>必选属性</strong> <code>id</code>，用来唯一确定一个 <code>&lt;context&gt;</code> 元素，该 <code>id</code> 属性可以在运行 MBG 的使用。</p><p>此外还有几个<strong>可选属性</strong>：</p><ul><li><code>defaultModelType</code> - <strong>这个属性很重要</strong>，这个属性定义了 MBG 如何生成<strong>实体类</strong>。该属性支持以下可选值：<ul><li><code>conditional</code> - 这是默认值。这个模型和下面的 hierarchical 类似，除了如果那个单独的类将只包含一个字段，将不会生成一个单独的类。 因此,如果一个表的主键只有一个字段,那么不会为该字段生成单独的实体类,会将该字段合并到基本实体类中。</li><li><code>flat</code> - 该模型为每一张表只生成一个实体类。这个实体类包含表中的所有字段。<strong>这种模型最简单，推荐使用。</strong></li><li><code>hierarchical</code> - 如果表有主键,那么该模型会产生一个单独的主键实体类,如果表还有 BLOB 字段， 则会为表生成一个包含所有 BLOB 字段的单独的实体类,然后为所有其他的字段生成一个单独的实体类。 MBG 会在所有生成的实体类之间维护一个继承关系。</li></ul></li><li><code>targetRuntime</code> - 此属性用于指定生成的代码的运行时环境。该属性支持以下可选值：<ul><li>MyBatis3 - 这是默认值。</li><li>MyBatis3Simple</li><li>Ibatis2Java2</li><li>Ibatis2Java5 一般情况下使用默认值即可，有关这些值的具体作用以及区别请查看中文文档的详细内容。</li></ul></li><li><code>introspectedColumnImpl</code> - 该参数可以指定扩展 <code>org.mybatis.generator.api.IntrospectedColumn</code> 该类的实现类。</li></ul><p>一般情况下，我们使用如下的配置即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"Mysql"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你希望不生成和 Example 查询有关的内容，那么可以按照如下进行配置:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"Mysql"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3Simple"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 MyBatis3Simple 可以避免在后面的 <code>&lt;table&gt;</code> 中逐个进行配置（后面会提到）。</p><p>MBG 配置中的其他几个元素，基本上都是 <code>&lt;context&gt;</code> 的子元素，这些子元素（有严格的配置顺序）包括：</p><ul><li><code>&lt;property&gt;</code> (0 个或多个)</li><li><code>&lt;plugin&gt;</code> (0 个或多个)</li><li><code>&lt;commentGenerator&gt;</code> (0 个或 1 个)</li><li><code>&lt;jdbcConnection&gt;</code> (1 个)</li><li><code>&lt;javaTypeResolver&gt;</code> (0 个或 1 个)</li><li><code>&lt;javaModelGenerator&gt;</code> (1 个)</li><li><code>&lt;sqlMapGenerator&gt;</code> (0 个或 1 个)</li><li><code>&lt;javaClientGenerator&gt;</code> (0 个或 1 个)</li><li><code>&lt;table&gt;</code> (1 个或多个)</li></ul><p>其中 <code>&lt;property&gt;</code> 属性比较特殊，后面讲解的时候都会和父元素一起进行讲解。在讲解 <code>&lt;property&gt;</code> 属性前，我们先看看<strong>什么是分隔符？</strong>。</p><p>这里通过一个例子说明。假设在 Mysql 数据库中有一个表名为 <code>user info</code>，你没有看错，中间是一个空格，这种情况下如果写出 <code>select * from user info</code> 这样的语句，肯定是要报错的，在 Mysql 中的时候我们一般会写成如下的样子:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`user info`</span></span><br></pre></td></tr></table></figure><p>这里的使用的<strong>反单引号(`)</strong>就是<strong>分隔符</strong>，<strong>分隔符</strong>可以用于<strong>表名</strong>或者<strong>列名</strong>。</p><p>下面继续看 <code>&lt;property&gt;</code> 支持的属性：</p><ul><li><code>autoDelimitKeywords</code></li><li><code>beginningDelimiter</code></li><li><code>endingDelimiter</code></li><li><code>javaFileEncoding</code></li><li><code>javaFormatter</code></li><li><code>xmlFormatter</code></li></ul><p>由于这些属性比较重要，这里一一讲解。</p><p>首先是 <code>autoDelimitKeywords</code>，当表名或者字段名为 SQL 关键字的时候，可以设置该属性为 true，MBG 会自动给表名或字段名添加<strong>分隔符</strong>。</p><p>然后这里继续上面的例子来讲 <code>beginningDelimiter</code> 和 <code>endingDelimiter</code> 属性。</p><p>由于 <code>beginningDelimiter</code> 和 <code>endingDelimiter</code> 的默认值为双引号(“)，在 Mysql 中不能这么写，所以还要将这两个默认值改为<strong>反单引号(`)</strong>，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>属性 <code>javaFileEncoding</code> 设置要使用的 Java 文件的编码，默认使用当前平台的编码，只有当生产的编码需要特殊指定时才需要使用，一般用不到。</p><p>最后两个 <code>javaFormatter</code> 和 <code>xmlFormatter</code> 属性<strong>可能会</strong>很有用，如果你想使用模板来定制生成的 java 文件和 xml 文件的样式，你可以通过指定这两个属性的值来实现。</p><h4 id="1-5-1-plugin-元素"><a href="#1-5-1-plugin-元素" class="headerlink" title="1.5.1. plugin 元素"></a>1.5.1. plugin 元素</h4><p>该元素可以配置 0 个或者多个，不受限制。</p><p><code>&lt;plugin&gt;</code> 元素用来定义一个插件。插件用于扩展或修改通过 MBG 代码生成器生成的代码。</p><p>插件将按在配置中配置的顺序执行。</p><p>有关插件的详细信息可以参考<a href="http://mbg.cndocs.ml/reference/pluggingIn.html" target="_blank" rel="noopener">开发插件</a>和<a href="http://mbg.cndocs.ml/reference/plugins.html" target="_blank" rel="noopener">提供的插件</a>了解更多。</p><h4 id="1-5-2-commentGenerator-元素"><a href="#1-5-2-commentGenerator-元素" class="headerlink" title="1.5.2. commentGenerator 元素"></a>1.5.2. commentGenerator 元素</h4><p>该元素最多可以配置 1 个。</p><p>这个元素非常有用，相信很多人都有过这样的需求，就是希望 MBG 生成的代码中可以包含注释信息，具体就是生成表或字段的备注信息。</p><p>使用这个元素就能很简单的实现我们想要的功能。这里先介绍该元素，介绍完后会举例如何扩展实现该功能。</p><p>该元素有一个可选属性 type,可以指定用户的实现类，该类需要实现 <code>org.mybatis.generator.api.CommentGenerator</code> 接口。而且必有一个默认的构造方法。这个属性接收默认的特殊值 DEFAULT，会使用默认的实现类 <code>org.mybatis.generator.internal.DefaultCommentGenerator</code>。</p><p>默认的实现类中提供了两个可选属性，需要通过 <code>&lt;property&gt;</code> 属性进行配置。</p><ul><li><code>suppressAllComments</code> - 阻止生成注释，默认为 false</li><li><code>suppressDate</code> - 阻止生成的注释包含时间戳，默认为 false</li></ul><p>一般情况下由于 MBG 生成的注释信息没有任何价值，而且有时间戳的情况下每次生成的注释都不一样，使用版本控制的时候每次都会提交，因而一般情况下我们都会屏蔽注释信息，可以如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们简单举例实现生成包含表字段注释信息的注释</p><p>因为系统提供了一个默认的实现类，所以对我们来说，自己实现一个会很容易，最简单的方法就是复制默认实现类代码到一个新的文件中，修改类名如 <code>MyCommentGenerator</code>，在你自己的实现类中，你可以选择是否继续支持上面的两个属性，你还可以增加对其他属性的支持。</p><p>我们通过下面一个方法的修改来了解，其他几个方法请自行修改(写本章的时候我也没有完全实现该类，所以不提供完整源码了):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFieldComment</span><span class="params">(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (introspectedColumn.getRemarks() != <span class="keyword">null</span> &amp;&amp; !introspectedColumn.getRemarks().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        field.addJavaDocLine(<span class="string">"/**"</span>);</span><br><span class="line">        field.addJavaDocLine(<span class="string">" * "</span> + introspectedColumn.getRemarks());</span><br><span class="line">        addJavadocTag(field, <span class="keyword">false</span>);</span><br><span class="line">        field.addJavaDocLine(<span class="string">" */"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是给字段添加注释信息的，其中 <code>IntrospectedColumn</code> 包含了字段的完整信息，通过 getRemarks 方法可以获取字段的注释信息。上面这个方法修改起来还是很容易的。除了字段的注释外还有 <code>Getter</code> 和 <code>Setter</code>，以及类的注释。此外还有生成 XML 的注释，大家可以根据默认的实现进行修改。</p><p>完成我们自己的实现类后，我们还需要做如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">commentGenerator</span> <span class="attr">type</span>=<span class="string">"com.github.abel533.mybatis.generator.MyCommentGenerator"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-3-jdbcConnection-元素"><a href="#1-5-3-jdbcConnection-元素" class="headerlink" title="1.5.3. jdbcConnection 元素"></a>1.5.3. jdbcConnection 元素</h4><p><code>&lt;jdbcConnection&gt;</code> 用于指定数据库连接信息，该元素必选，并且只能有一个。</p><p>配置该元素只需要注意如果 JDBC 驱动不在<strong>classpath</strong>下，就需要通过 <code>&lt;classPathEntry&gt;</code> 元素引入 jar 包，这里<strong>推荐</strong>将 jar 包放到<strong>classpath</strong>下。</p><p>该元素有两个必选属性:</p><ul><li><code>driverClass</code> - 访问数据库的 JDBC 驱动程序的完全限定类名</li><li><code>connectionURL</code> - 访问数据库的 JDBC 连接 URL</li></ul><p>该元素还有两个可选属性:</p><ul><li><code>userId</code> - 访问数据库的用户 ID</li><li><code>password</code> - 访问数据库的密码</li></ul><p>此外该元素还可以接受多个 <code>&lt;property&gt;</code> 子元素，这里配置的 <code>&lt;property&gt;</code> 属性都会添加到 JDBC 驱动的属性中。</p><p>这个元素配置起来最容易，这里举个简单例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-4-javaTypeResolver-元素"><a href="#1-5-4-javaTypeResolver-元素" class="headerlink" title="1.5.4. javaTypeResolver 元素"></a>1.5.4. javaTypeResolver 元素</h4><p>该元素最多可以配置一个。</p><p>这个元素的配置用来指定 JDBC 类型和 Java 类型如何转换。</p><p>该元素提供了一个可选的属性 type，和 <code>&lt;commentGenerator&gt;</code> 比较类型，提供了默认的实现 DEFAULT，一般情况下使用默认即可，需要特殊处理的情况可以通过其他元素配置来解决，不建议修改该属性。</p><p>该属性还有一个可以配置的 <code>&lt;property&gt;</code> 元素。</p><p>可以配置的属性为 forceBigDecimals，该属性可以控制是否强制 DECIMAL 和 NUMERIC 类型的字段转换为 Java 类型的 <code>java.math.BigDecimal</code>，默认值为 false，一般不需要配置。</p><p>默认情况下的转换规则为：</p><ol><li>如果 <code>精度&gt;0</code> 或者 <code>长度&gt;18</code>，就会使用 <code>java.math.BigDecimal</code></li><li>如果 <code>精度=0</code> 并且 <code>10&lt;=长度&lt;=18</code>，就会使用 <code>java.lang.Long</code></li><li>如果 <code>精度=0</code> 并且 <code>5&lt;=长度&lt;=9</code>，就会使用 <code>java.lang.Integer</code></li><li>如果 <code>精度=0</code> 并且 <code>长度&lt;5</code>，就会使用 <code>java.lang.Short</code></li><li>如果设置为 <code>true</code>，那么一定会使用 <code>java.math.BigDecimal</code>，配置示例如下：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-5-javaModelGenerator-元素"><a href="#1-5-5-javaModelGenerator-元素" class="headerlink" title="1.5.5. javaModelGenerator 元素"></a>1.5.5. javaModelGenerator 元素</h4><p>该元素必须配置一个，并且最多一个。</p><p>该元素用来控制生成的实体类，根据 <code>&lt;context&gt;</code> 中配置的 <code>defaultModelType</code>，一个表可能会对应生成多个不同的实体类。一个表对应多个类实际上并不方便，所以前面也推荐使用 <code>flat</code>，这种情况下一个表对应一个实体类。</p><p>该元素只有两个属性，都是必选的。</p><ul><li><code>targetPackage</code> - 生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响( <code>&lt;table&gt;</code> 中会提到)。</li><li><code>targetProject</code> - 指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=”src/main/java”）。</li></ul><p>该元素支持以下几个 <code>&lt;property&gt;</code> 子元素属性：</p><ul><li><code>constructorBased</code> - 该属性只对 MyBatis3 有效，如果 true 就会使用构造方法入参，如果 false 就会使用 setter 方式。默认为 false。</li><li><code>enableSubPackages</code> - 如果 true，MBG 会根据 <code>catalog</code> 和 <code>schema</code> 来生成子包。如果 false 就会直接用 <code>targetPackage</code> 属性。默认为 false。</li><li><code>immutable</code> - 该属性用来配置实体类属性是否可变，如果设置为 true，那么 constructorBased 不管设置成什么，都会使用构造方法入参，并且不会生成 setter 方法。如果为 false，实体类属性就可以改变。默认为 false。</li><li><code>rootClass</code> - 设置所有实体类的基类。如果设置，需要使用类的全限定名称。并且如果 MBG 能够加载 rootClass，那么 MBG 不会覆盖和父类中完全匹配的属性。匹配规则：<ul><li>属性名完全相同</li><li>属性类型相同</li><li>属性有 getter 方法</li><li>属性有 setter 方法</li></ul></li><li><code>trimStrings</code> - 是否对数据库查询结果进行 trim 操作，如果设置为 true 就会生成类似这样 <code>public void setUsername(String username) {this.username = username == null ? null : username.trim();}</code> 的 setter 方法。默认值为 false。</li></ul><p>配置示例如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"test.model"</span> <span class="attr">targetProject</span>=<span class="string">"src\main\java"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-sqlMapGenerator-元素"><a href="#1-6-sqlMapGenerator-元素" class="headerlink" title="1.6. sqlMapGenerator 元素"></a>1.6. sqlMapGenerator 元素</h3><p>该元素可选，最多配置一个。但是有如下两种必选的特殊情况：</p><ul><li>如果 <code>targetRuntime</code> 目标是<strong>iBATIS2</strong>，该元素必须配置一个。</li><li>如果 <code>targetRuntime</code> 目标是<strong>MyBatis3</strong>，只有当 <code>&lt;javaClientGenerator&gt;</code> 需要 XML 时，该元素必须配置一个。 如果没有配置 <code>&lt;javaClientGenerator&gt;</code> ，则使用以下的规则：<ul><li>如果指定了一个 <code>&lt;sqlMapGenerator&gt;</code> ，那么 MBG 将只生成 XML 的 SQL 映射文件和实体类。</li><li>如果没有指定 <code>&lt;sqlMapGenerator&gt;</code> ，那么 MBG 将只生成实体类。</li></ul></li><li>该元素只有两个属性（和前面提过的 <code>&lt;javaModelGenerator&gt;</code> 的属性含义一样），都是必选的。</li><li><code>targetPackage</code> - 生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响( <code>&lt;table&gt;</code> 中会提到)。</li><li><code>targetProject</code> - 指定目标项目路径，可以是绝对路径或相对路径（如 <code>targetProject=&quot;src/main/resources&quot;</code>）。</li><li>该元素支持 <code>&lt;property&gt;</code> 子元素，只有一个可以配置的属性：</li><li><code>enableSubPackages</code> - 如果 true，MBG 会根据 <code>catalog</code> 和 <code>schema</code> 来生成子包。如果 false 就会直接用 <code>targetPackage</code> 属性。默认为 false。</li></ul><p>配置示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"test.xml"</span>  <span class="attr">targetProject</span>=<span class="string">"src\main\resources"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-7-javaClientGenerator-元素"><a href="#1-7-javaClientGenerator-元素" class="headerlink" title="1.7. javaClientGenerator 元素"></a>1.7. javaClientGenerator 元素</h3><p>该元素可选，最多配置一个。</p><p>如果不配置该元素，就不会生成 Mapper 接口。</p><p>该元素有 3 个必选属性：</p><ul><li><code>type</code> - 该属性用于选择一个预定义的客户端代码（可以理解为 Mapper 接口）生成器，用户可以自定义实现，需要继承 <code>org.mybatis.generator.codegen.AbstractJavaClientGenerator</code> 类，必选有一个默认的构造方法。 该属性提供了以下预定的代码生成器，首先根据 <code>&lt;context&gt;</code> 的 <code>targetRuntime</code> 分成三类：<ul><li>MyBatis3<ul><li><code>ANNOTATEDMAPPER</code> - 基于注解的 Mapper 接口，不会有对应的 XML 映射文件</li><li><code>MIXEDMAPPER</code> - XML 和注解的混合形式，(上面这种情况中的)SqlProvider 注解方法会被 XML 替代。</li><li><code>XMLMAPPER</code> - 所有的方法都在 XML 中，接口调用依赖 XML 文件。</li></ul></li><li>MyBatis3Simple<ul><li><code>ANNOTATEDMAPPER</code> - 基于注解的 Mapper 接口，不会有对应的 XML 映射文件</li><li><code>XMLMAPPER</code> - 所有的方法都在 XML 中，接口调用依赖 XML 文件。</li></ul></li><li>Ibatis2Java2 或 Ibatis2Java5<ul><li><code>IBATIS</code> - 生成的对象符合 iBATIS 的 DAO 框架（不建议使用）。</li><li><code>GENERIC-CI</code> - 生成的对象将只依赖于 SqlMapClient，通过构造方法注入。</li><li><code>GENERIC-SI</code> - 生成的对象将只依赖于 SqlMapClient，通过 setter 方法注入。</li><li><code>SPRING</code> - 生成的对象符合 Spring 的 DAO 接口</li></ul></li></ul></li><li><code>targetPackage</code> - 生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响( <code>&lt;table&gt;</code> 中会提到)。</li><li><code>targetProject</code> - 指定目标项目路径，可以是绝对路径或相对路径（如 <code>targetProject=&quot;src/main/java&quot;</code>）。该元素还有一个可选属性：<ul><li><code>implementationPackage</code> - 如果指定了该属性，实现类就会生成在这个包中。</li><li>该元素支持 <code>&lt;property&gt;</code> 子元素设置的属性：<ul><li><code>enableSubPackages</code></li><li><code>exampleMethodVisibility</code></li><li><code>methodNameCalculator</code></li><li><code>rootInterface</code> - 用于指定一个所有生成的接口都继承的父接口。 这个值可以通过 <code>&lt;table&gt;</code> 配置的 <code>rootInterface</code> 属性覆盖。这个属性对于通用 Mapper 来说，可以让生成的所有接口都继承该接口。</li><li><code>useLegacyBuilder</code></li></ul></li></ul></li></ul><p>配置示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"test.dao"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">targetProject</span>=<span class="string">"src\main\java"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-8-table-元素"><a href="#1-8-table-元素" class="headerlink" title="1.8. table 元素"></a>1.8. table 元素</h3><p>该元素至少要配置一个，可以配置多个。</p><p>该元素用来配置要通过内省的表。只有配置的才会生成实体类和其他文件。</p><p>该元素有一个必选属性：</p><ul><li><code>tableName</code> - 指定要生成的表名，可以使用 SQL 通配符匹配多个表。</li></ul><p>例如要生成全部的表，可以按如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"%"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>该元素包含多个可选属性：</p><ul><li><code>schema</code> - 数据库的 <code>schema</code>,可以使用 SQL 通配符匹配。如果设置了该值，生成 SQL 的表名会变成如 <code>schema.tableName</code> 的形式。</li><li><code>catalog</code> - 数据库的 <code>catalog</code>，如果设置了该值，生成 SQL 的表名会变成如 catalog.tableName 的形式。</li><li><code>alias</code> - 如果指定，这个值会用在生成的 select 查询 SQL 的表的别名和列名上。 列名会被别名为 alias<em>actualColumnName(别名</em>实际列名) 这种模式。</li><li><code>domainObjectName</code> - 生成对象的基本名称。如果没有指定，MBG 会自动根据表名来生成名称。</li><li><code>enableXXX</code> - XXX 代表多种 SQL 方法，该属性用来指定是否生成对应的 XXX 语句。</li><li><code>selectByPrimaryKeyQueryId</code> - DBA 跟踪工具会用到，具体请看详细文档。</li><li><code>selectByExampleQueryId</code> - DBA 跟踪工具会用到，具体请看详细文档。</li><li><code>modelType</code> - 和 <code>&lt;context&gt;</code> 的 <code>defaultModelType</code> 含义一样，这里可以针对表进行配置，这里的配置会覆盖 <code>&lt;context&gt;</code> 的 <code>defaultModelType</code> 配置。</li><li><code>escapeWildcards</code> - 这个属性表示当查询列，是否对 <code>schema</code> 和表名中的 SQL 通配符 (‘_‘ and ‘%’) 进行转义。 对于某些驱动当 <code>schema</code> 或表名中包含 SQL 通配符时（例如，一个表名是 MY_TABLE，有一些驱动需要将下划线进行转义）是必须的。默认值是 false。</li><li><code>delimitIdentifiers</code> - 是否给标识符增加<strong>分隔符</strong>。默认 false。当 <code>catalog</code>、<code>schema</code> 或 <code>tableName</code> 中包含空白时，默认为 true。</li><li><code>delimitAllColumns</code> - 是否对所有列添加<strong>分隔符</strong>。默认 false。</li><li>该元素包含多个可用的 <code>&lt;property&gt;</code> 子元素，可选属性为：</li><li><code>constructorBased</code> - 和 <code>&lt;javaModelGenerator&gt;</code> 中的属性含义一样。</li><li><code>ignoreQualifiersAtRuntime</code> - 生成的 SQL 中的表名将不会包含 <code>schema</code> 和 <code>catalog</code> 前缀。</li><li><code>immutable</code> - 和 <code>&lt;javaModelGenerator&gt;</code> 中的属性含义一样。</li><li><code>modelOnly</code> - 此属性用于配置是否为表只生成实体类。如果设置为 true 就不会有 Mapper 接口。如果配置了 <code>&lt;sqlMapGenerator&gt;</code> ，并且 modelOnly 为 true，那么 XML 映射文件中只有实体对象的映射元素( <code>&lt;resultMap&gt;</code> )。如果为 true 还会覆盖属性中的 enableXXX 方法，将不会生成任何 CRUD 方法。</li><li><code>rootClass</code> - 和 <code>&lt;javaModelGenerator&gt;</code> 中的属性含义一样。</li><li><code>rootInterface</code> - 和 <code>&lt;javaClientGenerator&gt;</code> 中的属性含义一样。</li><li><code>runtimeCatalog</code> - 运行时的 <code>catalog</code>，当生成表和运行环境的表的 <code>catalog</code> 不一样的时候可以使用该属性进行配置。</li><li><code>runtimeschema</code> - 运行时的 <code>schema</code>，当生成表和运行环境的表的 <code>schema</code> 不一样的时候可以使用该属性进行配置。</li><li><code>runtimeTableName</code> - 运行时的 <code>tableName</code>，当生成表和运行环境的表的 <code>tableName</code> 不一样的时候可以使用该属性进行配置。</li><li><code>selectAllOrderByClause</code> - 该属性值会追加到 <code>selectAll</code> 方法后的 SQL 中，会直接跟 order by 拼接后添加到 SQL 末尾。</li><li><code>useActualColumnNames</code> - 如果设置为 true,那么 MBG 会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为 false(默认值)，MGB 将会尝试将返回的名称转换为驼峰形式。 在这两种情况下，可以通过 元素显示指定，在这种情况下将会忽略这个（useActualColumnNames）属性。</li><li><code>useColumnIndexes</code> - 如果是 true，MBG 生成 <code>resultMaps</code> 的时候会使用列的索引,而不是结果中列名的顺序。</li><li><code>useCompoundPropertyNames</code> - 如果是 true,那么 MBG 生成属性名的时候会将列名和列备注接起来. 这对于那些通过第四代语言自动生成列(例如 - FLD22237),但是备注包含有用信息(例如 - “customer id”)的数据库来说很有用. 在这种情况下,MBG 会生成属性名 FLD2237_CustomerId。</li></ul><p>除了 <code>&lt;property&gt;</code> 子元素外， <code>&lt;table&gt;</code> 还包含以下子元素：</p><ul><li><code>&lt;generatedKey&gt;</code> (0 个或 1 个)</li><li><code>&lt;columnRenamingRule&gt;</code> (0 个或 1 个)</li><li><code>&lt;columnOverride&gt;</code> (0 个或多个)</li><li><code>&lt;ignoreColumn&gt;</code> (0 个或多个)</li></ul><p>下面对这 4 个元素进行详细讲解。</p><h4 id="1-8-1-generatedKey-元素"><a href="#1-8-1-generatedKey-元素" class="headerlink" title="1.8.1. generatedKey 元素"></a>1.8.1. generatedKey 元素</h4><p>这个元素最多可以配置一个。</p><p>这个元素用来指定自动生成主键的属性（identity 字段或者 sequences 序列）。如果指定这个元素，MBG 在生成 insert 的 SQL 映射文件中插入一个 <code>&lt;selectKey&gt;</code> 元素。 这个元素<strong>非常重要</strong>，这个元素包含下面两个必选属性：</p><ul><li><code>column</code> - 生成列的列名。</li><li><code>sqlStatement</code> - 将返回新值的 SQL 语句。如果这是一个 identity 列，您可以使用其中一个预定义的的特殊值。预定义值如下：<ul><li>Cloudscape</li><li>DB2</li><li>DB2_MF</li><li>Derby</li><li>HSQLDB</li><li>Informix</li><li>MySql</li><li>SqlServer</li><li>SYBASE</li><li>JDBC - 这会配置 MBG 使用 MyBatis3 支持的 JDBC 标准的生成 key 来生成代码。 这是一个独立于数据库获取标识列中的值的方法。  重要 - 只有当目标运行为 MyBatis3 时才会产生正确的代码。 如果与 iBATIS2 一起使用目标运行时会产生运行时错误的代码。这个元素还包含两个可选属性：</li></ul></li><li><code>identity</code> - 当设置为 true 时,该列会被标记为 <code>identity</code> 列， 并且 <code>&lt;selectKey&gt;</code> 元素会被插入在 insert 后面。 当设置为 false 时， <code>&lt;selectKey&gt;</code> 会插入到 insert 之前（通常是序列）。<strong>重要</strong> - 即使您 type 属性指定为 post，您仍然需要为 <code>identity</code> 列将该参数设置为 true。 这将标志 MBG 从插入列表中删除该列。默认值是 false。</li><li><code>type</code> - <code>type=post and identity=true</code> 的时候生成的 <code>&lt;selectKey&gt;</code> 中的 order=AFTER，当 type=pre 的时候，identity 只能为 false，生成的 <code>&lt;selectKey&gt;</code> 中的 order=BEFORE。可以这么理解，自动增长的列只有插入到数据库后才能得到 ID，所以是 AFTER,使用序列时，只有先获取序列之后，才能插入数据库，所以是 BEFORE。</li></ul><p>配置示例一</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user login info"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserLoginInfo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">sqlStatement</span>=<span class="string">"Mysql"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的生成的结果</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"test.model.UserLoginInfo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into `user login info` (Id, username, logindate, loginip)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;logindate,jdbcType=TIMESTAMP&#125;, #&#123;loginip,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置示例二</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user login info"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserLoginInfo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">sqlStatement</span>=<span class="string">"select SEQ_ID.nextval from dual"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的生成结果</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"test.model.UserLoginInfo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        select SEQ_ID.nextval from dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into `user login info` (Id, username, logindate, loginip)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;logindate,jdbcType=TIMESTAMP&#125;,#&#123;loginip,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-8-2-columnRenamingRule-元素"><a href="#1-8-2-columnRenamingRule-元素" class="headerlink" title="1.8.2. columnRenamingRule 元素"></a>1.8.2. columnRenamingRule 元素</h4><p>该元素最多可以配置一个，使用该元素可以在生成列之前，对列进行重命名。这对那些存在同一前缀的字段想在生成属性名时去除前缀的表非常有用。例如假设一个表包含以下的列：</p><ul><li>CUST_BUSINESS_NAME</li><li>CUST_STREET_ADDRESS</li><li>CUST_CITY</li><li>CUST_STATE</li></ul><p>生成的所有属性名中如果都包含 CUST 的前缀可能会让人不爽。这些前缀可以通过如下方式定义重命名规则:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">columnRenamingRule</span> <span class="attr">searchString</span>=<span class="string">"^CUST_"</span> <span class="attr">replaceString</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意，在内部，MBG 使用 <code>java.util.regex.Matcher.replaceAll</code> 方法实现这个功能。 请参阅有关该方法的文档和在 Java 中使用正则表达式的例子。</p><p>当 <code>&lt;columnOverride&gt;</code> 匹配一列时，这个元素（ <code>&lt;columnRenamingRule&gt;</code> ）会被忽略。 <code>&lt;columnOverride&gt;</code> 优先于重命名的规则。</p><p>该元素有一个必选属性：</p><ul><li><code>searchString</code> - 定义将被替换的字符串的正则表达式。该元素有一个可选属性：<ul><li><code>replaceString</code> - 这是一个用来替换搜索字符串列每一个匹配项的字符串。如果没有指定，就会使用空字符串。</li></ul></li></ul><p>关于 <code>&lt;table&gt;</code> 的 <code>&lt;property&gt;</code> 属性 <code>useActualColumnNames</code> 对此的影响可以查看完整文档。</p><h4 id="1-8-3-columnOverride-元素"><a href="#1-8-3-columnOverride-元素" class="headerlink" title="1.8.3. columnOverride 元素"></a>1.8.3. columnOverride 元素</h4><p>该元素可选，可以配置多个。</p><p>该元素从将某些属性默认计算的值更改为指定的值。</p><p>该元素有一个必选属性:</p><ul><li><code>column</code> - 要重写的列名。该元素有多个可选属性：<ul><li><code>property</code> - 要使用的 Java 属性的名称。如果没有指定，MBG 会根据列名生成。 例如，如果一个表的一列名为 STRT_DTE，MBG 会根据 <code>&lt;table&gt;</code> 的 useActualColumnNames 属性生成 STRT_DTE 或 strtDte。</li><li><code>javaType</code> - 该列属性值为完全限定的 Java 类型。如果需要，这可以覆盖由 JavaTypeResolver 计算出的类型。 对某些数据库来说，这是必要的用来处理<strong>“奇怪的”</strong>数据库类型（例如 MySql 的 unsigned bigint 类型需要映射为 java.lang.Object)。</li><li><code>jdbcType</code> - 该列的 JDBC 类型(INTEGER, DECIMAL, NUMERIC, VARCHAR 等等)。 如果需要，这可以覆盖由 JavaTypeResolver 计算出的类型。 对某些数据库来说，这是必要的用来处理怪异的 JDBC 驱动 (例如 DB2 的 LONGVARCHAR 类型需要为 iBATIS 映射为 VARCHAR)。</li><li><code>typeHandler</code> - 用户定义的需要用来处理这列的类型处理器。它必须是一个继承 iBATIS 的 TypeHandler 类或 TypeHandlerCallback 接口（该接口很容易继承）的全限定的类名。如果没有指定或者是空白，iBATIS 会用默认的类型处理器来处理类型。<strong>重要</strong> - MBG 不会校验这个类型处理器是否存在或者可用。 MGB 只是简单的将这个值插入到生成的 SQL 映射的配置文件中。</li><li><code>delimitedColumnName</code> - 指定是否应在生成的 SQL 的列名称上增加<strong>分隔符</strong>。 如果列的名称中包含空格，MGB 会自动添加<strong>分隔符</strong>， 所以这个重写只有当列名需要强制为一个合适的名字或者列名是数据库中的保留字时是必要的。</li></ul></li></ul><p>配置示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">schema</span>=<span class="string">"DB2ADMIN"</span> <span class="attr">tableName</span>=<span class="string">"ALLTYPES"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">"LONG_VARCHAR_FIELD"</span> <span class="attr">javaType</span>=<span class="string">"java.lang.String"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-8-4-ignoreColumn-元素"><a href="#1-8-4-ignoreColumn-元素" class="headerlink" title="1.8.4. ignoreColumn 元素"></a>1.8.4. ignoreColumn 元素</h4><p>该元素可选，可以配置多个。</p><p>该元素可以用来屏蔽不需要生成的列。</p><p>该元素有一个必选属性：</p><ul><li><code>column</code> - 要忽略的列名。该元素还有一个可选属性：<ul><li><code>delimitedColumnName</code> - 匹配列名的时候是否区分大小写。如果为 true 则区分。默认值为 false，不区分大小写。</li></ul></li></ul><h2 id="2-MyBatis-Generator-最佳实践"><a href="#2-MyBatis-Generator-最佳实践" class="headerlink" title="2. MyBatis Generator 最佳实践"></a>2. MyBatis Generator 最佳实践</h2><p>本节内容针对 MyBatis3，使用 iBATIS 的不一定适用。</p><p>以下根据个人经验（对此有意见的可以留言）对一些配置看法列出如下几点：</p><p>关于实体类的 modelType，建议使用 defaultModelType=”flat”，只有一个对象的情况下管理毕竟方便，使用也简单。<br>关于注释 <code>&lt;commentGenerator&gt;</code> ，不管你是否要重写自己的注释生成器，有一点不能忘记，那就是注释中一定要保留@mbggenerated,MBG 通过该字符串来判断代码是否为代码生成器生成的代码，有该标记的的代码在重新生成的时候会被删除，不会重复。不会在 XML 中出现重复元素。</p><p>使用 MBG 生成的代码时，建议尽可能不要去修改自动生成的代码，而且要生成带有@mbggenerated，这样才不会在每次重新生成代码的时候需要手动修改好多内容。</p><p>仍然是注释相关，在 <code>&lt;commentGenerator&gt;</code> 中，建议一定要保留 <code>suppressAllComments</code> 属性(使用默认值 false)，一定要取消(设为 true)时间戳 <code>suppressDate</code>，避免重复提交 SVN。</p><p><code>&lt;jdbcConnection&gt;</code> 建议将 JDBC 驱动放到项目的<strong>classpath</strong>下，而不是使用 <code>&lt;classPathEntry&gt;</code> 来引入 jar 包，主要考虑到所有开发人员的统一性。</p><p>当数据库字段使用 CHAR 时，建议在 <code>&lt;javaModelGenerator&gt;</code> 中设置 <code>&lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</code> ，可以自动去掉不必要的空格。</p><p>在 <code>&lt;javaClientGenerator&gt;</code> 中，建议设置 <code>type=&quot;XMLMAPPER&quot;</code>,不建议使用注解或混合模式，比较代码和 SQL 完全分离易于维护。</p><p>建议尽可能在 <code>&lt;table&gt;</code> 中配置 <code>&lt;generatedKey&gt;</code> ，避免手工操作，以便于 MBG 重复执行代码生成。</p><p>如果有其他有价值的经验，会继续补充。</p><p>综合以上信息，这里给出一个 Mysql 的简单配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MysqlContext"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"test.model"</span> <span class="attr">targetProject</span>=<span class="string">"src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"test.xml"</span>  <span class="attr">targetProject</span>=<span class="string">"src\main\resources"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"test.dao"</span>  <span class="attr">targetProject</span>=<span class="string">"src\main\java"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">sqlStatement</span>=<span class="string">"Mysql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;table&gt;</code> 这里用的通配符匹配全部的表，另外所有表都有自动增长的 id 字段。如果不是所有表的配置都一样，可以做针对性的配置。</p><h2 id="3-引用和引申"><a href="#3-引用和引申" class="headerlink" title="3. 引用和引申"></a>3. 引用和引申</h2><ul><li><a href="https://github.com/mybatis/generator" target="_blank" rel="noopener">Github</a></li><li><a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://blog.csdn.net/isea533/article/details/42102297" target="_blank" rel="noopener">MyBatis Generator 详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MyBatis-Generator-MBG-指南&quot;&gt;&lt;a href=&quot;#1-MyBatis-Generator-MBG-指南&quot; class=&quot;headerlink&quot; title=&quot;1. MyBatis Generator (MBG) 指南&quot;&gt;&lt;/a&gt;1. My
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://dunwu.github.io/2019/03/06/network/data-link-layer/"/>
    <id>https://dunwu.github.io/2019/03/06/network/data-link-layer/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><blockquote><p><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p><ul><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#简介">简介</a></li><li><a href="#基本问题">基本问题</a><ul><li><a href="#封装成帧">封装成帧</a></li><li><a href="#透明传输">透明传输</a></li><li><a href="#差错检测">差错检测</a></li></ul></li><li><a href="#点对点信道">点对点信道</a><ul><li><a href="#ppp-协议">PPP 协议</a></li></ul></li><li><a href="#广播信道">广播信道</a><ul><li><a href="#csmacd-协议">CSMA/CD 协议</a></li></ul></li><li><a href="#局域网">局域网</a></li><li><a href="#以太网">以太网</a></li><li><a href="#mac-地址">MAC 地址</a></li><li><a href="#设备">设备</a><ul><li><a href="#适配器">适配器</a></li><li><a href="#集线器">集线器</a></li><li><a href="#网桥">网桥</a></li><li><a href="#以太网交换机">以太网交换机</a></li></ul></li></ul><!-- /TOC --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>链路是从一个节点到相邻节点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（网络适配器）和软件（协议）。</li><li>数据链路层三个基本问题：封装成帧、透明传输、差错检测。</li><li>数据链路层有两种信道类型：点对点信道（主要使用 <code>PPP</code>）和广播信道（主要使用 <code>CSMA/CD</code>）。</li><li>以太网 MAC 层的地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用及使用场合。</li></ul><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>为网络层传下来的 IP 数据报添加首部和尾部，用于标记帧的开始和结束。</p><p>为了提高传输效率，应该让数据部分长度尽可能大于首部和尾部。但是，每种链路层协议都限制了帧的数据部分长度上线——最大传送单元 MTU（Maximum Transfer Unit）</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/数据链路帧.png"></div><br></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p><strong>透明</strong>表示：某一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/经过字节填充后发送的数据.png"></div><br></p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>目前数据链路层广泛使用了<a href="https://zh.wikipedia.org/wiki/循环冗余检验" target="_blank" rel="noopener"><strong>循环冗余检验 CRC（Cyclic redundancy check）</strong></a>来检查比特差错。</p><h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><p>点对点信道使用一对一的点对点通信方式。</p><p>对于点对点的链路，点对点协议 PPP（Point-to-Point Protocol）是使用最广泛的数据链路层协议。</p><h3 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h3><p>互联网用户通常都要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/PPP协议.png"></div><br></p><p>PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/PPP帧.png"></div><br></p><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p>广播信道(broadcast channel)是通过广播的方式传输信息的信息通道。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h3><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p><ul><li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</li><li><strong>碰撞检测</strong> ：即边发送边检测。若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。计算退避等待时间采用的是<a href="https://baike.baidu.com/item/二进制指数退避算法" target="_blank" rel="noopener">二进制指数退避算法</a>。</li></ul><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网 LAN（Local Area Network）是指在某一区域内由多台计算机互联成的计算机组。</p><p>局域网的拓扑结构通常为总线型和环型。</p><p>局域网技术主要有：以太网、令牌环网、FDDI 网和无线局域网等。</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网（Ethernet）是一种星型拓扑结构局域网。</p><p>以太网是目前应用最广泛的局域网。</p><p>以太网使用 CSMA/CD 协议。</p><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址（Media Access Control Address），也称为以太网地址或物理地址，它是一个用来确认网上设备位置的地址。</p><p>MAC 地址长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/MAC帧.png"></div><br></p><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>网络适配器一般指网卡。</p><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>网卡和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而网卡和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行。</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器（Hub）的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p><p>使用集线器可以在物理层扩展以太网。</p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。</p><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p><ul><li>以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。</li><li>交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</li><li>用户独占传输媒体的带宽，若一个接口到主机的带宽是 10Mbit 每秒，那么有 10 个接口的交换机的总容量是 100Mbit 每秒。这是交换机的最大优点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据链路层（Data Link Layer）&lt;/strong&gt; - 网络层
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件工程</title>
    <link href="https://dunwu.github.io/2019/03/06/software/README/"/>
    <id>https://dunwu.github.io/2019/03/06/software/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><blockquote><p>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p><p>关键词： <code>瀑布模型</code>, <code>螺旋模型</code>, <code>敏捷开发</code>, <code>极限编程</code></p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#软件工程的基本内容">软件工程的基本内容</a></li><li><a href="#软件工程的目标">软件工程的目标</a></li><li><a href="#软件工程的方法">软件工程的方法</a></li><li><a href="#软件生命周期">软件生命周期</a></li><li><a href="#软件生命周期模型">软件生命周期模型</a><ul><li><a href="#瀑布模型">瀑布模型</a></li><li><a href="#螺旋模型">螺旋模型</a></li></ul></li><li><a href="#软件工程术语">软件工程术语</a></li><li><a href="#更多内容">更多内容</a></li></ul><!-- /TOC --><h2 id="软件工程的基本内容"><a href="#软件工程的基本内容" class="headerlink" title="软件工程的基本内容"></a>软件工程的基本内容</h2><p>软件工程的七条基本原理</p><ol><li>用分阶段的生存周期计划进行严格的管理。</li><li>坚持进行阶段评审。</li><li>实行严格的产品控制。</li><li>采用现代程序设计技术。</li><li>软件工程结果应能清楚地审查。</li><li>开发小组的人员应该少而精。</li><li>承认不断改进软件工程实践的必要性。</li></ol><h2 id="软件工程的目标"><a href="#软件工程的目标" class="headerlink" title="软件工程的目标"></a>软件工程的目标</h2><ol><li><strong>适用性</strong> - 软件在不同的系统约束条件下，使用户需求得到满足的难易程度。</li><li><strong>有效性</strong> - 软件系统能最有效的利用计算机的时间和空间资源。各种软件无不把系统的时/空开销作为衡量软件质量的一项重要技术指标。很多场合，在追求时间有效性和空间有效性时会发生矛盾，这时不得不牺牲时间有效性换取空间有效性或牺牲空间有效性换取时间有效性。时/空折衷是经常采用的技巧。</li><li><strong>可修改性</strong> - 允许对系统进行修改而不增加原系统的复杂性。它支持软件的调试和维护，是一个难以达到的目标。</li><li><strong>可靠性</strong> - 能防止因概念、设计和结构等方面的不完善造成的软件系统失效，具有挽回因操作不当造成软件系统失效的能力。</li><li><strong>可理解性</strong> - 系统具有清晰的结构，能直接反映问题的需求。可理解性有助于控制系统软件复杂性，并支持软件的维护、移植或重用。</li><li><strong>可维护性</strong> - 软件交付使用后，能够对它进行修改，以改正潜伏的错误，改进性能和其它属性，使软件产品适应环境的变化等。软件维护费用在软件开发费用中占有很大的比重。可维护性是软件工程中一项十分重要的目标。</li><li><strong>可重用性</strong> - 把概念或功能相对独立的一个或一组相关模块定义为一个软部件。可组装在系统的任何位置，降低工作量。</li><li><strong>可移植性</strong> - 软件从一个计算机系统或环境搬到另一个计算机系统或环境的难易程度。</li><li><strong>可追踪性</strong> - 根据软件需求对软件设计、程序进行正向追踪，或根据软件设计、程序对软件需求的逆向追踪的能力。</li><li><strong>可互操作性</strong> - 多个软件元素相互通信并协同完成任务的能力。</li></ol><h2 id="软件工程的方法"><a href="#软件工程的方法" class="headerlink" title="软件工程的方法"></a>软件工程的方法</h2><p>著名的重量级开发方法：</p><ul><li><a href="https://zh.wikipedia.org/zh-cn/ISO_9000" target="_blank" rel="noopener">ISO9000</a> - ISO 9000 系列标准是国际标准化组织设立的标准，与品质管理系统有关。</li><li><a href="https://zh.wikipedia.org/wiki/能力成熟度模型" target="_blank" rel="noopener">能力成熟度模型（CMM）</a> - CMM 涵盖一个成熟的软件发展组织所应具备的重要功能与项目，它描述了软件发展的演进过程，从毫无章法、不成熟的软件开发阶段到成熟软件开发阶段的过程。</li><li><a href="https://zh.wikipedia.org/wiki/统一软件开发过程" target="_blank" rel="noopener">统一软件开发过程（RUP）</a> - RUP 是一种软件工程方法，为迭代式软件开发流程。</li></ul><p>著名的轻量级开发方法：</p><ul><li><a href="https://zh.wikipedia.org/wiki/敏捷软件开发" target="_blank" rel="noopener">敏捷开发（Agile Development）</a> - 是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。</li><li><a href="https://zh.wikipedia.org/wiki/极限编程" target="_blank" rel="noopener">极限编程（XP）</a> - 极限编程是敏捷软件开发中最有成效的方法学之一。极限编程技术以沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）和尊重（Respect）为价值标准。</li></ul><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><blockquote><p>软件生命周期(Software Life Cycle,SLC)是软件的产生直到报废或停止使用的生命周期。</p></blockquote><ul><li>问题定义 - 要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。</li><li>可行性研究 - 一方面在于把待开发的系统的目标以明确的语言描述出来；另一方面从经济、技术、法律等多方面进行可行性分析。</li><li>需求分析 - 弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。</li><li>开发阶段<ul><li>概要设计</li><li>详细设计</li><li>编码实现</li><li>软件测试 - 测试的过程分单元测试、组装测试以及系统测试三个阶段进行。测试的方法主要有白盒测试和黑盒测试两种。</li></ul></li><li>维护</li></ul><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/software-engineering/软件生命周期.gif"></div><br></p><h2 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><blockquote><p>瀑布模型（Waterfall Model）强调系统开发应有完整的周期，且必须完整的经历周期的每一开发阶段，并系统化的考量分析与设计的技术、时间与资源之投入等。</p></blockquote><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/software-engineering/瀑布模型.jpg"></div><br></p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>瀑布模型核心思想是按工序将问题拆分，将功能的实现与设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>为项目提供了按阶段划分的检查点。</li><li>当前一阶段完成后，您只需要去关注后续阶段。</li><li>可在迭代模型中应用瀑布模型。</li><li>它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。</li></ul><p><strong>缺点</strong></p><ul><li>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。</li><li>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。</li><li>通过过多的强制完成日期和里程碑来跟踪各个项目阶段。</li><li>瀑布模型的突出缺点是不适应用户需求的变化。</li></ul><p><strong>适用场景</strong></p><p>是否使用这一模型主要取决于是否能理解客户的需求以及在项目的进程中这些需求的变化程度。对于需求经常变化的项目，不要适用瀑布模型。</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><blockquote><p>螺旋模型基本做法是在“瀑布模型”的每一个开发阶段前引入一个非常严格的风险识别、风险分析和风险控制，它把软件项目分解成一个个小项目。每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。</p></blockquote><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/software-engineering/螺旋模型.png"></div><br></p><h4 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h4><p>螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：</p><ol><li>制定计划 - 确定软件目标，选定实施方案，弄清项目开发的限制条件；</li><li>风险分析 - 分析评估所选方案，考虑如何识别和消除风险；</li><li>实施工程 - 实施软件开发和验证；</li><li>客户评估 - 评价开发工作，提出修正建议，制定下一步计划。</li></ol><p>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>设计上的灵活性,可以在项目的各个阶段进行变更。</li><li>以小的分段来构建大型系统,使成本计算变得简单容易。</li><li>客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。</li><li>随着项目推进,客户始终掌握项目的最新信息, 从而他或她能够和管理层有效地交互。</li><li>客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品。</li></ul><p><strong>缺点</strong></p><p>很难让用户确信这种演化方法的结果是可以控制的。建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。</p><p><strong>适用场景</strong></p><p>对于新项目，需求不明确的情况下，适合用螺旋模型进行开发，便于风险控制和需求变更。</p><h2 id="软件工程术语"><a href="#软件工程术语" class="headerlink" title="软件工程术语"></a>软件工程术语</h2><ul><li><strong>里程碑（Milestone）</strong> - 在制定项目进度计划时，在进度时间表上设立一些重要的时间检查点，这样一来，就可以在项目执行过程中利用这些重要的时间检查点来对项目的进程进行检查和控制。这些重要的时间检查点被称作项目的里程碑。</li><li><strong>人月</strong> - 软件开发的工作量单位。如 200 人月，10 个人开发，那算来就是花 20 个月就可完工。</li><li><strong>基线</strong> - 基线是项目储存库中每个工件版本在特定时期的一个“快照”。它提供一个正式标准，随后的工作基于此标准，并且只有经过授权后才能变更这个标准。建立一个初始基线后，以后每次对其进行的变更都将记录为一个差值，直到建成下一个基线。</li></ul><h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul><li>《没有银弹》</li><li>《人月神话》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件工程&quot;&gt;&lt;a href=&quot;#软件工程&quot; class=&quot;headerlink&quot; title=&quot;软件工程&quot;&gt;&lt;/a&gt;软件工程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数
      
    
    </summary>
    
    
  </entry>
  
</feed>
