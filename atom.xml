<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张鹏的博客</title>
  
  <subtitle>大道至简，知易行难</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://dunwu.github.io/"/>
  <updated>2019-03-06T08:43:45.844Z</updated>
  <id>https://dunwu.github.io/</id>
  
  <author>
    <name>Zhang Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 快速入门</title>
    <link href="https://dunwu.github.io/2019/03/06/frontend/mvc/react/react/"/>
    <id>https://dunwu.github.io/2019/03/06/frontend/mvc/react/react/</id>
    <published>2019-03-06T08:38:11.317Z</published>
    <updated>2019-03-06T08:43:45.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-快速入门"><a href="#React-快速入门" class="headerlink" title="React 快速入门"></a>React 快速入门</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#安装">安装</a></li><li><a href="#introducing-jsx">Introducing JSX</a><ul><li><a href="#jsx-中嵌入表达式">JSX 中嵌入表达式</a></li><li><a href="#jsx-也是一个表达式">JSX 也是一个表达式</a></li><li><a href="#用-jsx-指定属性值">用 JSX 指定属性值</a></li><li><a href="#用-jsx-指定子元素">用 JSX 指定子元素</a></li><li><a href="#jsx-防止注入攻击">JSX 防止注入攻击</a></li><li><a href="#jsx-表示对象">JSX 表示对象</a></li></ul></li><li><a href="#渲染元素">渲染元素</a><ul><li><a href="#渲染一个元素到-dom">渲染一个元素到 DOM</a></li><li><a href="#更新已渲染的元素">更新已渲染的元素</a></li><li><a href="#react-只更新必需要更新的部分">React 只更新必需要更新的部分</a></li></ul></li><li><a href="#组件components-和-属性props">组件(Components) 和 属性(Props)</a><ul><li><a href="#函数式组件和类组件">函数式组件和类组件</a></li><li><a href="#渲染一个组件">渲染一个组件</a></li><li><a href="#构成组件">构成组件</a></li><li><a href="#提取组件">提取组件</a></li><li><a href="#props-是只读的">Props 是只读的</a></li></ul></li><li><a href="#把函数式组件转化为类组件">把函数式组件转化为类组件</a></li><li><a href="#在类组件中添加本地状态state">在类组件中添加本地状态(state)</a></li><li><a href="#在类中添加生命周期方法">在类中添加生命周期方法</a></li><li><a href="#正确地使用-state状态">正确地使用 State(状态)</a><ul><li><a href="#不要直接修改-state状态">不要直接修改 state(状态)</a></li><li><a href="#state状态-更新可能是异步的">state(状态) 更新可能是异步的</a></li><li><a href="#state状态更新会被合并">state(状态)更新会被合并</a></li></ul></li><li><a href="#数据向下流动">数据向下流动</a><ul><li><a href="#元素变量">元素变量</a></li><li><a href="#使用逻辑--操作符的内联-if-用法">使用逻辑 &amp;&amp; 操作符的内联 if 用法</a></li><li><a href="#使用条件操作符的内联-if-else">使用条件操作符的内联 If-Else</a></li><li><a href="#防止组件渲染">防止组件渲染</a></li><li><a href="#多组件渲染">多组件渲染</a></li><li><a href="#基本列表组件">基本列表组件</a></li></ul></li><li><a href="#键keys">键(Keys)</a><ul><li><a href="#使用-keys-提取组件">使用 keys 提取组件</a></li><li><a href="#keys-在同辈元素中必须是唯一的">keys 在同辈元素中必须是唯一的</a></li><li><a href="#在-jsx-中嵌入-map">在 JSX 中嵌入 map()</a></li></ul></li><li><a href="#受控组件controlled-components">受控组件(Controlled Components)</a></li><li><a href="#textare-标签">textare 标签</a></li><li><a href="#select-标签">select 标签</a></li><li><a href="#处理多个输入元素">处理多个输入元素</a></li><li><a href="#受控组件的替代方案">受控组件的替代方案</a></li><li><a href="#添加第二个输入">添加第二个输入</a></li><li><a href="#编写转换函数">编写转换函数</a></li><li><a href="#状态提升lifting-state-up">状态提升(Lifting State Up)</a></li><li><a href="#经验总结">经验总结</a></li><li><a href="#包含">包含</a></li><li><a href="#特例">特例</a></li><li><a href="#如何看待">如何看待？</a></li></ul><!-- /TOC --><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>直接下载使用</li></ol><p>React 可以直接下载使用，下载包中也提供了很多学习的实例。</p><p>你可以在官网  <a href="http://facebook.github.io/react/" target="_blank" rel="noopener">http://facebook.github.io/react/</a>  下载最新版。</p><ol start="2"><li>通过 npm 使用 React</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -S react react-dom</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 yarn 使用 React</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add react react-dom</span><br></pre></td></tr></table></figure><ol start="4"><li><p>使用各种快速构建工具</p><p>目前最流行的构建工具应该是 create-react-app，它使得用户可以通过命令就能快速构建 React 开发环境。</p><p>create-react-app 自动创建的项目是基于 Webpack + ES6 。</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br><span class="line">$ create-react-app my-app</span><br><span class="line">$ <span class="built_in">cd</span> my-app/</span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><h2 id="Introducing-JSX"><a href="#Introducing-JSX" class="headerlink" title="Introducing JSX"></a>Introducing JSX</h2><p>考虑一下这个变量的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>这种有趣的标签语法既不是字符串也不是 HTML。</p><p>这就是 JSX ，他是 JavaScrip 的一种扩展语法。我们推荐在 React 中使用这种语法来描述 UI 信息。JSX 可能会让你想起某种模板语言，但是它具有 JavaScrip 的全部能力。</p><p>JSX 可以生成 React “元素”。我们将在<a href="http://www.css88.com/react/docs/rendering-elements.html" target="_blank" rel="noopener">下一章</a>探索如何把它渲染到 DOM 上。下面你可以找到 JSX 的基础知识，以帮助您开始使用。</p><h3 id="JSX-中嵌入表达式"><a href="#JSX-中嵌入表达式" class="headerlink" title="JSX 中嵌入表达式"></a>JSX 中嵌入表达式</h3><p>你可以用 花括号 把任意的  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript 表达式</a>  嵌入到 JSX 中。</p><p>例如，<code>2 + 2</code>， <code>user.firstName</code>， 和  <code>formatName(user)</code>，这些都是可用的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function formatName(user) &#123;</span><br><span class="line">  return user.firstName + &apos; &apos; + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  firstName: &apos;Harper&apos;,</span><br><span class="line">  lastName: &apos;Perez&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/PGEjdG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>为便于阅读，我们将 JSX 分割成多行。我们推荐使用括号将 JSX 包裹起来，虽然这不是必须的，但这样做可以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">分号自动插入</a>的陷阱。</p><h3 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h3><p>编译之后，JSX 表达式就变成了常规的 JavaScript 对象。</p><p>这意味着你可以在  <code>if</code>  语句或者是  <code>for</code>  循环中使用 JSX，用它给变量赋值，当做参数接收，或者作为函数的返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getGreeting(user) &#123;</span><br><span class="line">  if (user) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-JSX-指定属性值"><a href="#用-JSX-指定属性值" class="headerlink" title="用 JSX 指定属性值"></a>用 JSX 指定属性值</h3><p>您可以使用双引号来指定字符串字面量作为属性值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure><p>您也可以用花括号嵌入一个 JavaScript 表达式作为属性值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure><p>在属性中嵌入 JavaScript 表达式时，不要使用引号来包裹大括号。否则，JSX 将该属性视为字符串字面量而不是表达式。对于字符串值你应该使用引号，对于表达式你应该使用大括号，但两者不能同时用于同一属性。</p><h3 id="用-JSX-指定子元素"><a href="#用-JSX-指定子元素" class="headerlink" title="用 JSX 指定子元素"></a>用 JSX 指定子元素</h3><p>如果是空标签，您应该像 XML 一样，使用  <code>/&gt;</code>立即闭合它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</span><br></pre></td></tr></table></figure><p>JSX 标签可能包含子元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p><strong>警告：</strong></p><p>比起 HTML ， JSX 更接近于 JavaScript ， 所以 React DOM 使用驼峰(<code>camelCase</code>)属性命名约定, 而不是 HTML 属性名称。</p><p>例如，<code>class</code>  在 JSX 中变为<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className" target="_blank" rel="noopener"><code>className</code></a>，<code>tabindex</code>  变为  <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex" target="_blank" rel="noopener"><code>tabIndex</code></a>。</p></blockquote><h3 id="JSX-防止注入攻击"><a href="#JSX-防止注入攻击" class="headerlink" title="JSX 防止注入攻击"></a>JSX 防止注入攻击</h3><p>在 JSX 中嵌入用户输入是安全的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const title = response.potentiallyMaliciousInput;</span><br><span class="line">// This is safe:</span><br><span class="line">const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>默认情况下， 在渲染之前, React DOM 会格式化(<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a>) JSX 中的所有值. 从而保证用户无法注入任何应用之外的代码. 在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免  <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站脚本)</a>  攻击。</p><h3 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h3><p>Babel 将 JSX 编译成  <code>React.createElement()</code>  调用。</p><p>下面的两个例子是是完全相同的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>React.createElement()</code>  会执行一些检查来帮助你编写没有 bug 的代码，但基本上它会创建一个如下所示的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注意: 这是简化的结构</span><br><span class="line">const element = &#123;</span><br><span class="line">  type: &apos;h1&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;greeting&apos;,</span><br><span class="line">    children: &apos;Hello, world&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些对象被称作“React 元素”。你可以把他们想象成为你想在屏幕上显示内容的一种描述。React 会读取这些对象，用他们来构建 DOM，并且保持它们的不断更新。</p><p>我们将在下一节中来探索如何将 React 元素渲染到 DOM 上。</p><blockquote><p><strong>提示:</strong></p><p>我们建议你去搜一下你用的编辑器的 “Babel” 语法方案, 以便 ES6 和 JSX 代码都能够被正确高亮的显示。</p></blockquote><h2 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h2><p>元素(Elements)是 React 应用中最小的建造部件（或者说构建块，building blocks）。</p><p>一个元素用于描述你在将在屏幕上看到的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>不同于浏览器的 DOM 元素， React 元素是普通的对象，非常容易创建。React DOM 会负责更新 DOM ，以匹配 React 元素（愚人码头注：DOM 元素与 React 元素保持一致）。</p><blockquote><p><strong>注意：</strong></p><p>有人可能会将元素与更广为人知的 “组件(Components)” 概念相混淆。我们将在<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">下一节</a>介绍组件。元素是构成组件的”材料”， 所以我们建议你看完本节再进入下一节。</p></blockquote><h3 id="渲染一个元素到-DOM"><a href="#渲染一个元素到-DOM" class="headerlink" title="渲染一个元素到 DOM"></a>渲染一个元素到 DOM</h3><p>我们假设你的 HTML 文件中的什么地方有这么一个<code></code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们称这个是一个 “根” DOM 节点，因为该节点内的所有内容都由 React DOM 管理。</p><p>单纯用 React 构建的应用程序通常只有一个单独的 根 DOM 节点。但如果你要把 React 整合进现有的 app 中 ，那你可能会有多个相互独立的根 DOM 节点。</p><p>要渲染一个 React 元素到一个 根 DOM 节点，吧它们传递给  <code>ReactDOM.render()</code>  方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/rrpgNB?editors=1010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>上面代码会在页面上显示 “Hello, world” 。</p><h3 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h3><p>React 元素是  <a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可突变（immutable）</a>  的. 一旦你创建了一个元素, 就不能再修改其子元素或任何属性。一个元素就像电影里的一帧: 它表示在某一特定时间点的 UI 。</p><p>就我们所知, 更新 UI 的唯一方法是创建一个新的元素, 并将其传入<code>ReactDOM.render()</code>方法.</p><p>思考以下时钟例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function tick() &#123;</span><br><span class="line">  const element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>以上代码每隔 1 秒, 就会通过  <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener"><code>setInterval()</code></a>  回调  <code>ReactDOM.render()</code>  方法来重新渲染元素。</p><blockquote><p><strong>注意：</strong></p><p>实际上，大多数 React 应用只会调用  <code>ReactDOM.render()</code>  一次。在接下来的章节中，我们将学习如何将这些代码封装到<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">有状态的组件中</a>。</p><p>我们建议您不要跳过任何一节，因为每一节之间都是彼此有联系的。</p></blockquote><h3 id="React-只更新必需要更新的部分"><a href="#React-只更新必需要更新的部分" class="headerlink" title="React 只更新必需要更新的部分"></a>React 只更新必需要更新的部分</h3><p>React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。</p><p>你可以用浏览器工具对  <a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">上一个例子</a>  进行检查来验证这一点:</p><p><br><div align="center"><img src="http://www.css88.com/react/img/docs/granular-dom-updates.gif"></div><br></p><p>即使我们我们每隔 1 秒都重建了整个元素, 但实际上 React DOM 只更新了修改过的文本节点.</p><p>在我们的经验中, 关注每个时间点 UI 的表现, 而不是关注随着时间不断更新 UI 的状态, 可以减少很多奇怪的 bug 。</p><h2 id="组件-Components-和-属性-Props"><a href="#组件-Components-和-属性-Props" class="headerlink" title="组件(Components) 和 属性(Props)"></a>组件(Components) 和 属性(Props)</h2><p>组件使你可以将 UI 划分为一个一个独立，可复用的小部件，并可以对每个部件进行单独的设计。</p><p>从定义上来说， 组件就像 JavaScript 的函数。组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容。</p><blockquote><p>愚人码头注：Props ， 即属性(Property)， 在代码中写作 props ， 故可用 props 指代 properties .</p></blockquote><h3 id="函数式组件和类组件"><a href="#函数式组件和类组件" class="headerlink" title="函数式组件和类组件"></a>函数式组件和类组件</h3><p>最简单的定义组件的方法是写一个 JavaScript 函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是一个合法的 React 组件，因为它接收一个  <code>props</code>  参数, 并返回一个 React 元素。 我们把此类组件称为”函数式(Functional)”组件， 因为从字面上看来它就是一个 JavaScript 函数。</p><p>你也可以用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 的 class</a>  来定义一个组件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个组件从 React 的角度来看是等效的。</p><p>类组件有一些额外的特性，我们将在<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一节</a>讨论。在此之前, 我们先用函数式组件，因为它们更加简洁。</p><h3 id="渲染一个组件"><a href="#渲染一个组件" class="headerlink" title="渲染一个组件"></a>渲染一个组件</h3><p>在前面, 我们只遇到代表 DOM 标签的 React 元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;div /&gt;;</span><br></pre></td></tr></table></figure><p>然而，元素也可以代表用户定义的组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</span><br></pre></td></tr></table></figure><p>当 React 遇到一个代表用户定义组件的元素时，它将 JSX 属性以一个单独对象的形式传递给相应的组件。 我们将其称为 “props” 对象。</p><p>比如, 以下代码在页面上渲染 “Hello, Sara” ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/YGYmEG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>我们简单扼要重述一下上面这个例子:</p><ol><li>我们调用了  <code>ReactDOM.render()</code>  方法并向其中传入了  <code></code>  元素。</li><li>React 调用  <code>Welcome</code>  组件，并向其中传入了  <code>{name: &#39;Sara&#39;}</code>  作为 props 对象。</li><li><code>Welcome</code>  组件返回  <code>Hello, Sara</code>。</li><li>React DOM 迅速更新 DOM ，使其显示为  <code>Hello, Sara</code>。</li></ol><blockquote><p><strong>警告：</strong></p><p>组件名称总是以大写字母开始。</p><p>举例来说, <code>代表一个 DOM 标签，而</code>  则代表一个组件，并且需要在作用域中有一个  <code>Welcome</code>  组件。</p></blockquote><h3 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h3><p>组件可以在它们的输出中引用其它组件。这使得我们可以使用同样的组件来抽象到任意层级。一个按钮，一个表单，一个对话框，一个屏幕：在 React 应用中，所有这些都通常描述为组件。</p><p>例如，我们可以创建一个  <code>App</code>  组件，并在其内部多次渲染  <code>Welcome</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=&quot;Sara&quot; /&gt;</span><br><span class="line">      &lt;Welcome name=&quot;Cahal&quot; /&gt;</span><br><span class="line">      &lt;Welcome name=&quot;Edite&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/KgQKPr?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>通常，新的 React apps 都有一个单独的顶层  <code>App</code>  组件。然而，如果你在已有的应用中整合 React，你可以需要由下至上地, 从类似于  <code>Button</code>  这样的小组件开始, 逐渐整合到视图层的顶层。</p><blockquote><p><strong>警告：</strong></p><p>组件必须返回一个单独的根元素。这就是为什么我们添加一个  <code>来包含所有</code>  元素的原因。</p></blockquote><h3 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h3><p>不要害怕把一个组件分为多个更小的组件。</p><p>举个例子，思考下名  <code>Comment</code>  组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;Comment&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;UserInfo&quot;&gt;</span><br><span class="line">        &lt;img className=&quot;Avatar&quot;</span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=&quot;UserInfo-name&quot;&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-text&quot;&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-date&quot;&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/VKQwEo?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>它接受  <code>author</code>（一个对象），<code>text</code>（一个字符串）和  <code>date</code>（一个日期）作为 props，并用于在某社交网站中描述一条评论。</p><p>这个组件修改起来很麻烦，因为它是被嵌套的，而且很难复用其中的某个部分。让我们从其中提取一些组件。</p><p>首先，提取头像  <code>Avatar</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img className=&quot;Avatar&quot;</span><br><span class="line">      src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">      alt=&#123;props.user.name&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Avatar</code>  组件不用关心它在  <code>Comment</code>  中是如何渲染的。这是为什么我们它的 prop 一个更通用的属性名: <code>user</code>, 而不是  <code>author</code>  的原因。</p><p>我们建议从组件本身的角度来命名 props 而不是它被使用的上下文环境。</p><p>我们可以稍微简化一下  <code>Comment</code>  组件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;Comment&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;UserInfo&quot;&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;UserInfo-name&quot;&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-text&quot;&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-date&quot;&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们提取用户信息  <code>UserInfo</code>  组件， 用于将  <code>Avatar</code>  显示在用户名旁边：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function UserInfo(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;UserInfo&quot;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=&quot;UserInfo-name&quot;&gt;</span><br><span class="line">        &#123;props.user.name&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使我们可以进一步简化  <code>Comment</code>  组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;Comment&quot;&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-text&quot;&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-date&quot;&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/rrJNJY?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>提取组件可能看起来是一个繁琐的工作，但是在大型的 Apps 中可以回报给我们的是大量的可复用组件。一个好的经验准则是如果你 UI 的一部分需要用多次 (<code>Button</code>，<code>Panel</code>，<code>Avatar</code>)，或者本身足够复杂(<code>App</code>，<code>FeedStory</code>，<code>Comment</code>)，最好的做法是使其成为可复用组件。</p><h3 id="Props-是只读的"><a href="#Props-是只读的" class="headerlink" title="Props 是只读的"></a>Props 是只读的</h3><p>无论你用<a href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">函数或类</a>的方法来声明组件, 它都无法修改其自身 props. 思考下列  <code>sum</code> (求和)函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种函数称为  <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“纯函数”</a> ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。</p><p>反之， 以下是非纯函数， 因为它改变了自身的输入值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(account, amount) &#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 React 很灵活，但是它有一条严格的规则：</p><p><strong>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</strong></p><p>当然， 应用 UI 总是动态的，并且随时有可以改变。 所以在<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一节</a>, 我们会介绍一个新的概念<code>state</code>(状态) 。<code>state</code>  允许 React 组件在不违反上述规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。</p><h1 id="状态-State-和生命周期"><a href="#状态-State-和生命周期" class="headerlink" title="状态(State) 和生命周期"></a>状态(State) 和生命周期</h1><p>思考<a href="http://www.css88.com/react/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">前面章节</a>中提到过的时钟例子.</p><p>目前为止我们只学了一种更新 UI 的方式。</p><p>我们通过调  <code>ReactDOM.render()</code>  方法来更新渲染的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function tick() &#123;</span><br><span class="line">  const element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在本节中，我们将学习如何使  <code>Clock</code>  组件变得真正可复用 和 封装的更好。它将设置自己的计时器，并在每秒更新自身。</p><p>我们可以从封装时钟开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Clock(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tick() &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;new Date()&#125; /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/dpdoYR?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>然而，它没有满足一个关键的要求：<code>Clock</code>  设置定时器并每秒更新 UI ，事实上应该是  <code>Clock</code>自身实现的一部分。</p><p>理想情况下，我们应该只引用一个  <code>Clock</code> , 然后让它自动计时并更新:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>要实现这点，我们需要添加  <code>state</code>  到  <code>Clock</code>  组件。</p><p><code>state</code>  和  <code>props</code>  类似，但是它是私有的，并且由组件本身完全控制。</p><p>我们<a href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">之前提到过</a>, 用类定义的组件有一些额外的特性。 这个”类专有的特性”， 指的就是局部状态。</p><h2 id="把函数式组件转化为类组件"><a href="#把函数式组件转化为类组件" class="headerlink" title="把函数式组件转化为类组件"></a>把函数式组件转化为类组件</h2><p>你可以遵从以下 5 步, 把一个类似  <code>Clock</code>  这样的函数式组件转化为类组件：</p><ol><li>创建一个继承自  <code>React.Component</code>  类的  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>  同名类。</li><li>添加一个名为  <code>render()</code>  的空方法。</li><li>把原函数中的所有内容移至  <code>render()</code>  中。</li><li>在  <code>render()</code>  方法中使用  <code>this.props</code>  替代  <code>props</code>。</li><li>删除保留的空函数声明。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/zKRGpo?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p><code>Clock</code>  现在被定为类组件，而不是函数式组件。</p><p>类允许我们在其中添加本地状态(state)和生命周期钩子。</p><h2 id="在类组件中添加本地状态-state"><a href="#在类组件中添加本地状态-state" class="headerlink" title="在类组件中添加本地状态(state)"></a>在类组件中添加本地状态(state)</h2><p>我们现在通过以下 3 步, 把<code>date</code>从属性(<code>props</code>) 改为 状态(<code>state</code>)：</p><p>We will move the <code>date</code> from props to state in three steps:</p><ol><li>替换  <code>render()</code>  方法中的  <code>this.props.date</code>  为  <code>this.state.date</code>：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor" target="_blank" rel="noopener">类构造函数(class constructor)</a>  初始化  <code>this.state</code>:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们如何将  <code>props</code>  传递给基础构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;date: new Date()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件应始终使用  <code>props</code>  调用基础构造函数。</p><ol start="3"><li>移除  <code></code>  元素中的  <code>date</code>  属性：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们稍后再把 计时器代码 添加到组件内部。</p><p>现有的结果是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>接下来，我们将使  <code>Clock</code>  设置自己的计时器，并每秒更新一次。</p><h2 id="在类中添加生命周期方法"><a href="#在类中添加生命周期方法" class="headerlink" title="在类中添加生命周期方法"></a>在类中添加生命周期方法</h2><p>在一个具有许多组件的应用程序中，在组件被销毁时释放所占用的资源是非常重要的。</p><p>当  <code>Clock</code>  第一次渲染到 DOM 时，我们要<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">设置一个定时器</a> 。 这在 React 中称为 “挂载(mounting)” 。</p><p>当  <code>Clock</code>  产生的 DOM 被销毁时，我们也想<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">清除该计时器</a>。 这在 React 中称为 “卸载(unmounting)” 。</p><p>当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来运行一些代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法称为 “生命周期钩子”。</p><p><code>componentDidMount()</code>  钩子在组件输出被渲染到 DOM 之后运行。这是设置时钟的不错的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.timerID = setInterval(</span><br><span class="line">    () =&gt; this.tick(),</span><br><span class="line">    1000</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们把计时器 ID 直接存在  <code>this</code>  中。</p><p><code>this.props</code>  由 React 本身设定, 而  <code>this.state</code>  具有特殊的含义，但如果需要存储一些不用于视觉输出的内容，则可以手动向类中添加额外的字段。</p><p>如果在  <code>render()</code>  方法中没有被引用, 它不应该出现在 state 中。</p><p>我们在<code>componentWillUnmount()</code>生命周期钩子中取消这个计时器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(this.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们将会实现每秒运行的  <code>tick()</code>  方法。</p><p>它将使用  <code>this.setState()</code>  来来周期性地更新组件本地状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.timerID = setInterval(</span><br><span class="line">      () =&gt; this.tick(),</span><br><span class="line">      1000</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(this.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      date: new Date()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>现在这个时钟每秒都会走了。</p><p>我们来快速回顾一下该过程，以及调用方法的顺序：</p><ol><li>当  <code></code>  被传入  <code>ReactDOM.render()</code>  时, React 会调用  <code>Clock</code>组件的构造函数。 因为<code>Clock</code>  要显示的是当前时间，所以它将使用包含当前时间的对象来初始化  <code>this.state</code>。我们稍后会更新此状态。</li><li>然后 React 调用了  <code>Clock</code>  组件的  <code>render()</code>  方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配  <code>Clock</code>  的渲染输出。</li><li>当  <code>Clock</code>  输出被插入到 DOM 中时，React 调用  <code>componentDidMount()</code>  生命周期钩子。在该方法中，<code>Clock</code>  组件请求浏览器设置一个定时器来一次调用  <code>tick()</code>。</li><li>浏览器会每隔一秒调用一次  <code>tick()</code>方法。在该方法中， <code>Clock</code>  组件通过  <code>setState()</code>  方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过  <code>setState()</code>, React 得知了组件  <code>state</code>(状态)的变化, 随即再次调用  <code>render()</code>  方法，获取了当前应该显示的内容。 这次，<code>render()</code>  方法中的  <code>this.state.date</code>  的值已经发生了改变， 从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。</li><li>如果通过其他操作将  <code>Clock</code>  组件从 DOM 中移除了, React 会调用<code>componentWillUnmount()</code>  生命周期钩子, 所以计时器也会被停止。</li></ol><h2 id="正确地使用-State-状态"><a href="#正确地使用-State-状态" class="headerlink" title="正确地使用 State(状态)"></a>正确地使用 State(状态)</h2><p>关于  <code>setState()</code>  有三件事是你应该知道的。</p><h3 id="不要直接修改-state-状态"><a href="#不要直接修改-state-状态" class="headerlink" title="不要直接修改 state(状态)"></a>不要直接修改 state(状态)</h3><p>例如，这样将不会重新渲染一个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 错误</span><br><span class="line">this.state.comment = &apos;Hello&apos;;</span><br></pre></td></tr></table></figure><p>用  <code>setState()</code>  代替：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">this.setState(&#123;comment: &apos;Hello&apos;&#125;);</span><br></pre></td></tr></table></figure><p>唯一可以分配  <code>this.state</code>  的地方是构造函数。</p><h3 id="state-状态-更新可能是异步的"><a href="#state-状态-更新可能是异步的" class="headerlink" title="state(状态) 更新可能是异步的"></a>state(状态) 更新可能是异步的</h3><p>React 为了优化性能，有可能会将多个  <code>setState()</code>  调用合并为一次更新。</p><p>因为  <code>this.props</code>  和  <code>this.state</code>  可能是异步更新的，你不能依赖他们的值计算下一个 state(状态)。</p><p>例如, 以下代码可能导致  <code>counter</code>(计数器)更新失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 错误</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要解决这个问题，应该使用第 2 种  <code>setState()</code>  的格式，它接收一个函数，而不是一个对象。该函数接收前一个状态值作为第 1 个参数， 并将更新后的值作为第 21 个参数:</p><p>要弥补这个问题，使用另一种 setState() 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">this.setState((prevState, props) =&gt; (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>我们在上面使用了一个<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，但是也可以使用一个常规的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">this.setState(function(prevState, props) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="state-状态-更新会被合并"><a href="#state-状态-更新会被合并" class="headerlink" title="state(状态)更新会被合并"></a>state(状态)更新会被合并</h3><p>当你调用  <code>setState()</code>， React 将合并你提供的对象到当前的状态中。</p><p>例如，你的状态可能包含几个独立的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过调用独立的  <code>setState()</code>  调用分别更新它们:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchPosts().then(response =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      posts: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchComments().then(response =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      comments: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并是浅合并，所以  <code>this.setState({comments})</code>  不会改变  <code>this.state.posts</code>  的值，但会完全替换<code>this.state.comments</code>  的值。</p><h2 id="数据向下流动"><a href="#数据向下流动" class="headerlink" title="数据向下流动"></a>数据向下流动</h2><p>无论作为父组件还是子组件，它都无法获悉一个组件是否有状态，同时也不需要关心另一个组件是定义为函数组件还是类组件。</p><p>这就是 state(状态) 经常被称为 本地状态 或 封装状态的原因。 它不能被拥有并设置它的组件 以外的任何组件访问。</p><p>一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>同样适用于用户定义组件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;this.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure><p><code>FormattedDate</code>  组件通过 props(属性) 接收了  <code>date</code>  的值，但它仍然不能获知该值是来自于<code>Clock</code>的 state(状态) ，还是  <code>Clock</code>  的 props(属性)，或者是直接手动创建的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function FormattedDate(props) &#123;</span><br><span class="line">  return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/zKRqNB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这通常称为一个“从上到下”，或者“单向”的数据流。任何 state(状态) 始终由某个特定组件所有，并且从该 state(状态) 导出的任何数据 或 UI 只能影响树中 “下方” 的组件。</p><p>如果把组件树想像为 props(属性) 的瀑布，所有组件的 state(状态) 就如同一个额外的水源汇入主流，且只能随着主流的方向向下流动。</p><p>要证明所有组件都是完全独立的， 我们可以创建一个  <code>App</code>  组件，并在其中渲染 3 个<code></code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>每个  <code>Clock</code>  都设置它自己的计时器并独立更新。</p><p>在 React 应用中，一个组件是否是有状态或者无状态的，被认为是组件的一个实现细节，随着时间推移可能发生改变。你可以在有状态的组件中使用无状态组件，反之亦然。</p><p>通过 React 元素处理事件跟在 DOM 元素上处理事件非常相似。但是有一些语法上的区别：</p><ul><li>React 事件使用驼峰命名，而不是全部小写。</li><li>通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。</li></ul><p>例如，HTML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;activateLasers()&quot;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>在 React 中略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>另一个区别是，在 React 中你不能通过返回  <code>false</code>（愚人码头注：即  <code>return false;</code>  语句） 来阻止默认行为。必须明确调用  <code>preventDefault</code> 。例如，对于纯 HTML ，要阻止链接打开一个新页面的默认行为，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot; onclick=&quot;console.log(&apos;The link was clicked.&apos;); return false&quot;&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>在 React 中, 应该这么写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">  function handleClick(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&apos;The link was clicked.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里， e 是一个合成的事件。 React 根据  <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>  定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。查看  <a href="http://www.css88.com/react/docs/events.html" target="_blank" rel="noopener"><code>SyntheticEvent</code></a>  参考指南了解更多。</p><p>当使用 React 时，你一般不需要调用  <code>addEventListener</code>  在 DOM 元素被创建后添加事件监听器。相反，只要当元素被初始渲染的时候提供一个监听器就可以了。</p><p>当使用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 类</a>  定义一个组件时，通常的一个事件处理程序是类上的一个方法。例如，<code>Toggle</code>  组件渲染一个按钮，让用户在 “ON” 和 “OFF” 状态之间切换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">    // 这个绑定是必要的，使`this`在回调中起作用</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(prevState =&gt; (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/xEmzGg?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在 JSX 回调中你必须注意  <code>this</code>  的指向。 在 JavaScript 中，类方法默认没有  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">绑定</a>  的。如果你忘记绑定  <code>this.handleClick</code>  并将其传递给<code>onClick</code>，那么在直接调用该函数时，<code>this</code>  会是<code>undefined</code> 。</p><p>这不是 React 特有的行为；这是  <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/" target="_blank" rel="noopener">JavaScript 中的函数如何工作</a>的一部分。 一般情况下，如果你引用一个后面没跟  <code>()</code>  的方法，例如  <code>onClick={this.handleClick}</code> ，那你就应该 绑定(bind) 该方法。</p><p>如果调用  <code>bind</code>  令你烦恼，有两种方法可以解决这个问题。 如果您使用实验性的  <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">属性初始化语法</a> ，那么你可以使用属性初始值设置来正确地 绑定(bind) 回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  // 这个语法确保 `this` 绑定在 handleClick 中。</span><br><span class="line">  // 警告：这是 *实验性的* 语法。</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(&apos;this is:&apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语法在  <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">创建 React App</a>  中是默认开启的。</p><p>如果你没有使用属性初始化语法，可以在回调中使用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;this is:&apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 这个语法确保 `this` 被绑定在 handleClick 中</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语法的问题是，每次  <code>LoggingButton</code>  渲染时都创建一个不同的回调。在多数情况下，没什么问题。然而，如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们通常建议在构造函数中进行绑定，以避免这类性能问题。</p><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p>在 React 中，你可以创建不同的组件封装你所需要的行为。然后，只渲染它们之中的一些，取决于你的应用的状态。</p><p>React 中的条件渲染就和在 JavaScript 中的条件语句一样。使用 JavaScript 操作符如  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" target="_blank" rel="noopener"><code>if</code></a>  或者<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener">条件操作符</a>来创建渲染当前状态的元素，并且让 React 更新匹配的 UI 。</p><p>思考以下两个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function UserGreeting(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Welcome back!&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function GuestGreeting(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Please sign up.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要创建一个  <code>Greeting</code>  组件, 用来根据用户是否登录, 判断并显示上述两个组件之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Greeting(props) &#123;</span><br><span class="line">  const isLoggedIn = props.isLoggedIn;</span><br><span class="line">  if (isLoggedIn) &#123;</span><br><span class="line">    return &lt;UserGreeting /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;GuestGreeting /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  // 修改为 isLoggedIn=&#123;true&#125; 试试:</span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/ZpVxNq?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这个例子根据  <code>isLoggedIn</code> prop 渲染了不同的问候语 。</p><h3 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h3><p>你可以用变量来存储元素。这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。</p><p>思考以下两个新组件，分别用于显示登出和登入按钮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function LoginButton(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      Login</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function LogoutButton(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      Logout</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来的例子中，我们将会创建一个<a href="http://www.css88.com/react/docs/state-and-lifecycle.html#adding-local-state-to-a-class" target="_blank" rel="noopener">有状态组件</a>，叫做  <code>LoginControl</code> 。</p><p>它将渲染  <code>或者</code> ，取决于当前状态。同时渲染前面提到的<code></code>  组件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class LoginControl extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleLoginClick = this.handleLoginClick.bind(this);</span><br><span class="line">    this.handleLogoutClick = this.handleLogoutClick.bind(this);</span><br><span class="line">    this.state = &#123;isLoggedIn: false&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    this.setState(&#123;isLoggedIn: true&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    this.setState(&#123;isLoggedIn: false&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const isLoggedIn = this.state.isLoggedIn;</span><br><span class="line"></span><br><span class="line">    let button = null;</span><br><span class="line">    if (isLoggedIn) &#123;</span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;LoginControl /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/QKzAgB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>虽然声明一个变量并使用一个  <code>if</code>  语句是一个有条件地渲染组件的好方法，有时你可能想要使用一个更简短的语法。在 JSX 中有几种内联条件的方法，如下所述。</p><h3 id="使用逻辑-amp-amp-操作符的内联-if-用法"><a href="#使用逻辑-amp-amp-操作符的内联-if-用法" class="headerlink" title="使用逻辑 &amp;&amp; 操作符的内联 if 用法"></a>使用逻辑 &amp;&amp; 操作符的内联 if 用法</h3><p>您可以  <a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">在 JSX 中嵌入任何表达式</a> ，方法是将其包裹在花括号中。这也包括 JavaScript 逻辑<code>&amp;&amp;</code>  运算符。 它有助于有条件地包含一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Mailbox(props) &#123;</span><br><span class="line">  const unreadMessages = props.unreadMessages;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/ozJddz?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>它可以正常运行，因为在 JavaScript 中， <code>true &amp;&amp; expression</code>  总是会评估为  <code>expression</code> ，而<code>false &amp;&amp; expression</code>  总是执行为  <code>false</code> 。</p><p>因此，如果条件为  <code>true</code> ，则  <code>&amp;&amp;</code>  后面的元素将显示在输出中。 如果是  <code>false</code>，React 将会忽略并跳过它。</p><h3 id="使用条件操作符的内联-If-Else"><a href="#使用条件操作符的内联-If-Else" class="headerlink" title="使用条件操作符的内联 If-Else"></a>使用条件操作符的内联 If-Else</h3><p>另一个用于条件渲染元素的内联方法是使用 JavaScript 的条件操作符  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener"><code>condition ? true : false</code></a> 。</p><p>在下面这个例子中，我们使用它来进行条件渲染一个小的文本块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  const isLoggedIn = this.state.isLoggedIn;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user is &lt;b&gt;&#123;isLoggedIn ? &apos;currently&apos; : &apos;not&apos;&#125;&lt;/b&gt; logged in.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也可以用于更大的表达式，虽然不太明显发生了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  const isLoggedIn = this.state.isLoggedIn;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像 JavaScript 一样，你可以根据你和你的团队认为更易于阅读的方式选择合适的风格。还要记住，无论何时何地，当条件变得太复杂时，可能是<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取组件</a>的好时机。</p><h3 id="防止组件渲染"><a href="#防止组件渲染" class="headerlink" title="防止组件渲染"></a>防止组件渲染</h3><p>在极少数情况下，您可能希望组件隐藏自身，即使它是由另一个组件渲染的。为此，返回<code>null</code>  而不是其渲染输出。</p><p>在下面的例子中，根据名为<code>warn</code>的 prop 值，呈现  <code></code> 。如果 prop 值为  <code>false</code>，则该组件不渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function WarningBanner(props) &#123;</span><br><span class="line">  if (!props.warn) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showWarning: true&#125;</span><br><span class="line">    this.handleToggleClick = this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(prevState =&gt; (&#123;</span><br><span class="line">      showWarning: !prevState.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.showWarning ? &apos;Hide&apos; : &apos;Show&apos;&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/Xjoqwm?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>从组件的  <code>render</code>  方法返回  <code>null</code>  不会影响组件生命周期方法的触发。 例如，<code>componentWillUpdate</code>  和  <code>componentDidUpdate</code>  仍将被调用。</p><h1 id="列表-Lists-和-键-Keys"><a href="#列表-Lists-和-键-Keys" class="headerlink" title="列表(Lists) 和 键(Keys)"></a>列表(Lists) 和 键(Keys)</h1><p>首先，让我们回顾一下在 JavaScript 中如何转换列表。</p><p>给定下面的代码，我们使用  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a>  函数使  <code>numbers</code>  数组中的元素值翻倍。我们将  <code>map()</code>  返回的新数组分配给变量  <code>doubled</code>，并且打印这个它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">const doubled = numbers.map((number) =&gt; number * 2);</span><br><span class="line">console.log(doubled);</span><br></pre></td></tr></table></figure><p>这段代码在控制台中打印为  <code>[2, 4, 6, 8, 10]</code>。</p><p>在 React 中，转换数组为  <a href="http://www.css88.com/react/docs/rendering-elements.html" target="_blank" rel="noopener">元素列表</a>  的方式，和上述方法基本相同。</p><h3 id="多组件渲染"><a href="#多组件渲染" class="headerlink" title="多组件渲染"></a>多组件渲染</h3><p>可以创建元素集合，并用一对大括号  <code>{}</code> <a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">在 JSX 中直接将其引用</a>即可。</p><p>下面，我们用 JavaScript 的  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a>  函数将  <code>numbers</code>  数组循环处理。对于每一项，我们返回一个  <code></code>  元素。最终，我们将结果元素数组分配给  <code>listItems</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">const listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>把整个  <code>listItems</code>  数组包含到一个  <code></code>  元素，并<a href="http://www.css88.com/react/docs/rendering-elements.html#rendering-an-element-into-the-dom" target="_blank" rel="noopener">渲染到 DOM</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/GjPyQr?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这段代码显示从 1 到 5 的数字列表。</p><h3 id="基本列表组件"><a href="#基本列表组件" class="headerlink" title="基本列表组件"></a>基本列表组件</h3><p>通常情况下，我们会在一个<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">组件</a>中渲染列表。</p><p>我们可以重构前面的例子到一个组件，它接受一个  <code>numbers</code>  数组，并输出一个元素的无序列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    &lt;li&gt;&#123;number&#125;&lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当运行上述代码的时候，将会收到一个警告：a key should be provided for list items（应该为列表元素提供一个键）（愚人码头注 ：CodeOpen 中没有报警告，是因为其示例中使用的是 min 版本的 React，换成非 min 版本的就可以看到）。当创建元素列表时，“key” 是一个你需要包含的特殊字符串属性。我们将在下一节讨论它的重要性。</p><p>我们在  <code>numbers.map()</code>  中赋值一个  <code>key</code>  给我们的列表元素，解决丢失 key 的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">      &#123;number&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/jrXYRR?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="键-Keys"><a href="#键-Keys" class="headerlink" title="键(Keys)"></a>键(Keys)</h2><p>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">const listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">    &#123;number&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>挑选 key 最好的方式是使用一个在它的同辈元素中不重复的标识字符串。多数情况你可以使用数据中的 IDs 作为 keys：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo) =&gt;</span><br><span class="line">  &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当要渲染的列表项中没有稳定的 IDs 时，你可以使用数据项的索引值作为 key 的最后选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo, index) =&gt;</span><br><span class="line">  // Only do this if items have no stable IDs</span><br><span class="line">  &lt;li key=&#123;index&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果列表项可能被重新排序时，我们不建议使用索引作为 keys，因为这导致一定的性能问题，会很慢。如果感兴趣，你可以阅读一下<a href="http://www.css88.com/react/docs/reconciliation.html#recursing-on-children" target="_blank" rel="noopener">深入的介绍关于为什么 keys 是必须的</a>。</p><h3 id="使用-keys-提取组件"><a href="#使用-keys-提取组件" class="headerlink" title="使用 keys 提取组件"></a>使用 keys 提取组件</h3><p>keys 只在数组的上下文中存在意义。</p><p>例如，如果你<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取</a>  一个  <code>ListItem</code>  组件，应该把 key 放置在数组处理的  <code>元素中，不能放在 `ListItem` 组件自身中的</code>  根元素上。</p><p><strong>例子：错误的 key 用法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function ListItem(props) &#123;</span><br><span class="line">  const value = props.value;</span><br><span class="line">  return (</span><br><span class="line">    // 错误！不需要在这里指定 key：</span><br><span class="line">    &lt;li key=&#123;value.toString()&#125;&gt;</span><br><span class="line">      &#123;value&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    // 错误！key 应该在这里指定：</span><br><span class="line">    &lt;ListItem value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>错误！key 应该在这里指定：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function ListItem(props) &#123;</span><br><span class="line">  // 正确！这里不需要指定 key ：</span><br><span class="line">  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    // 正确！key 应该在这里被指定</span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/rthor/pen/QKzJKG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>一个好的经验准则是元素中调用  <code>map()</code>  需要 keys 。</p><h3 id="keys-在同辈元素中必须是唯一的"><a href="#keys-在同辈元素中必须是唯一的" class="headerlink" title="keys 在同辈元素中必须是唯一的"></a>keys 在同辈元素中必须是唯一的</h3><p>在数组中使用的 keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一。我们可以在操作两个不同数组的时候使用相同的 keys ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function Blog(props) &#123;</span><br><span class="line">  const sidebar = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.posts.map((post) =&gt;</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">          &#123;post.title&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">  const content = props.posts.map((post) =&gt;</span><br><span class="line">    &lt;div key=&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;sidebar&#125;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &#123;content&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const posts = [</span><br><span class="line">  &#123;id: 1, title: &apos;Hello World&apos;, content: &apos;Welcome to learning React!&apos;&#125;,</span><br><span class="line">  &#123;id: 2, title: &apos;Installation&apos;, content: &apos;You can install React from npm.&apos;&#125;</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Blog posts=&#123;posts&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/NRZYGN?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>键是 React 的一个内部映射，但其不会传递给组件的内部。如果你需要在组件中使用相同的值，可以明确使用一个不同名字的 prop 传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const content = posts.map((post) =&gt;</span><br><span class="line">  &lt;Post</span><br><span class="line">    key=&#123;post.id&#125;</span><br><span class="line">    id=&#123;post.id&#125;</span><br><span class="line">    title=&#123;post.title&#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的例子中， <code>Post</code>  组件可以读取  <code>props.id</code>，但是不能读取  <code>props.key</code> 。</p><h3 id="在-JSX-中嵌入-map"><a href="#在-JSX-中嵌入-map" class="headerlink" title="在 JSX 中嵌入 map()"></a>在 JSX 中嵌入 map()</h3><p>在上面的例子中，我们单独声明了一个  <code>listItems</code>  变量，并在 JSX 中引用了该变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSX 允许在大括号中<a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">嵌入任何表达式</a>，因此可以 内联  <code>map()</code>  结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;numbers.map((number) =&gt;</span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">                  value=&#123;number&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/BLvYrB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>有时这可以产生清晰的代码，但是这个风格也可能被滥用。就像在 JavaScript 中，是否有必要提取一个变量以提高程序的可读性，这取决于你。但是记住，如果  <code>map()</code>  体中有太多嵌套，可能是<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取组件</a>的好时机。</p><h1 id="表单-Forms"><a href="#表单-Forms" class="headerlink" title="表单(Forms)"></a>表单(Forms)</h1><p>HTML 表单元素与 React 中的其他 DOM 元素有所不同，因为表单元素自然地保留了一些内部状态。例如，这个纯 HTML 表单接受一个单独的 name：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;label&gt;</span><br><span class="line">    Name:</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>该表单和 HTML 表单的默认行为一致，当用户提交此表单时浏览器会打开一个新页面。如果你希望 React 中保持这个行为，也可以工作。但是多数情况下，用一个处理表单提交并访问用户输入到表单中的数据的 JavaScript 函数也很方便。实现这一点的标准方法是使用一种称为“受控组件(controlled components)”的技术。</p><h2 id="受控组件-Controlled-Components"><a href="#受控组件-Controlled-Components" class="headerlink" title="受控组件(Controlled Components)"></a>受控组件(Controlled Components)</h2><p>在 HTML 中，表单元素如  <code>，</code>  和  <code></code>  表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过  <a href="http://www.css88.com/react/docs/react-component.html#setstate" target="_blank" rel="noopener"><code>setState()</code></a>  更新。</p><p>我们可以通过使 React 的 state 成为 “单一数据源原则” 来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。</p><p>例如，如果我们想使上一个例子在提交时记录名称，我们可以将表单写为受控组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;A name was submitted: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/VmmPgp?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>设置表单元素的 value 属性之后，其显示值将由 this.state.value 决定，以满足 React 状态的同一数据理念。每次键盘敲击之后会执行 handleChange 方法以更新 React 状态，显示值也将随着用户的输入改变。</p><p>由于  <code>value</code>  属性设置在我们的表单元素上，显示的值总是  <code>this.state.value</code>，以满足 state 状态的同一数据理念。由于  <code>handleChange</code>  在每次敲击键盘时运行，以更新 React state(状态)，显示的值将更新为用户的输入。</p><p>对于受控组件来说，每一次 state(状态) 变化都会伴有相关联的处理函数。这使得可以直接修改或验证用户的输入。比如，如果我们希望强制 name 的输入都是大写字母，可以这样来写<code>handleChange</code>  方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">  this.setState(&#123;value: event.target.value.toUpperCase()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textare-标签"><a href="#textare-标签" class="headerlink" title="textare 标签"></a>textare 标签</h2><p>在 HTML 中，<code></code>  元素通过它的子节点定义了它的文本值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea&gt;</span><br><span class="line">  Hello there, this is some text in a text area</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>在 React 中，<code>的赋值使用 `value` 属性替代。这样一来，表单中</code>  的书写方式接近于单行文本输入框 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class EssayForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;Please write an essay about your favorite DOM element.&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;An essay was submitted: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>this.state.value</code>  在构造函数中初始化，所以这些文本一开始就出现在文本域中。</p><h2 id="select-标签"><a href="#select-标签" class="headerlink" title="select 标签"></a>select 标签</h2><p>在 HTML 中，<code></code>  创建了一个下拉列表。例如，这段 HTML 创建一个下拉的口味(flavors)列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;</span><br><span class="line">  &lt;option selected value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>注意，Coconut 选项是初始化选中的，因为它的  <code>selected</code>  属性。React 中，并不使用这个<code>selected</code>  属性，而是在根  <code>select</code>  标签中使用了一个  <code>value</code>  属性。这使得受控组件使用更方便，因为你只需要更新一处即可。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class FlavorForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;coconut&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;Your favorite flavor is: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Pick your favorite La Croix flavor:</span><br><span class="line">          &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;</span><br><span class="line">          &lt;/select&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/JbbEzX?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>总的来说，这使  <code>，</code>  和  <code></code>  都以类似的方式工作 —— 它们都接受一个  <code>value</code>  属性可以用来实现一个受控组件。</p><h2 id="处理多个输入元素"><a href="#处理多个输入元素" class="headerlink" title="处理多个输入元素"></a>处理多个输入元素</h2><p>当您需要处理多个受控的  <code>input</code>  元素时，您可以为每个元素添加一个  <code>name</code>  属性，并且让处理函数根据  <code>event.target.name</code>  的值来选择要做什么。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleInputChange = this.handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target = event.target;</span><br><span class="line">    const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;</span><br><span class="line">    const name = target.name;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Is going:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=&quot;isGoing&quot;</span><br><span class="line">            type=&quot;checkbox&quot;</span><br><span class="line">            checked=&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Number of guests:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=&quot;numberOfGuests&quot;</span><br><span class="line">            type=&quot;number&quot;</span><br><span class="line">            value=&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/wgedvV?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>注意我们如何使用 ES6<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names" target="_blank" rel="noopener">计算的属性名称</a>语法来更新与给定输入名称相对应的 state(状态) 键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  [name]: value</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码等价于 ES5 代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var partialState = &#123;&#125;;</span><br><span class="line">partialState[name] = value;</span><br><span class="line">this.setState(partialState);</span><br></pre></td></tr></table></figure><p>此外，由于  <code>setState()</code>  自动<a href="http://www.css88.com/react/docs/state-and-lifecycle.html#state-updates-are-merged" target="_blank" rel="noopener">将部分状态合并到当前状态</a>，所以我们只需要调用更改的部分即可。</p><h2 id="受控组件的替代方案"><a href="#受控组件的替代方案" class="headerlink" title="受控组件的替代方案"></a>受控组件的替代方案</h2><p>有时使用受控组件有些乏味，因为你需要为每一个可更改的数据提供事件处理器，并通过 React 组件管理所有输入状态。当你将已经存在的代码转换为 React 时，或将 React 应用程序与非 React 库集成时，这可能变得特别烦人。在这些情况下，您可能需要使用<a href="http://www.css88.com/react/docs/uncontrolled-components.html" target="_blank" rel="noopener">不受控的组件</a>，用于实现输入表单的替代技术。</p><h1 id="状态提升-Lifting-State-Up"><a href="#状态提升-Lifting-State-Up" class="headerlink" title="状态提升(Lifting State Up)"></a>状态提升(Lifting State Up)</h1><p>通常情况下，同一个数据的变化需要几个不同的组件来反映。我们建议提升共享的状态到它们最近的祖先组件中。我们看下这是如何运作的。</p><p>在本节，我们将会创建一个温度计算器，用来计算水在一个给定温度下是否会沸腾。</p><p>我们通过一个称为  <code>BoilingVerdict</code>  的组件开始。它接受  <code>celsius</code>（摄氏温度）作为 prop ，并打印是否足以使水沸腾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function BoilingVerdict(props) &#123;</span><br><span class="line">  if (props.celsius &gt;= 100) &#123;</span><br><span class="line">    return &lt;p&gt;The water would boil.&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;p&gt;The water would not boil.&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将会创建一个  <code>Calculator</code>  组件。它渲染一个  <code></code>  让你输入温度，并在<code>this.state.temperature</code>  中保存它的值。</p><p>另外，它会根据当前输入的温度来渲染  <code>BoilingVerdict</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value=&#123;temperature&#125;</span><br><span class="line">          onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(temperature)&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/VpZJRZ?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="添加第二个输入"><a href="#添加第二个输入" class="headerlink" title="添加第二个输入"></a>添加第二个输入</h2><p>我们新的需求是，除了一个摄氏温度输入之外，我们再提供了一个华氏温度输入，并且两者保持自动同步。</p><p>我们可以从  <code>Calculator</code>  中提取一个  <code>TemperatureInput</code>  组件开始。我们将添加一个新的  <code>scale</code>属性，值可能是  <code>&quot;c&quot;</code>  或者  <code>&quot;f&quot;</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const scaleNames = &#123;</span><br><span class="line">  c: &apos;Celsius&apos;,</span><br><span class="line">  f: &apos;Fahrenheit&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    const scale = this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以修改  <code>Calculator</code>  来渲染两个独立的温度输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput scale=&quot;c&quot; /&gt;</span><br><span class="line">        &lt;TemperatureInput scale=&quot;f&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/GWKbao?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>我们现在有两个 (input)输入框 了，但是当你输入其中一个温度时，另一个输入并没有更新。这是跟我们的需要不符的：我们希望它们保持同步。</p><p>我们也不能在  <code>Calculator</code>  中显示  <code>BoilingVerdict</code> 。 <code>Calculator</code>  不知道当前的温度，因为它是在  <code>TemperatureInput</code>  中隐藏的。</p><h2 id="编写转换函数"><a href="#编写转换函数" class="headerlink" title="编写转换函数"></a>编写转换函数</h2><p>首先，我们编写两个函数来在摄氏温度和华氏温度之间转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function toCelsius(fahrenheit) &#123;</span><br><span class="line">  return (fahrenheit - 32) * 5 / 9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toFahrenheit(celsius) &#123;</span><br><span class="line">  return (celsius * 9 / 5) + 32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数用来转化数字。接下来再编写一个函数用来接收一个字符串  <code>temperature</code>  和一个 转化器函数 作为参数，并返回一个字符串。这个函数用来在两个输入之间进行相互转换。</p><p>对于无效的  <code>temperature</code>  值，它返回一个空字符串，输出结果保留 3 位小数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function tryConvert(temperature, convert) &#123;</span><br><span class="line">  const input = parseFloat(temperature);</span><br><span class="line">  if (Number.isNaN(input)) &#123;</span><br><span class="line">    return &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  const output = convert(input);</span><br><span class="line">  const rounded = Math.round(output * 1000) / 1000;</span><br><span class="line">  return rounded.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如， <code>tryConvert(&#39;abc&#39;, toCelsius)</code>  将返回一个空字符串，而  <code>tryConvert(&#39;10.22&#39;, toFahrenheit)</code>  返回  <code>&#39;50.396&#39;</code> 。</p><h2 id="状态提升-Lifting-State-Up-1"><a href="#状态提升-Lifting-State-Up-1" class="headerlink" title="状态提升(Lifting State Up)"></a>状态提升(Lifting State Up)</h2><p>目前，两个  <code>TemperatureInput</code>  组件都将其值保持在本地状态中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br></pre></td></tr></table></figure><p>但是，我们希望这两个输入是相互同步的。当我们更新摄氏温度输入时，华氏温度输入应反映转换后的温度，反之亦然。</p><p>在 React 中，共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。我们将从  <code>TemperatureInput</code>  中移除相关状态本地状态，并将其移动到  <code>Calculator</code>  中。</p><p>如果  <code>Calculator</code>  拥有共享状态，那么它将成为两个输入当前温度的“单一数据来源”。它可以指示他们具有彼此一致的值。由于两个  <code>TemperatureInput</code>  组件的 props 都来自同一个父级<code>Calculator</code>组件，两个输入将始终保持同步。</p><p>让我们一步一步看看这是如何工作的。</p><p>首先，我们将在  <code>TemperatureInput</code>  组件中用  <code>this.props.temperature</code>  替换<code>this.state.temperature</code> 。 现在，我们假装  <code>this.props.temperature</code>  已经存在，虽然我们将来需要从  <code>Calculator</code>  传递过来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 之前是: const temperature = this.state.temperature;</span><br><span class="line">  const temperature = this.props.temperature;</span><br></pre></td></tr></table></figure><p>我们知道  <a href="http://www.css88.com/react/docs/components-and-props.html#props-are-read-only" target="_blank" rel="noopener">props(属性) 是只读的</a>。 当  <code>temperature</code>  是 本地 state(状态)时， <code>TemperatureInput</code>可以调用  <code>this.setState()</code>  来更改它。 然而，现在  <code>temperature</code>  来自父级作为 prop(属性) ，<code>TemperatureInput</code>  就无法控制它。</p><p>在 React 中，通常通过使组件“受控”的方式来解决。就像 DOM <code></code>一样接受一个  <code>value</code>和一个  <code>onChange</code> prop(属性) ，所以可以定制  <code>TemperatureInput</code>  接受来自其父级  <code>Calculator</code>  的<code>temperature</code>  和  <code>onTemperatureChange</code> 。</p><p>现在，当  <code>TemperatureInput</code>  想要更新其温度时，它就会调用<code>this.props.onTemperatureChange</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(e) &#123;</span><br><span class="line">  // 之前是: this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  this.props.onTemperatureChange(e.target.value);</span><br></pre></td></tr></table></figure><p>请注意，自定义组件中的  <code>temperature</code>  或  <code>onTemperatureChange</code> prop(属性) 名称没有特殊的含义。我们可以命名为任何其他名称，像命名他们为  <code>value</code>  和  <code>onChange</code>，是一个常见的惯例。</p><p><code>onTemperatureChange</code> prop(属性) 和  <code>temperature</code> prop(属性) 一起由父级的  <code>Calculator</code>  组件提供。它将通过修改自己的本地 state(状态) 来处理变更，从而通过新值重新渲染两个输入。我们将很快看到新的  <code>Calculator</code>  实现。</p><p>在修改  <code>Calculator</code>  之前，让我们回顾一下对  <code>TemperatureInput</code>  组件的更改。我们已经从中删除了本地 state(状态) ，不是读取<code>this.state.temperature</code> ，我们现在读取<code>this.props.temperature</code> 。当我们想要更改时， 不是调用  <code>this.setState()</code> ，而是调用<code>this.props.onTemperatureChange()</code>， 这将由  <code>Calculator</code>  提供：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.props.temperature;</span><br><span class="line">    const scale = this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来看一下  <code>Calculator</code>  组件。</p><p>我们将当前输入的  <code>temperature</code>  和  <code>scale</code>  存储在本地 state(状态) 中。这是我们从输入 “提升” 的 state(状态) ，它将作为两个输入的 “单一数据来源” 。为了渲染两个输入，我们需要知道的所有数据的最小表示。</p><p>例如，如果我们在摄氏度输入框中输入 37 ，则  <code>Calculator</code>  组件的状态将是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: &apos;37&apos;,</span><br><span class="line">  scale: &apos;c&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们稍后将华氏温度字段编辑为 212 ，则  <code>Calculator</code>  组件的状态将是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: &apos;212&apos;,</span><br><span class="line">  scale: &apos;f&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以存储两个输入框的值，但事实证明是不必要的。存储最近更改的输入框的值，以及它所表示的度量衡就够了。然后，我们可以基于当前的  <code>temperature</code>(温度) 和  <code>scale</code>(度量衡) 来推断其他输入的值。</p><p>输入框保持同步，因为它们的值是从相同的 state(状态) 计算出来的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);</span><br><span class="line">    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &apos;c&apos;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &apos;f&apos;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const scale = this.state.scale;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=&quot;c&quot;</span><br><span class="line">          temperature=&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=&quot;f&quot;</span><br><span class="line">          temperature=&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(celsius)&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/jBNjja?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>现在，无论你编辑哪个输入框，<code>Calculator</code>  中的  <code>this.state.temperature</code>  和  <code>this.state.scale</code>都会更新。其中一个输入框获取值，所以任何用户输入都被保留，并且另一个输入总是基于它重新计算值。</p><p>让我们回顾一下编辑输入时会发生什么：</p><ul><li>React 调用在 DOM <code></code>  上的  <code>onChange</code>  指定的函数。在我们的例子中，这是<code>TemperatureInput</code>  组件中的  <code>handleChange</code>  方法。</li><li><code>TemperatureInput</code>  组件中的  <code>handleChange</code>  方法使用 新的期望值 调用<code>this.props.onTemperatureChange()</code>。<code>TemperatureInput</code>  组件中的 props(属性) ，包括<code>onTemperatureChange</code>，由其父组件  <code>Calculator</code>  提供。</li><li>当它预先呈现时， <code>Calculator</code>  指定了摄氏  <code>TemperatureInput</code>  的  <code>onTemperatureChange</code>  是<code>Calculator</code>  的  <code>handleCelsiusChange</code>  方法，并且华氏  <code>TemperatureInput</code>  的<code>onTemperatureChange</code>  是  <code>Calculator</code>  的  <code>handleFahrenheitChange</code>  方法。因此，会根据我们编辑的输入框，分别调用这两个  <code>Calculator</code>  方法。</li><li>在这些方法中， <code>Calculator</code>  组件要求 React 通过使用 新的输入值 和 刚刚编辑的输入框的当前度量衡 来调用  <code>this.setState()</code>  来重新渲染自身。</li><li>React 调用  <code>Calculator</code>  组件的  <code>render</code>  方法来了解 UI 外观应该是什么样子。基于当前温度和激活的度量衡来重新计算两个输入框的值。这里进行温度转换。</li><li>React 使用  <code>Calculator</code>  指定的新 props(属性) 调用各个  <code>TemperatureInput</code>  组件的  <code>render</code>方法。 它了解 UI 外观应该是什么样子。</li><li>React DOM 更新 DOM 以匹配期望的输入值。我们刚刚编辑的输入框接收当前值，另一个输入框更新为转换后的温度。</li></ul><p>每个更新都会执行相同的步骤，以便输入保持同步。</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>在一个 React 应用中，对于任何可变的数据都应该循序“单一数据源”原则。通常情况下，state 首先被添加到需要它进行渲染的组件。然后，如果其它的组件也需要它，你可以提升状态到它们最近的祖先组件。你应该依赖  <a href="http://www.css88.com/react/docs/state-and-lifecycle.html#the-data-flows-down" target="_blank" rel="noopener">从上到下的数据流向</a> ，而不是试图在不同的组件中同步状态。</p><p>提升状态相对于双向绑定方法需要写更多的“模板”代码，但是有一个好处，它可以更方便的找到和隔离 bugs。由于任何 state(状态) 都 “存活” 在若干的组件中，而且可以分别对其独立修改，所以发生错误的可能大大减少。另外，你可以实现任何定制的逻辑来拒绝或者转换用户输入。</p><p>如果某个东西可以从 props(属性) 或者 state(状态) 得到，那么它可能不应该在 state(状态) 中。例如，我们只保存最后编辑的  <code>temperature</code>  和它的  <code>scale</code>，而不是保存  <code>celsiusValue</code>  和<code>fahrenheitValue</code> 。另一个输入框的值总是在  <code>render()</code>  方法中计算得来的。这使我们对其进行清除和四舍五入到其他字段同时不会丢失用户输入的精度。</p><p>当你看到 UI 中的错误，你可以使用  <a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">React 开发者工具</a>来检查 props ，并向上遍历树，直到找到负责更新状态的组件。这使你可以跟踪到 bug 的源头：</p><h1 id="组合和继承对比（Composition-vs-Inheritance）"><a href="#组合和继承对比（Composition-vs-Inheritance）" class="headerlink" title="组合和继承对比（Composition vs Inheritance）"></a>组合和继承对比（Composition vs Inheritance）</h1><p>React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用。</p><p>在本节中，我们将考虑几个问题，即 React 新手经常会使用继承，并展示我们如何通过组合来解决它们。</p><h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><p>一些组件在设计前无法获知自己要使用什么子组件，尤其在  <code>Sidebar</code>  和  <code>Dialog</code>  等通用 “容器” 中比较常见。</p><p>我们建议这种组件使用特别的  <code>children</code> prop 来直接传递 子元素到他们的输出中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function FancyBorder(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#123;&apos;FancyBorder FancyBorder-&apos; + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这允许其他组件通过嵌套 JSX 传递任意子组件给他们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/ozqNOV?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在  <code>JSX 标签中的任何内容被传递到 `FancyBorder` 组件中，作为一个 `children`prop(属性)。由于 `FancyBorder` 渲染 `{props.children}` 到一个</code>  中，传递的元素会呈现在最终的输出中。</p><p>然而这并不常见，有时候，在一个组件中你可能需要多个 “占位符” 。在这种情况下，你可以使用自定义的 prop(属性)，而不是使用  <code>children</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function SplitPane(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;SplitPane&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;SplitPane-left&quot;&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;SplitPane-right&quot;&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left=&#123;</span><br><span class="line">        &lt;Contacts /&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwZOJp?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>如  <code>和</code>  等 React 元素本质上也是对象，所以可以将其像其他数据一样作为 props(属性) 传递使用。</p><h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><p>有时候，我们考虑组件作为其它组件的“特殊情况”。例如，我们可能说一个  <code>WelcomeDialog</code>  是<code>Dialog</code>  的一个特殊用例。</p><p>在 React 中，也可以使用组合来实现，一个偏“特殊”的组件渲染出一个偏“通用”的组件，通过 props(属性) 配置它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Dialog</span><br><span class="line">      title=&quot;Welcome&quot;</span><br><span class="line">      message=&quot;Thank you for visiting our spacecraft!&quot; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/kkEaOZ?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>对于用类定义的组件组合也同样适用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SignUpDialog extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSignUp = this.handleSignUp.bind(this);</span><br><span class="line">    this.state = &#123;login: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Dialog title=&quot;Mars Exploration Program&quot;</span><br><span class="line">              message=&quot;How should we refer to you?&quot;&gt;</span><br><span class="line">        &lt;input value=&#123;this.state.login&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;login: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSignUp() &#123;</span><br><span class="line">    alert(`Welcome aboard, $&#123;this.state.login&#125;!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwZbYa?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="如何看待？"><a href="#如何看待？" class="headerlink" title="如何看待？"></a>如何看待？</h2><p>在 Facebook ，我们在千万的组件中使用 React，我们还没有发现任何用例，值得我们建议你用继承层次结构来创建组件。</p><p>使用 props(属性) 和 组合已经足够灵活来明确、安全的定制一个组件的外观和行为。切记，组件可以接受任意的 props(属性) ，包括原始值、React 元素，或者函数。</p><p>如果要在组件之间重用非 UI 功能，我们建议将其提取到单独的 JavaScript 模块中。组件可以导入它并使用该函数，对象或类，而不扩展它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-快速入门&quot;&gt;&lt;a href=&quot;#React-快速入门&quot; class=&quot;headerlink&quot; title=&quot;React 快速入门&quot;&gt;&lt;/a&gt;React 快速入门&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker 安装 MySQL</title>
    <link href="https://dunwu.github.io/2019/03/06/os/docker/practice/docker-install-mysql/"/>
    <id>https://dunwu.github.io/2019/03/06/os/docker/practice/docker-install-mysql/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-安装-MySQL"><a href="#Docker-安装-MySQL" class="headerlink" title="Docker 安装 MySQL"></a>Docker 安装 MySQL</h1><blockquote><p>实测环境：Centos</p></blockquote><h2 id="查看可下载镜像"><a href="#查看可下载镜像" class="headerlink" title="查看可下载镜像"></a>查看可下载镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker search mysql</span></span><br><span class="line">INDEX       NAME                                                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/mysql                                                  MySQL is a widely used, open-source relati...   <span class="number">5757</span>      [OK]       </span><br><span class="line">docker.io   docker.io/mariadb                                                MariaDB is a community-developed fork of M...   <span class="number">1863</span>      [OK]       </span><br><span class="line">docker.io   docker.io/mysql/mysql-server                                     Optimized MySQL Server Docker images. Crea...   <span class="number">397</span>                  [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="选择下载官方镜像"><a href="#选择下载官方镜像" class="headerlink" title="选择下载官方镜像"></a>选择下载官方镜像</h2><p>比如，我想下载最新版本，则执行如下命令：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h2 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span></span><br></pre></td></tr></table></figure><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener">https://hub.docker.com/_/mysql/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-安装-MySQL&quot;&gt;&lt;a href=&quot;#Docker-安装-MySQL&quot; class=&quot;headerlink&quot; title=&quot;Docker 安装 MySQL&quot;&gt;&lt;/a&gt;Docker 安装 MySQL&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;实测环境：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaMail 使用小结</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javalib/javamail/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javalib/javamail/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaMail-使用小结"><a href="#JavaMail-使用小结" class="headerlink" title="JavaMail 使用小结"></a>JavaMail 使用小结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="邮件相关的标准"><a href="#邮件相关的标准" class="headerlink" title="邮件相关的标准"></a>邮件相关的标准</h3><p>厂商所提供的 JavaMail 服务程序可以有选择地实现某些邮件协议，常见的邮件协议包括：</p><ul><li><code>SMTP(Simple Mail Transfer Protocol)</code> ：即简单邮件传输协议，它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。</li><li><code>POP3(Post Office Protocol - Version 3)</code> ：即邮局协议版本 3 ，用于接收电子邮件的标准协议。</li><li><code>IMAP(Internet Mail Access Protocol)</code> ：即 Internet 邮件访问协议。是 POP3 的替代协议。</li></ul><p>这三种协议都有对应 SSL 加密传输的协议，分别是  <strong>SMTPS </strong>， <strong>POP3S </strong>和  <strong>IMAPS </strong>。</p><p><code>MIME(Multipurpose Internet Mail Extensions)</code> ：即多用途因特网邮件扩展标准。它不是邮件传输协议。但对传输内容的消息、附件及其它的内容定义了格式。</p><h3 id="JavaMail-简介"><a href="#JavaMail-简介" class="headerlink" title="JavaMail 简介"></a>JavaMail 简介</h3><p>JavaMail 是由 Sun 发布的用来处理 email 的 API 。它并没有包含在 Java SE 中，而是作为 Java EE 的一部分。</p><ul><li><code>mail.jar</code> ：此 JAR 文件包含 JavaMail API 和 Sun 提供的 SMTP 、 IMAP 和 POP3 服务提供程序；</li><li><code>activation.jar</code> ：此 JAR 文件包含 JAF API 和 Sun 的实现。</li></ul><p>JavaMail 包中用于处理电子邮件的核心类是： <code>Properties</code> 、 <code>Session</code> 、 <code>Message</code> 、 <code>Address</code> 、 <code>Authenticator</code> 、 <code>Transport</code> 、 <code>Store</code> 等。</p><h3 id="邮件传输过程"><a href="#邮件传输过程" class="headerlink" title="邮件传输过程"></a>邮件传输过程</h3><p>如上图，电子邮件的处理步骤如下：</p><ol><li>创建一个 Session 对象。</li><li>Session 对象创建一个 Transport 对象 /Store 对象，用来发送 / 保存邮件。</li><li>Transport 对象 /Store 对象连接邮件服务器。</li><li>Transport 对象 /Store 对象创建一个 Message 对象 ( 也就是邮件内容 ) 。</li><li>Transport 对象发送邮件； Store 对象获取邮箱的邮件。</li></ol><h3 id="Message-结构"><a href="#Message-结构" class="headerlink" title="Message 结构"></a>Message 结构</h3><ul><li><code>MimeMessage</code> 类：代表整封邮件。</li><li><code>MimeBodyPart</code> 类：代表邮件的一个 MIME 信息。</li><li><code>MimeMultipart</code> 类：代表一个由多个 MIME 信息组合成的组合 MIME 信息。</li></ul><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-948230d2f5c7a620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p><h2 id="JavaMail-的核心类"><a href="#JavaMail-的核心类" class="headerlink" title="JavaMail 的核心类"></a>JavaMail 的核心类</h2><p>JavaMail 对收发邮件进行了高级的抽象，形成了一些关键的的接口和类，它们构成了程序的基础，下面我们分别来了解一下这些最常见的对象。</p><h3 id="java-util-Properties-类（属性对象）"><a href="#java-util-Properties-类（属性对象）" class="headerlink" title="java.util.Properties 类（属性对象）"></a>java.util.Properties 类（属性对象）</h3><p>java.util.Properties 类代表一组属性集合。</p><p>它的每一个键和值都是 String <strong>类型。</strong></p><p>由于 JavaMail 需要和邮件服务器进行通信，这就要求程序提供许多诸如服务器地址、端口、用户名、密码等信息， JavaMail 通过 Properties 对象封装这些属性信息。</p><p>例： 如下面的代码封装了几个属性信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">prop.setProperty(<span class="string">"mail.debug"</span>, <span class="string">"true"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"mail.host"</span>, <span class="string">"[email protected]"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>针对不同的的邮件协议， JavaMail 规定了服务提供者必须支持一系列属性，</p><p>下表是一些常见属性（属性值都以 String 类型进行设置，属性类型栏仅表示属性是如何被解析的）：</p><table><thead><tr><th>关键词</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>mail.debug</td><td>boolean</td><td>debug 开关。</td></tr><tr><td>mail.host</td><td>String</td><td>指定发送、接收邮件的默认邮箱服务器。</td></tr><tr><td>mail.store.protocol</td><td>String</td><td>指定接收邮件的协议。</td></tr><tr><td>mail.transport.protocol</td><td>String</td><td>指定发送邮件的协议。</td></tr><tr><td>mail.debug.auth</td><td>boolean</td><td>debug 输出中是否包含认证命令。默认是 false 。</td></tr></tbody></table><p>详情请参考官方 API 文档：</p><p><a href="https://javamail.java.net/nonav/docs/api/" target="_blank" rel="noopener">https://javamail.java.net/nonav/docs/api/</a> 。</p><h3 id="javax-mail-Session-类（会话对象）"><a href="#javax-mail-Session-类（会话对象）" class="headerlink" title="javax.mail.Session 类（会话对象）"></a>javax.mail.Session 类（会话对象）</h3><p><code>Session</code> 表示一个邮件会话。</p><p>Session 的主要作用包括两个方面：</p><ul><li>接收各种配置属性信息：通过 Properties 对象设置的属性信息；</li><li>初始化 JavaMail 环境：根据 JavaMail 的配置文件，初始化 JavaMail 环境，以便通过 Session 对象创建其他重要类的实例。</li></ul><p>JavaMail 在 Jar 包的 META-INF 目录下，通过以下文件提供了基本配置信息，以便 session 能够根据这个配置文件加载提供者的实现类：</p><ul><li>javamail.default.providers</li><li>javamail.default.address.map</li></ul><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-b59382c69385df45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p><p><strong>例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">Session session = Session.getInstance(props);</span><br></pre></td></tr></table></figure><h3 id="javax-mail-Transport-类（邮件传输）"><a href="#javax-mail-Transport-类（邮件传输）" class="headerlink" title="javax.mail.Transport 类（邮件传输）"></a>javax.mail.Transport 类（邮件传输）</h3><p>邮件操作只有发送或接收两种处理方式。</p><p>JavaMail 将这两种不同操作描述为传输（ javax.mail.Transport ）和存储（ javax.mail.Store ），传输对应邮件的发送，而存储对应邮件的接收。</p><ul><li><code>getTransport</code> - Session 类中的 getTransport <strong>() </strong>有多个重载方法，可以用来创建 Transport 对象。</li><li><code>connect</code> - 如果设置了认证命令—— mail.smtp.auth ，那么使用 Transport 类的 connect 方法连接服务器时，则必须加上用户名和密码。</li><li><code>sendMessage</code> - Transport 类的 sendMessage 方法用来发送邮件消息。</li><li><code>close</code> - Transport 类的 close 方法用来关闭和邮件服务器的连接。</li></ul><h3 id="javax-mail-Store-类（邮件存储-）"><a href="#javax-mail-Store-类（邮件存储-）" class="headerlink" title="javax.mail.Store 类（邮件存储 ）"></a>javax.mail.Store 类（邮件存储 ）</h3><ul><li><code>getStore</code> - Session 类中的 getStore ()  有多个重载方法，可以用来创建 Store 对象。</li><li><code>connect</code> - 如果设置了认证命令—— mail.smtp.auth ，那么使用 Store 类的 connect 方法连接服务器时，则必须加上用户名和密码。</li><li><code>getFolder</code> - Store 类的 getFolder 方法可以 获取邮箱内的邮件夹 Folder 对象</li><li><code>close</code> - Store 类的 close 方法用来关闭和邮件服务器的连接。</li></ul><h3 id="javax-mail-Message-类（消息对象）"><a href="#javax-mail-Message-类（消息对象）" class="headerlink" title="javax.mail.Message 类（消息对象）"></a>javax.mail.Message 类（消息对象）</h3><ul><li><code>javax.mail.Message</code> - 是个抽象类，只能用子类去实例化，多数情况下为  <code>javax.mail.internet.MimeMessage</code>。</li><li><code>MimeMessage</code> - 代表 MIME 类型的电子邮件消息。</li></ul><p>要创建一个 Message ，需要将 Session 对象传递给 <code>MimeMessage</code> 构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br></pre></td></tr></table></figure><p>注意：还存在其它构造器，如用按 RFC822 格式的输入流来创建消息。</p><ul><li>setFrom - 设置邮件的发件人</li><li>setRecipient - 设置邮件的发送人、抄送人、密送人</li></ul><p>三种预定义的地址类型是：</p><ul><li><code>Message.RecipientType.TO</code> - 收件人</li><li><code>Message.RecipientType.CC</code> - 抄送人</li><li><code>Message.RecipientType.BCC</code> - 密送人</li><li><code>setSubject</code> - 设置邮件的主题</li><li><code>setContent</code> - 设置邮件内容</li><li><code>setText</code> - 如果邮件内容是纯文本，可以使用此接口设置文本内容。</li></ul><h3 id="javax-mail-Address-类（地址）"><a href="#javax-mail-Address-类（地址）" class="headerlink" title="javax.mail.Address 类（地址）"></a>javax.mail.Address 类（地址）</h3><p>一旦您创建了 Session 和 Message ，并将内容填入消息后，就可以用 Address 确定信件地址了。和 Message 一样， Address 也是个抽象类。您用的是 javax.mail.internet.InternetAddress 类。</p><p>若创建的地址只包含电子邮件地址，只要传递电子邮件地址到构造器就行了。</p><p><strong>例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address address = <span class="keyword">new</span> InternetAddress(<span class="string">"[email protected]"</span>);</span><br></pre></td></tr></table></figure><h3 id="Authenticator-类（认证者）"><a href="#Authenticator-类（认证者）" class="headerlink" title="Authenticator 类（认证者）"></a>Authenticator 类（认证者）</h3><p>与 java.net 类一样， JavaMail API 也可以利用 <code>Authenticator</code> 通过用户名和密码访问受保护的资源。对于 JavaMail API 来说，这些资源就是邮件服务器。<code>Authenticator</code> 在 javax.mail 包中，而且它和 java.net 中同名的类 Authenticator 不同。两者并不共享同一个 Authenticator ，因为 JavaMail API 用于 Java 1.1 ，它没有 java.net 类别。</p><p>要使用 Authenticator ，先创建一个抽象类的子类，并从 <code>getPasswordAuthentication()</code> 方法中返回 <code>PasswordAuthentication</code> 实例。创建完成后，您必需向 session 注册 <code>Authenticator</code> 。然后，在需要认证的时候，就会通知 <code>Authenticator</code> 。您可以弹出窗口，也可以从配置文件中（虽然没有加密是不安全的）读取用户名和密码，将它们作为 <code>PasswordAuthentication</code> 对象返回给调用程序。</p><p><strong>例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">Authenticator auth = <span class="keyword">new</span> MyAuthenticator();</span><br><span class="line">Session session = Session.getDefaultInstance(props, auth);</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="发送文本邮件"><a href="#发送文本邮件" class="headerlink" title="发送文本邮件"></a>发送文本邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">"mail.debug"</span>, <span class="string">"true"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.host"</span>, MAIL_SERVER_HOST);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    Session session = Session.getInstance(prop);</span><br><span class="line">    Transport ts = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到transport对象</span></span><br><span class="line">    ts = session.getTransport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建邮件</span></span><br><span class="line">    MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息头</span></span><br><span class="line">    message.setFrom(<span class="keyword">new</span> InternetAddress(MAIL_FROM)); <span class="comment">// 邮件的发件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(MAIL_TO)); <span class="comment">// 邮件的收件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.CC, <span class="keyword">new</span> InternetAddress(MAIL_CC)); <span class="comment">// 邮件的抄送人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.BCC, <span class="keyword">new</span> InternetAddress(MAIL_BCC)); <span class="comment">// 邮件的密送人</span></span><br><span class="line">    message.setSubject(<span class="string">"测试文本邮件"</span>); <span class="comment">// 邮件的标题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息体</span></span><br><span class="line">    message.setText(<span class="string">"天下无双。"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发送邮件</span></span><br><span class="line">    ts.sendMessage(message, message.getAllRecipients());</span><br><span class="line">    ts.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送-HTML-格式的邮件"><a href="#发送-HTML-格式的邮件" class="headerlink" title="发送 HTML 格式的邮件"></a>发送 HTML 格式的邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">"mail.debug"</span>, <span class="string">"true"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.host"</span>, MAIL_SERVER_HOST);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    Session session = Session.getInstance(prop);</span><br><span class="line">    Transport ts = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到transport对象</span></span><br><span class="line">    ts = session.getTransport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建邮件</span></span><br><span class="line">    MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息头</span></span><br><span class="line">    message.setFrom(<span class="keyword">new</span> InternetAddress(MAIL_FROM)); <span class="comment">// 邮件的发件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(MAIL_TO)); <span class="comment">// 邮件的收件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.CC, <span class="keyword">new</span> InternetAddress(MAIL_CC)); <span class="comment">// 邮件的抄送人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.BCC, <span class="keyword">new</span> InternetAddress(MAIL_BCC)); <span class="comment">// 邮件的密送人</span></span><br><span class="line">    message.setSubject(<span class="string">"测试HTML邮件"</span>); <span class="comment">// 邮件的标题</span></span><br><span class="line"></span><br><span class="line">    String htmlContent = <span class="string">"&lt;h1&gt;Hello&lt;/h1&gt;"</span> + <span class="string">"&lt;p&gt;显示图片&lt;img src='cid:abc.jpg'&gt;1.jpg&lt;/p&gt;"</span>;</span><br><span class="line">    MimeBodyPart text = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">    text.setContent(htmlContent, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    MimeBodyPart image = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">    DataHandler dh = <span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="string">"D:\\05_Datas\\图库\\吉他少年背影.png"</span>));</span><br><span class="line">    image.setDataHandler(dh);</span><br><span class="line">    image.setContentID(<span class="string">"abc.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述数据关系</span></span><br><span class="line">    MimeMultipart mm = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">    mm.addBodyPart(text);</span><br><span class="line">    mm.addBodyPart(image);</span><br><span class="line">    mm.setSubType(<span class="string">"related"</span>);</span><br><span class="line">    message.setContent(mm);</span><br><span class="line">    message.saveChanges();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发送邮件</span></span><br><span class="line">    ts.sendMessage(message, message.getAllRecipients());</span><br><span class="line">    ts.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">"mail.debug"</span>, <span class="string">"true"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.host"</span>, MAIL_SERVER_HOST);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    Session session = Session.getInstance(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到transport对象</span></span><br><span class="line">    Transport ts = session.getTransport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建邮件</span></span><br><span class="line">    MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息头</span></span><br><span class="line">    message.setFrom(<span class="keyword">new</span> InternetAddress(MAIL_FROM)); <span class="comment">// 邮件的发件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(MAIL_TO)); <span class="comment">// 邮件的收件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.CC, <span class="keyword">new</span> InternetAddress(MAIL_CC)); <span class="comment">// 邮件的抄送人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.BCC, <span class="keyword">new</span> InternetAddress(MAIL_BCC)); <span class="comment">// 邮件的密送人</span></span><br><span class="line">    message.setSubject(<span class="string">"测试带附件邮件"</span>); <span class="comment">// 邮件的标题</span></span><br><span class="line"></span><br><span class="line">    MimeBodyPart text = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">    text.setContent(<span class="string">"邮件中有两个附件。"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述数据关系</span></span><br><span class="line">    MimeMultipart mm = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">    mm.setSubType(<span class="string">"related"</span>);</span><br><span class="line">    mm.addBodyPart(text);</span><br><span class="line">    String[] files = &#123;</span><br><span class="line">            <span class="string">"D:\\00_Temp\\temp\\1.jpg"</span>, <span class="string">"D:\\00_Temp\\temp\\2.png"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加邮件附件</span></span><br><span class="line">    <span class="keyword">for</span> (String filename : files) &#123;</span><br><span class="line">        MimeBodyPart attachPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        attachPart.attachFile(filename);</span><br><span class="line">        mm.addBodyPart(attachPart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message.setContent(mm);</span><br><span class="line">    message.saveChanges();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发送邮件</span></span><br><span class="line">    ts.sendMessage(message, message.getAllRecipients());</span><br><span class="line">    ts.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取邮箱中的邮件"><a href="#获取邮箱中的邮件" class="headerlink" title="获取邮箱中的邮件"></a>获取邮箱中的邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个有具体连接信息的Properties对象</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">"mail.debug"</span>, <span class="string">"true"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.store.protocol"</span>, <span class="string">"pop3"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"mail.pop3.host"</span>, MAIL_SERVER_HOST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    Session session = Session.getInstance(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到Store对象</span></span><br><span class="line">    Store store = session.getStore();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    store.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、获得邮箱内的邮件夹</span></span><br><span class="line">    Folder folder = store.getFolder(<span class="string">"inbox"</span>);</span><br><span class="line">    folder.open(Folder.READ_ONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得邮件夹Folder内的所有邮件Message对象</span></span><br><span class="line">    Message[] messages = folder.getMessages();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; messages.length; i++) &#123;</span><br><span class="line">        String subject = messages[i].getSubject();</span><br><span class="line">        String from = (messages[i].getFrom()[<span class="number">0</span>]).toString();</span><br><span class="line">        System.out.println(<span class="string">"第 "</span> + (i + <span class="number">1</span>) + <span class="string">"封邮件的主题："</span> + subject);</span><br><span class="line">        System.out.println(<span class="string">"第 "</span> + (i + <span class="number">1</span>) + <span class="string">"封邮件的发件人地址："</span> + from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、关闭</span></span><br><span class="line">    folder.close(<span class="keyword">false</span>);</span><br><span class="line">    store.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转发邮件"><a href="#转发邮件" class="headerlink" title="转发邮件"></a>转发邮件</h3><p>例：获取指定邮件夹下的第一封邮件并转发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.put(<span class="string">"mail.store.protocol"</span>, <span class="string">"pop3"</span>);</span><br><span class="line">    prop.put(<span class="string">"mail.pop3.host"</span>, MAIL_SERVER_POP3);</span><br><span class="line">    prop.put(<span class="string">"mail.pop3.starttls.enable"</span>, <span class="string">"true"</span>);</span><br><span class="line">    prop.put(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line">    prop.put(<span class="string">"mail.smtp.host"</span>, MAIL_SERVER_SMTP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    Session session = Session.getDefaultInstance(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、读取邮件夹</span></span><br><span class="line">    Store store = session.getStore(<span class="string">"pop3"</span>);</span><br><span class="line">    store.connect(MAIL_SERVER_POP3, USER, PASSWORD);</span><br><span class="line">    Folder folder = store.getFolder(<span class="string">"inbox"</span>);</span><br><span class="line">    folder.open(Folder.READ_ONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邮件夹中第1封邮件信息</span></span><br><span class="line">    Message[] messages = folder.getMessages();</span><br><span class="line">    <span class="keyword">if</span> (messages.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Message message = messages[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印邮件关键信息</span></span><br><span class="line">    String from = InternetAddress.toString(message.getFrom());</span><br><span class="line">    <span class="keyword">if</span> (from != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"From: "</span> + from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String replyTo = InternetAddress.toString(message.getReplyTo());</span><br><span class="line">    <span class="keyword">if</span> (replyTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Reply-to: "</span> + replyTo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String to = InternetAddress.toString(message.getRecipients(Message.RecipientType.TO));</span><br><span class="line">    <span class="keyword">if</span> (to != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"To: "</span> + to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String subject = message.getSubject();</span><br><span class="line">    <span class="keyword">if</span> (subject != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Subject: "</span> + subject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Date sent = message.getSentDate();</span><br><span class="line">    <span class="keyword">if</span> (sent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sent: "</span> + sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置转发邮件信息头</span></span><br><span class="line">    Message forward = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">    forward.setFrom(<span class="keyword">new</span> InternetAddress(MAIL_FROM));</span><br><span class="line">    forward.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(MAIL_TO));</span><br><span class="line">    forward.setSubject(<span class="string">"Fwd: "</span> + message.getSubject());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置转发邮件内容</span></span><br><span class="line">    MimeBodyPart bodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">    bodyPart.setContent(message, <span class="string">"message/rfc822"</span>);</span><br><span class="line"></span><br><span class="line">    Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">    multipart.addBodyPart(bodyPart);</span><br><span class="line">    forward.setContent(multipart);</span><br><span class="line">    forward.saveChanges();</span><br><span class="line"></span><br><span class="line">    Transport ts = session.getTransport(<span class="string">"smtp"</span>);</span><br><span class="line">    ts.connect(USER, PASSWORD);</span><br><span class="line">    ts.sendMessage(forward, forward.getAllRecipients());</span><br><span class="line"></span><br><span class="line">    folder.close(<span class="keyword">false</span>);</span><br><span class="line">    store.close();</span><br><span class="line">    ts.close();</span><br><span class="line">    System.out.println(<span class="string">"message forwarded successfully...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaMail-使用小结&quot;&gt;&lt;a href=&quot;#JavaMail-使用小结&quot; class=&quot;headerlink&quot; title=&quot;JavaMail 使用小结&quot;&gt;&lt;/a&gt;JavaMail 使用小结&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mockito 快速指南</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javalib/mockito/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javalib/mockito/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mockito-快速指南"><a href="#mockito-快速指南" class="headerlink" title="mockito 快速指南"></a>mockito 快速指南</h1><blockquote><p>Mockito 是一个针对 Java 的 mock 框架。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#预备知识">预备知识</a></li><li><a href="#使用-mock-对象来进行测试">使用 mock 对象来进行测试</a><ul><li><a href="#单元测试的目标和挑战">单元测试的目标和挑战</a></li><li><a href="#测试类的分类">测试类的分类</a></li><li><a href="#mock-对象的产生">Mock 对象的产生</a></li><li><a href="#使用-mockito-生成-mock-对象">使用 Mockito 生成 Mock 对象</a></li></ul></li><li><a href="#为自己的项目添加-mockito-依赖">为自己的项目添加 Mockito 依赖</a><ul><li><a href="#在-gradle-添加-mockito-依赖">在 Gradle 添加 Mockito 依赖</a></li><li><a href="#在-maven-添加-mockito-依赖">在 Maven 添加 Mockito 依赖</a></li><li><a href="#在-eclipse-ide-使用-mockito">在 Eclipse IDE 使用 Mockito</a></li><li><a href="#以-osgi-或者-eclipse-插件形式添加-mockito-依赖">以 OSGi 或者 Eclipse 插件形式添加 Mockito 依赖</a></li></ul></li><li><a href="#使用-mockito-api">使用 Mockito API</a><ul><li><a href="#静态引用">静态引用</a></li><li><a href="#使用-mockito-创建和配置-mock-对象">使用 Mockito 创建和配置 mock 对象</a></li><li><a href="#配置-mock">配置 mock</a></li><li><a href="#验证-mock-对象方法是否被调用">验证 mock 对象方法是否被调用</a></li><li><a href="#使用-spy-封装-java-对象">使用 Spy 封装 java 对象</a></li><li><a href="#使用-injectmocks-在-mockito-中进行依赖注入">使用 @InjectMocks 在 Mockito 中进行依赖注入</a></li><li><a href="#捕捉参数">捕捉参数</a></li><li><a href="#mockito-的限制">Mockito 的限制</a></li></ul></li><li><a href="#在-android-中使用-mockito">在 Android 中使用 Mockito</a></li><li><a href="#实例使用-mockito-写一个-instrumented-unit-test">实例：使用 Mockito 写一个 Instrumented Unit Test</a><ul><li><a href="#创建一个测试的-android-应用">创建一个测试的 Android 应用</a></li><li><a href="#在-appbuildgradle-文件中添加-mockito-依赖">在 app/build.gradle 文件中添加 Mockito 依赖</a></li><li><a href="#创建测试">创建测试</a></li></ul></li><li><a href="#实例使用-mockito-创建一个-mock-对象">实例：使用 Mockito 创建一个 mock 对象</a><ul><li><a href="#目标">目标</a></li><li><a href="#创建一个-twitter-api-的例子">创建一个 Twitter API 的例子</a></li><li><a href="#模拟-itweet-的实例">模拟 ITweet 的实例</a></li><li><a href="#验证方法调用">验证方法调用</a></li><li><a href="#验证">验证</a></li></ul></li><li><a href="#模拟静态方法">模拟静态方法</a><ul><li><a href="#使用-powermock-来模拟静态方法">使用 Powermock 来模拟静态方法</a></li><li><a href="#用封装的方法代替-powermock">用封装的方法代替 Powermock</a></li></ul></li><li><a href="#引用和引申">引用和引申</a></li></ul><!-- /TOC --><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>如果需要往下学习，你需要先理解 Junit 框架中的单元测试。</p><p>如果你不熟悉 JUnit，请查看下面的教程： <a href="http://www.vogella.com/tutorials/JUnit/article.html" target="_blank" rel="noopener">http://www.vogella.com/tutorials/JUnit/article.html</a></p><h2 id="使用-mock-对象来进行测试"><a href="#使用-mock-对象来进行测试" class="headerlink" title="使用 mock 对象来进行测试"></a>使用 mock 对象来进行测试</h2><h3 id="单元测试的目标和挑战"><a href="#单元测试的目标和挑战" class="headerlink" title="单元测试的目标和挑战"></a>单元测试的目标和挑战</h3><p>单元测试的思路是在不涉及依赖关系的情况下测试代码（隔离性），所以测试代码与其他类或者系统的关系应该尽量被消除。一个可行的消除方法是替换掉依赖类（测试替换），也就是说我们可以使用替身来替换掉真正的依赖对象。</p><h3 id="测试类的分类"><a href="#测试类的分类" class="headerlink" title="测试类的分类"></a>测试类的分类</h3><ul><li><strong>dummy object</strong> 做为参数传递给方法但是绝对不会被使用。譬如说，这种测试类内部的方法不会被调用，或者是用来填充某个方法的参数。</li><li><strong>Fake</strong> 是真正接口或抽象类的实现体，但给对象内部实现很简单。譬如说，它存在内存中而不是真正的数据库中。（译者注：<strong>Fake</strong> 实现了真正的逻辑，但它的存在只是为了测试，而不适合于用在产品中。）</li><li><strong>stub</strong> 类是依赖类的部分方法实现，而这些方法在你测试类和接口的时候会被用到，也就是说 <strong>stub</strong> 类在测试中会被实例化。<strong>stub</strong> 类会回应任何外部测试的调用。<strong>stub</strong> 类有时候还会记录调用的一些信息。</li><li><strong>mock object</strong> 是指类或者接口的模拟实现，你可以自定义这个对象中某个方法的输出结果。</li></ul><p>测试替代技术能够在测试中模拟测试类以外对象。因此你可以验证测试类是否响应正常。譬如说，你可以验证在 Mock 对象的某一个方法是否被调用。这可以确保隔离了外部依赖的干扰只测试测试类。</p><p>我们选择 Mock 对象的原因是因为 Mock 对象只需要少量代码的配置。</p><h3 id="Mock-对象的产生"><a href="#Mock-对象的产生" class="headerlink" title="Mock 对象的产生"></a>Mock 对象的产生</h3><p>你可以手动创建一个 Mock 对象或者使用 Mock 框架来模拟这些类，Mock 框架允许你在运行时创建 Mock 对象并且定义它的行为。</p><p>一个典型的例子是把 Mock 对象模拟成数据的提供者。在正式的生产环境中它会被实现用来连接数据源。但是我们在测试的时候 Mock 对象将会模拟成数据提供者来确保我们的测试环境始终是相同的。</p><p>Mock 对象可以被提供来进行测试。因此，我们测试的类应该避免任何外部数据的强依赖。</p><p>通过 Mock 对象或者 Mock 框架，我们可以测试代码中期望的行为。譬如说，验证只有某个存在 Mock 对象的方法是否被调用了。</p><h3 id="使用-Mockito-生成-Mock-对象"><a href="#使用-Mockito-生成-Mock-对象" class="headerlink" title="使用 Mockito 生成 Mock 对象"></a>使用 Mockito 生成 Mock 对象</h3><p><em>Mockito</em> 是一个流行 mock 框架，可以和 JUnit 结合起来使用。Mockito 允许你创建和配置 mock 对象。使用 Mockito 可以明显的简化对外部依赖的测试类的开发。</p><p>一般使用 Mockito 需要执行下面三步</p><ol><li>模拟并替换测试代码中外部依赖</li><li>执行测试代码</li><li>验证测试代码是否被正确的执行</li></ol><p><br><div align="center"><img src="https://camo.githubusercontent.com/d10c5af5eb7d78af30d92e0f1a9813f419e3975e/687474703a2f2f7777322e73696e61696d672e636e2f6c617267652f3732663936636261677731663562326a386d3276736a323068683035366a7276"></div><br></p><h2 id="为自己的项目添加-Mockito-依赖"><a href="#为自己的项目添加-Mockito-依赖" class="headerlink" title="为自己的项目添加 Mockito 依赖"></a>为自己的项目添加 Mockito 依赖</h2><h3 id="在-Gradle-添加-Mockito-依赖"><a href="#在-Gradle-添加-Mockito-依赖" class="headerlink" title="在 Gradle 添加 Mockito 依赖"></a>在 Gradle 添加 Mockito 依赖</h3><p>如果你的项目使用 Gradle 构建，将下面代码加入 Gradle 的构建文件中为自己项目添加 Mockito 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123; jcenter() &#125;</span><br><span class="line">dependencies &#123; testCompile &quot;org.mockito:mockito-core:2.0.57-beta&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="在-Maven-添加-Mockito-依赖"><a href="#在-Maven-添加-Mockito-依赖" class="headerlink" title="在 Maven 添加 Mockito 依赖"></a>在 Maven 添加 Mockito 依赖</h3><p>需要在 Maven 声明依赖，您可以在 <a href="http://search.maven.org/" target="_blank" rel="noopener">http://search.maven.org</a> 网站中搜索 g:”org.mockito”, a:”mockito-core” 来得到具体的声明方式。</p><h3 id="在-Eclipse-IDE-使用-Mockito"><a href="#在-Eclipse-IDE-使用-Mockito" class="headerlink" title="在 Eclipse IDE 使用 Mockito"></a>在 Eclipse IDE 使用 Mockito</h3><p>Eclipse IDE 支持 Gradle 和 Maven 两种构建工具，所以在 Eclipse IDE 添加依赖取决你使用的是哪一个构建工具。</p><h3 id="以-OSGi-或者-Eclipse-插件形式添加-Mockito-依赖"><a href="#以-OSGi-或者-Eclipse-插件形式添加-Mockito-依赖" class="headerlink" title="以 OSGi 或者 Eclipse 插件形式添加 Mockito 依赖"></a>以 OSGi 或者 Eclipse 插件形式添加 Mockito 依赖</h3><p>在 Eclipse RCP 应用依赖通常可以在 p2 update 上得到。Orbit 是一个很好的第三方仓库，我们可以在里面寻找能在 Eclipse 上使用的应用和插件。</p><p>Orbit 仓库地址：<a href="http://download.eclipse.org/tools/orbit/downloads" target="_blank" rel="noopener">http://download.eclipse.org/tools/orbit/downloads</a></p><p><br><div align="center"><img src="https://camo.githubusercontent.com/79c0e1d7c1e50563574535f33e64b365af512af9/687474703a2f2f7777322e73696e61696d672e636e2f6c617267652f3732663936636261677731663562326a6c627239376a32306e79306867373763"></div><br></p><h2 id="使用-Mockito-API"><a href="#使用-Mockito-API" class="headerlink" title="使用 Mockito API"></a>使用 Mockito API</h2><h3 id="静态引用"><a href="#静态引用" class="headerlink" title="静态引用"></a>静态引用</h3><p>如果在代码中静态引用了<code>org.mockito.Mockito.*;</code>，那你你就可以直接调用静态方法和静态变量而不用创建对象，譬如直接调用 mock() 方法。</p><h3 id="使用-Mockito-创建和配置-mock-对象"><a href="#使用-Mockito-创建和配置-mock-对象" class="headerlink" title="使用 Mockito 创建和配置 mock 对象"></a>使用 Mockito 创建和配置 mock 对象</h3><p>除了上面所说的使用 mock() 静态方法外，Mockito 还支持通过 <code>@Mock</code> 注解的方式来创建 mock 对象。</p><p>如果你使用注解，那么必须要实例化 mock 对象。Mockito 在遇到使用注解的字段的时候，会调用<code>MockitoAnnotations.initMocks(this)</code> 来初始化该 mock 对象。另外也可以通过使用<code>@RunWith(MockitoJUnitRunner.class)</code>来达到相同的效果。</p><p>通过下面的例子我们可以了解到使用<code>@Mock</code> 的方法和<code>MockitoRule</code>规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        MyDatabase databaseMock; (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Rule</span> <span class="keyword">public</span> MockitoRule mockitoRule = MockitoJUnit.rule(); (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">                ClassToTest t  = <span class="keyword">new</span> ClassToTest(databaseMock); (<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">boolean</span> check = t.query(<span class="string">"* from t"</span>); (<span class="number">4</span>)</span><br><span class="line">                assertTrue(check); (<span class="number">5</span>)</span><br><span class="line">                verify(databaseMock).query(<span class="string">"* from t"</span>); (<span class="number">6</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>告诉 Mockito 模拟 databaseMock 实例</li><li>Mockito 通过 @mock 注解创建 mock 对象</li><li>使用已经创建的 mock 初始化这个类</li><li>在测试环境下，执行测试类中的代码</li><li>使用断言确保调用的方法返回值为 true</li><li>验证 query 方法是否被 <code>MyDatabase</code> 的 mock 对象调用</li></ol><h3 id="配置-mock"><a href="#配置-mock" class="headerlink" title="配置 mock"></a>配置 mock</h3><p>当我们需要配置某个方法的返回值的时候，Mockito 提供了链式的 API 供我们方便的调用</p><p><code>when(….).thenReturn(….)</code>可以被用来定义当条件满足时函数的返回值，如果你需要定义多个返回值，可以多次定义。当你多次调用函数的时候，Mockito 会根据你定义的先后顺序来返回返回值。Mocks 还可以根据传入参数的不同来定义不同的返回值。譬如说你的函数可以将<code>anyString</code> 或者 <code>anyInt</code>作为输入参数，然后定义其特定的放回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//  创建 mock</span></span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义 getUniqueId() 的返回值</span></span><br><span class="line">        when(test.getUniqueId()).thenReturn(<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在测试中使用mock对象</span></span><br><span class="line">        assertEquals(test.getUniqueId(), <span class="number">43</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回多个值</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMoreThanOneReturnValue</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        Iterator i= mock(Iterator.class);</span><br><span class="line">        when(i.next()).thenReturn(<span class="string">"Mockito"</span>).thenReturn(<span class="string">"rocks"</span>);</span><br><span class="line">        String result=i.next()+<span class="string">" "</span>+i.next();</span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        assertEquals(<span class="string">"Mockito rocks"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何根据输入来返回值</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnValueDependentOnMethodParameter</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(<span class="string">"Mockito"</span>)).thenReturn(<span class="number">1</span>);</span><br><span class="line">        when(c.compareTo(<span class="string">"Eclipse"</span>)).thenReturn(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        assertEquals(<span class="number">1</span>,c.compareTo(<span class="string">"Mockito"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何让返回值不依赖于输入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnValueInDependentOnMethodParameter</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(anyInt())).thenReturn(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        assertEquals(-<span class="number">1</span> ,c.compareTo(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据参数类型来返回值</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnValueInDependentOnMethodParameter</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(isA(Todo.class))).thenReturn(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        Todo todo = <span class="keyword">new</span> Todo(<span class="number">5</span>);</span><br><span class="line">        assertEquals(todo ,c.compareTo(<span class="keyword">new</span> Todo(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于无返回值的函数，我们可以使用<code>doReturn(…).when(…).methodCall</code>来获得类似的效果。例如我们想在调用某些无返回值函数的时候抛出异常，那么可以使用<code>doThrow</code> 方法。如下面代码片段所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面测试用例描述了如何使用doThrow()方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>(expected=IOException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForIOException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并配置 mock 对象</span></span><br><span class="line">        OutputStream mockStream = mock(OutputStream.class);</span><br><span class="line">        doThrow(<span class="keyword">new</span> IOException()).when(mockStream).close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 mock</span></span><br><span class="line">        OutputStreamWriter streamWriter= <span class="keyword">new</span> OutputStreamWriter(mockStream);</span><br><span class="line">        streamWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证-mock-对象方法是否被调用"><a href="#验证-mock-对象方法是否被调用" class="headerlink" title="验证 mock 对象方法是否被调用"></a>验证 mock 对象方法是否被调用</h3><p>Mockito 会跟踪 mock 对象里面所有的方法和变量。所以我们可以用来验证函数在传入特定参数的时候是否被调用。这种方式的测试称行为测试，行为测试并不会检查函数的返回值，而是检查在传入正确参数时候函数是否被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVerify</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并配置 mock 对象</span></span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line">        when(test.getUniqueId()).thenReturn(<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用mock对象里面的方法并传入参数为12</span></span><br><span class="line">        test.testing(<span class="number">12</span>);</span><br><span class="line">        test.getUniqueId();</span><br><span class="line">        test.getUniqueId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看在传入参数为12的时候方法是否被调用</span></span><br><span class="line">        verify(test).testing(Matchers.eq(<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法是否被调用两次</span></span><br><span class="line">        verify(test, times(<span class="number">2</span>)).getUniqueId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他用来验证函数是否被调用的方法</span></span><br><span class="line">        verify(mock, never()).someMethod(<span class="string">"never called"</span>);</span><br><span class="line">        verify(mock, atLeastOnce()).someMethod(<span class="string">"called at least once"</span>);</span><br><span class="line">        verify(mock, atLeast(<span class="number">2</span>)).someMethod(<span class="string">"called at least twice"</span>);</span><br><span class="line">        verify(mock, times(<span class="number">5</span>)).someMethod(<span class="string">"called five times"</span>);</span><br><span class="line">        verify(mock, atMost(<span class="number">3</span>)).someMethod(<span class="string">"called at most 3 times"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Spy-封装-java-对象"><a href="#使用-Spy-封装-java-对象" class="headerlink" title="使用 Spy 封装 java 对象"></a>使用 Spy 封装 java 对象</h3><p>@Spy 或者<code>spy()</code>方法可以被用来封装 java 对象。被封装后，除非特殊声明（打桩 <em>stub</em>），否则都会真正的调用对象里面的每一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lets mock a LinkedList</span></span><br><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用 doReturn() 来打桩</span></span><br><span class="line">doReturn(<span class="string">"foo"</span>).when(spy).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码不生效</span></span><br><span class="line"><span class="comment">// 真正的方法会被调用</span></span><br><span class="line"><span class="comment">// 将会抛出 IndexOutOfBoundsException 的异常，因为 List 为空</span></span><br><span class="line">when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><p>方法<code>verifyNoMoreInteractions()</code>允许你检查没有其他的方法被调用了。</p><h3 id="使用-InjectMocks-在-Mockito-中进行依赖注入"><a href="#使用-InjectMocks-在-Mockito-中进行依赖注入" class="headerlink" title="使用 @InjectMocks 在 Mockito 中进行依赖注入"></a>使用 @InjectMocks 在 Mockito 中进行依赖注入</h3><p>我们也可以使用<code>@InjectMocks</code> 注解来创建对象，它会根据类型来注入对象里面的成员方法和变量。假定我们有 ArticleManager 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> ArticleDatabase database;</span><br><span class="line"></span><br><span class="line">    ArticleManager(User user) &#123;</span><br><span class="line">     <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDatabase</span><span class="params">(ArticleDatabase database)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类会被 Mockito 构造，而类的成员方法和变量都会被 mock 对象所代替，正如下面的代码片段所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(MockitoJUnitRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleManagerTest</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Mock</span> ArticleCalculator calculator;</span><br><span class="line">       <span class="meta">@Mock</span> ArticleDatabase database;</span><br><span class="line">       <span class="meta">@Most</span> User user;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Spy</span> <span class="keyword">private</span> UserProvider userProvider = <span class="keyword">new</span> ConsumerUserProvider();</span><br><span class="line"></span><br><span class="line">       <span class="meta">@InjectMocks</span> <span class="keyword">private</span> ArticleManager manager; (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldDoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">// 假定 ArticleManager 有一个叫 initialize() 的方法被调用了</span></span><br><span class="line">               <span class="comment">// 使用 ArticleListener 来调用 addListener 方法</span></span><br><span class="line">               manager.initialize();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 验证 addListener 方法被调用</span></span><br><span class="line">               verify(database).addListener(any(ArticleListener.class));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建 ArticleManager 实例并注入 Mock 对象</li></ol><p>更多的详情可以查看 <a href="http://docs.mockito.googlecode.com/hg/1.9.5/org/mockito/InjectMocks.html" target="_blank" rel="noopener">http://docs.mockito.googlecode.com/hg/1.9.5/org/mockito/InjectMocks.html</a>.</p><h3 id="捕捉参数"><a href="#捕捉参数" class="headerlink" title="捕捉参数"></a>捕捉参数</h3><p><code>ArgumentCaptor</code>类允许我们在 verification 期间访问方法的参数。得到方法的参数后我们可以使用它进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.hasItem;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertThat;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.mock;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.verify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.ArgumentCaptor;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Captor;</span><br><span class="line"><span class="keyword">import</span> org.mockito.junit.MockitoJUnit;</span><br><span class="line"><span class="keyword">import</span> org.mockito.junit.MockitoRule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> MockitoRule rule = MockitoJUnit.rule();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Captor</span></span><br><span class="line">    <span class="keyword">private</span> ArgumentCaptor&lt;List&lt;String&gt;&gt; captor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">shouldContainCertainListItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; asList = Arrays.asList(<span class="string">"someElement_test"</span>, <span class="string">"someElement"</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; mockedList = mock(List.class);</span><br><span class="line">        mockedList.addAll(asList);</span><br><span class="line"></span><br><span class="line">        verify(mockedList).addAll(captor.capture());</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; capturedArgument = captor.getValue();</span><br><span class="line">        assertThat(capturedArgument, hasItem(<span class="string">"someElement"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mockito-的限制"><a href="#Mockito-的限制" class="headerlink" title="Mockito 的限制"></a>Mockito 的限制</h3><p>Mockito 当然也有一定的限制。而下面三种数据类型则不能够被测试</p><ul><li>final classes</li><li>anonymous classes</li><li>primitive types</li></ul><h2 id="在-Android-中使用-Mockito"><a href="#在-Android-中使用-Mockito" class="headerlink" title="在 Android 中使用 Mockito"></a>在 Android 中使用 Mockito</h2><p>在 Android 中的 Gradle 构建文件中加入 Mockito 依赖后就可以直接使用 Mockito 了。若想使用 Android Instrumented tests 的话，还需要添加 dexmaker 和 dexmaker-mockito 依赖到 Gradle 的构建文件中。（需要 Mockito 1.9.5 版本以上）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="comment">// Mockito unit test 的依赖</span></span><br><span class="line">    testCompile <span class="string">'org.mockito:mockito-core:1.+'</span></span><br><span class="line">    <span class="comment">// Mockito Android instrumentation tests 的依赖</span></span><br><span class="line">    androidTestCompile <span class="string">'org.mockito:mockito-core:1.+'</span></span><br><span class="line">    androidTestCompile <span class="string">"com.google.dexmaker:dexmaker:1.2"</span></span><br><span class="line">    androidTestCompile <span class="string">"com.google.dexmaker:dexmaker-mockito:1.2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例：使用-Mockito-写一个-Instrumented-Unit-Test"><a href="#实例：使用-Mockito-写一个-Instrumented-Unit-Test" class="headerlink" title="实例：使用 Mockito 写一个 Instrumented Unit Test"></a>实例：使用 Mockito 写一个 Instrumented Unit Test</h2><h3 id="创建一个测试的-Android-应用"><a href="#创建一个测试的-Android-应用" class="headerlink" title="创建一个测试的 Android 应用"></a>创建一个测试的 Android 应用</h3><p>创建一个包名为<code>com.vogella.android.testing.mockito.contextmock</code>的 Android 应用，添加一个静态方法 ，方法里面创建一个包含参数的 Intent，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">createQuery</span><span class="params">(Context context, String query, String value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简单起见，重用MainActivity</span></span><br><span class="line">    Intent i = <span class="keyword">new</span> Intent(context, MainActivity.class);</span><br><span class="line">    i.putExtra(<span class="string">"QUERY"</span>, query);</span><br><span class="line">    i.putExtra(<span class="string">"VALUE"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-app-build-gradle-文件中添加-Mockito-依赖"><a href="#在-app-build-gradle-文件中添加-Mockito-依赖" class="headerlink" title="在 app/build.gradle 文件中添加 Mockito 依赖"></a>在 app/build.gradle 文件中添加 Mockito 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // Mockito 和 JUnit 的依赖</span><br><span class="line">    // instrumentation unit tests on the JVM</span><br><span class="line">    androidTestCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">    androidTestCompile &apos;org.mockito:mockito-core:2.0.57-beta&apos;</span><br><span class="line">    androidTestCompile &apos;com.android.support.test:runner:0.3&apos;</span><br><span class="line">    androidTestCompile &quot;com.google.dexmaker:dexmaker:1.2&quot;</span><br><span class="line">    androidTestCompile &quot;com.google.dexmaker:dexmaker-mockito:1.2&quot;</span><br><span class="line"></span><br><span class="line">    // Mockito 和 JUnit 的依赖</span><br><span class="line">    // tests on the JVM</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">    testCompile &apos;org.mockito:mockito-core:1.+&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><p>使用 Mockito 创建一个单元测试来验证在传递正确 extra data 的情况下，intent 是否被触发。</p><p>因此我们需要使用 Mockito 来 mock 一个<code>Context</code>对象，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vogella.android.testing.mockitocontextmock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertNotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextIntentCreation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntentShouldBeCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = Mockito.mock(Context.class);</span><br><span class="line">        Intent intent = MainActivity.createQuery(context, <span class="string">"query"</span>, <span class="string">"value"</span>);</span><br><span class="line">        assertNotNull(intent);</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        assertNotNull(extras);</span><br><span class="line">        assertEquals(<span class="string">"query"</span>, extras.getString(<span class="string">"QUERY"</span>));</span><br><span class="line">        assertEquals(<span class="string">"value"</span>, extras.getString(<span class="string">"VALUE"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例：使用-Mockito-创建一个-mock-对象"><a href="#实例：使用-Mockito-创建一个-mock-对象" class="headerlink" title="实例：使用 Mockito 创建一个 mock 对象"></a>实例：使用 Mockito 创建一个 mock 对象</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>创建一个 Api，它可以被 Mockito 来模拟并做一些工作</p><h3 id="创建一个-Twitter-API-的例子"><a href="#创建一个-Twitter-API-的例子" class="headerlink" title="创建一个 Twitter API 的例子"></a>创建一个 Twitter API 的例子</h3><p>实现 <code>TwitterClient</code>类，它内部使用到了 <code>ITweet</code> 的实现。但是<code>ITweet</code>实例很难得到，譬如说他需要启动一个很复杂的服务来得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITweet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwitterClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTweet</span><span class="params">(ITweet tweet)</span> </span>&#123;</span><br><span class="line">                String message = tweet.getMessage();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// send the message to Twitter</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟-ITweet-的实例"><a href="#模拟-ITweet-的实例" class="headerlink" title="模拟 ITweet 的实例"></a>模拟 ITweet 的实例</h3><p>为了能够不启动复杂的服务来得到 <code>ITweet</code>，我们可以使用 Mockito 来模拟得到该实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendingTweet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TwitterClient twitterClient = <span class="keyword">new</span> TwitterClient();</span><br><span class="line"></span><br><span class="line">        ITweet iTweet = mock(ITweet.class);</span><br><span class="line"></span><br><span class="line">        when(iTweet.getMessage()).thenReturn(<span class="string">"Using mockito is great"</span>);</span><br><span class="line"></span><br><span class="line">        twitterClient.sendTweet(iTweet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>TwitterClient</code> 可以使用 <code>ITweet</code> 接口的实现，当调用 <code>getMessage()</code> 方法的时候将会打印 “Using Mockito is great” 信息。</p><h3 id="验证方法调用"><a href="#验证方法调用" class="headerlink" title="验证方法调用"></a>验证方法调用</h3><p>确保 getMessage() 方法至少调用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendingTweet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TwitterClient twitterClient = <span class="keyword">new</span> TwitterClient();</span><br><span class="line"></span><br><span class="line">        ITweet iTweet = mock(ITweet.class);</span><br><span class="line"></span><br><span class="line">        when(iTweet.getMessage()).thenReturn(<span class="string">"Using mockito is great"</span>);</span><br><span class="line"></span><br><span class="line">        twitterClient.sendTweet(iTweet);</span><br><span class="line"></span><br><span class="line">        verify(iTweet, atLeastOnce()).getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>运行测试，查看代码是否测试通过。</p><h2 id="模拟静态方法"><a href="#模拟静态方法" class="headerlink" title="模拟静态方法"></a>模拟静态方法</h2><h3 id="使用-Powermock-来模拟静态方法"><a href="#使用-Powermock-来模拟静态方法" class="headerlink" title="使用 Powermock 来模拟静态方法"></a>使用 Powermock 来模拟静态方法</h3><p>因为 Mockito 不能够 mock 静态方法，因此我们可以使用 <code>Powermock</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalHostname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String hostname = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress addr = InetAddress.getLocalHost();</span><br><span class="line">            <span class="comment">// Get hostname</span></span><br><span class="line">            hostname = addr.getHostName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( UnknownHostException e ) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hostname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们模拟了 NetworkReader 的依赖，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.powermock.core.classloader.annotations.PrepareForTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>( PowerMockRunner.class )</span><br><span class="line"><span class="meta">@PrepareForTest</span>( NetworkReader.class )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockStatic( NetworkUtil.class );</span><br><span class="line">    when( NetworkReader.getLocalHostname() ).andReturn( <span class="string">"localhost"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 NetworkReader 协作的测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用封装的方法代替-Powermock"><a href="#用封装的方法代替-Powermock" class="headerlink" title="用封装的方法代替 Powermock"></a>用封装的方法代替 Powermock</h3><p>有时候我们可以在静态方法周围包含非静态的方法来达到和 Powermock 同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooWraper</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Foo.someStaticMethod()</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用和引申"><a href="#引用和引申" class="headerlink" title="引用和引申"></a>引用和引申</h2><ul><li><a href="https://site.mockito.org/" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/mockito/mockito" target="_blank" rel="noopener">Github</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/Unit-tests-with-Mockito.md" target="_blank" rel="noopener">使用强大的 Mockito 测试框架来测试你的代码</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mockito-快速指南&quot;&gt;&lt;a href=&quot;#mockito-快速指南&quot; class=&quot;headerlink&quot; title=&quot;mockito 快速指南&quot;&gt;&lt;/a&gt;mockito 快速指南&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Mockito 是一个针对 Jav
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站架构概述</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javaweb/architecture/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javaweb/architecture/大型网站架构概述/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大型网站架构概述"><a href="#大型网站架构概述" class="headerlink" title="大型网站架构概述"></a>大型网站架构概述</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-大型网站系统的特点">1. 大型网站系统的特点</a></li><li><a href="#2-大型网站架构演化历程">2. 大型网站架构演化历程</a><ul><li><a href="#21-初始阶段架构">2.1. 初始阶段架构</a></li><li><a href="#22-应用服务和数据服务分离">2.2. 应用服务和数据服务分离</a></li><li><a href="#23-使用缓存改善性能">2.3. 使用缓存改善性能</a></li><li><a href="#24-使用应用服务器集群">2.4. 使用应用服务器集群</a></li><li><a href="#25-数据库读写分离">2.5. 数据库读写分离</a></li><li><a href="#26-反向代理和-cdn-加速">2.6. 反向代理和 CDN 加速</a></li><li><a href="#27-分布式文件系统和分布式数据库">2.7. 分布式文件系统和分布式数据库</a></li><li><a href="#28-使用-nosql-和搜索引擎">2.8. 使用 NoSQL 和搜索引擎</a></li><li><a href="#29-业务拆分">2.9. 业务拆分</a></li><li><a href="#210-分布式服务">2.10. 分布式服务</a></li></ul></li><li><a href="#3-大型网站架构模式">3. 大型网站架构模式</a><ul><li><a href="#31-分层">3.1. 分层</a></li><li><a href="#32-分割">3.2. 分割</a></li><li><a href="#33-分布式">3.3. 分布式</a></li><li><a href="#34-集群">3.4. 集群</a></li><li><a href="#35-缓存">3.5. 缓存</a></li><li><a href="#36-异步">3.6. 异步</a></li><li><a href="#37-冗余">3.7. 冗余</a></li><li><a href="#38-自动化">3.8. 自动化</a></li><li><a href="#39-安全">3.9. 安全</a></li></ul></li><li><a href="#4-大型网站核心架构要素">4. 大型网站核心架构要素</a><ul><li><a href="#41-性能">4.1. 性能</a></li><li><a href="#42-可用性">4.2. 可用性</a></li><li><a href="#43-伸缩性">4.3. 伸缩性</a></li><li><a href="#44-扩展性">4.4. 扩展性</a></li><li><a href="#45-安全性">4.5. 安全性</a></li></ul></li><li><a href="#5-资料">5. 资料</a></li></ul><!-- /TOC --><h2 id="1-大型网站系统的特点"><a href="#1-大型网站系统的特点" class="headerlink" title="1. 大型网站系统的特点"></a>1. 大型网站系统的特点</h2><ul><li>高并发、大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛，网络情况复杂</li><li>安全环境恶劣</li><li>需求快速变更，迭代频繁</li><li>渐进式发展</li></ul><h2 id="2-大型网站架构演化历程"><a href="#2-大型网站架构演化历程" class="headerlink" title="2. 大型网站架构演化历程"></a>2. 大型网站架构演化历程</h2><h3 id="2-1-初始阶段架构"><a href="#2-1-初始阶段架构" class="headerlink" title="2.1. 初始阶段架构"></a>2.1. 初始阶段架构</h3><p>问题：网站运营初期，访问用户少，一台服务器绰绰有余。</p><p>特征：<strong>应用程序、数据库、文件等所有的资源都在一台服务器上。</strong></p><p>描述：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-初始阶段架构.jpg" width="400"><br></div><h3 id="2-2-应用服务和数据服务分离"><a href="#2-2-应用服务和数据服务分离" class="headerlink" title="2.2. 应用服务和数据服务分离"></a>2.2. 应用服务和数据服务分离</h3><p>问题：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。</p><p>特征：<strong>应用服务器、数据库服务器、文件服务器分别独立部署。</strong></p><p>描述：三台服务器对性能要求各不相同：应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；文件服务器需要存储大量文件，因此需要更大容量的硬盘。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-应用服务和数据服务分离.jpg" width="450"><br></div><h3 id="2-3-使用缓存改善性能"><a href="#2-3-使用缓存改善性能" class="headerlink" title="2.3. 使用缓存改善性能"></a>2.3. 使用缓存改善性能</h3><p>问题：随着用户逐渐增多，数据库压力太大导致访问延迟。</p><p>特征：由于网站访问和财富分配一样遵循二八定律：80% 的业务访问集中在 20% 的数据上。<strong>将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。</strong></p><p>描述：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存，本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-使用缓存改善性能.jpg" width="450"><br></div><h3 id="2-4-使用应用服务器集群"><a href="#2-4-使用应用服务器集群" class="headerlink" title="2.4. 使用应用服务器集群"></a>2.4. 使用应用服务器集群</h3><p>问题：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。</p><p>特征：<strong>多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。</strong></p><p>描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-使用应用服务器集群.jpg" width="500"><br></div><h3 id="2-5-数据库读写分离"><a href="#2-5-数据库读写分离" class="headerlink" title="2.5. 数据库读写分离"></a>2.5. 数据库读写分离</h3><p>问题：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。</p><p>特征：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。<strong>网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。</strong></p><p>描述：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-数据库读写分离.jpg" width="500"><br></div><h3 id="2-6-反向代理和-CDN-加速"><a href="#2-6-反向代理和-CDN-加速" class="headerlink" title="2.6. 反向代理和 CDN 加速"></a>2.6. 反向代理和 CDN 加速</h3><p>问题：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。</p><p>特征：<strong>采用 CDN 和反向代理加快系统的静态资源访问速度。</strong></p><p>描述：CDN 和反向代理的基本原理都是缓存，区别在于 CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-反向代理和CDN加速.jpg" width="500"><br></div><h3 id="2-7-分布式文件系统和分布式数据库"><a href="#2-7-分布式文件系统和分布式数据库" class="headerlink" title="2.7. 分布式文件系统和分布式数据库"></a>2.7. 分布式文件系统和分布式数据库</h3><p>问题：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。</p><p>特征：<strong>数据库采用分布式数据库，文件系统采用分布式文件系统。</strong></p><p>描述：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-分布式文件系统和分布式数据库.jpg"><br></div><h3 id="2-8-使用-NoSQL-和搜索引擎"><a href="#2-8-使用-NoSQL-和搜索引擎" class="headerlink" title="2.8. 使用 NoSQL 和搜索引擎"></a>2.8. 使用 NoSQL 和搜索引擎</h3><p>问题：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。</p><p>特征：<strong>系统引入 NoSQL 数据库及搜索引擎。</strong></p><p>描述：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-使用NoSQL和搜索引擎.jpg"><br></div><h3 id="2-9-业务拆分"><a href="#2-9-业务拆分" class="headerlink" title="2.9. 业务拆分"></a>2.9. 业务拆分</h3><p>问题：大型网站的业务场景日益复杂，分为多个产品线。</p><p>特征：采用分而治之的手段将整个网站业务分成不同的产品线。<strong>系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。</strong></p><p>描述：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。</p><p>纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</p><p>横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-业务拆分.jpg"><br></div><h3 id="2-10-分布式服务"><a href="#2-10-分布式服务" class="headerlink" title="2.10. 分布式服务"></a>2.10. 分布式服务</h3><p>问题：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。</p><p>特征：<strong>公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。</strong></p><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/系统架构进化-分布式服务.jpg"><br></div><h2 id="3-大型网站架构模式"><a href="#3-大型网站架构模式" class="headerlink" title="3. 大型网站架构模式"></a>3. 大型网站架构模式</h2><h3 id="3-1-分层"><a href="#3-1-分层" class="headerlink" title="3.1. 分层"></a>3.1. 分层</h3><p>大型网站架构中常采用分层结构，将软件系统分为应用层、服务层、数据层：</p><ul><li><strong>应用层</strong> - 负责具体业务和视图展示。如网站首页及搜索输入和结果展示。</li><li><strong>服务层</strong> - 为应用层提供服务支持。如用户管理服务、购物车服务等。</li><li><strong>应用层</strong> - 提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。</li></ul><p>分层架构的约束：禁止跨层次的调用（应用层直接调用数据层）及逆向调用（数据层调用服务层，或者服务层调用应用层）。</p><p>分层结构内部还可以继续分层，如应用可以再细分为视图层和业务逻辑层；服务层也可以细分为数据接口层和逻辑处理层。</p><h3 id="3-2-分割"><a href="#3-2-分割" class="headerlink" title="3.2. 分割"></a>3.2. 分割</h3><p>将不同的功能和服务分割开来，包装成高内聚低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。</p><h3 id="3-3-分布式"><a href="#3-3-分布式" class="headerlink" title="3.3. 分布式"></a>3.3. 分布式</h3><p>大于大型网站，分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同的服务器上，通过远程调用协同工作。</p><p>分布式意味可以用更多的机器工作，那么 CPU、内存、存储资源也就更丰富，能够处理的并发访问和数据量就越大，进而能够为更多的用户提供服务。</p><p>分布式也引入了一些问题：</p><ul><li>服务调用必须通过网络，网络延迟会影响性能</li><li>服务器越多，宕机概率也越大，是可用性降低</li><li>数据一致性非常困难，分布式事务也难以保证</li><li>网站依赖错综复杂，开发管理维护困难</li></ul><p>常用的分布式方案：</p><ul><li>分布式应用和服务</li><li>分布式静态资源</li><li>分布式数据和存储</li><li>分布式计算</li></ul><h3 id="3-4-集群"><a href="#3-4-集群" class="headerlink" title="3.4. 集群"></a>3.4. 集群</h3><p>集群即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。</p><p>集群需要具备伸缩性和故障转移机制：伸缩性是指可以根据用户访问量向集群添加或减少机器；故障转移是指，当某台机器出现故障时，负载均衡设备或失效转移机制将请求转发到集群中的其他机器上，从而不影响用户使用。</p><h3 id="3-5-缓存"><a href="#3-5-缓存" class="headerlink" title="3.5. 缓存"></a>3.5. 缓存</h3><p>缓存就是将数据存放在距离最近的位置以加快处理速度。缓存是改善软件性能的第一手段。</p><p>网站应用中，缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。</p><p>常见缓存手段：</p><ul><li>CDN</li><li>反向代理</li><li>本地缓存</li><li>分布式缓存</li></ul><p>使用缓存有两个前提：</p><ul><li>数据访问热点不均匀，频繁访问的数据应该放在缓存中</li><li>数据在某个时间段有效，不过很快过期，否则缓存数据会因已经失效而产生脏读</li></ul><h3 id="3-6-异步"><a href="#3-6-异步" class="headerlink" title="3.6. 异步"></a>3.6. 异步</h3><p>软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展。</p><p>大型网站架构中，系统解耦的手段除了分层、分割、分布式等，还有一个重要手段——异步。</p><p>业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。</p><ul><li>在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；</li><li>在分布式系统中，多个服务器集群通过分布式消息队列实现异步。</li></ul><p>异步架构是典型的生产者消费模式，二者不存在直接调用。异步消息队列还有如下特性：</p><ul><li>提高系统可用性</li><li>加快响应速度</li><li>消除并发访问高峰</li></ul><h3 id="3-7-冗余"><a href="#3-7-冗余" class="headerlink" title="3.7. 冗余"></a>3.7. 冗余</h3><p>大型网站，出现服务器宕机是必然事件。要保证部分服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份。这样当某台服务器宕机是，可以将其上的服务和数据访问转移到其他机器上。</p><p>访问和负载很小的服务也必须部署 至少两台服务器构成一个集群，目的就是通过冗余实现服务高可用。数据除了定期备份，存档保存，实现 <strong>冷备份</strong> 外；为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现 <strong>热备份</strong>。</p><p>为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 <strong>灾备数据中心</strong>。网站程序和数据实时同步到多个灾备数据中心。</p><h3 id="3-8-自动化"><a href="#3-8-自动化" class="headerlink" title="3.8. 自动化"></a>3.8. 自动化</h3><p>大型网站架构的自动化架构设计主要集中在发布运维方面：</p><ul><li>发布过程自动化<ul><li>自动化代码管理</li><li>自动化测试</li><li>自动化安全监测</li><li>自动化部署</li></ul></li><li>运维自动化<ul><li>自动化监控</li><li>自动化报警</li><li>自动化失效转移</li><li>自动化失效恢复</li><li>自动化降级</li><li>自动化分配资源</li></ul></li></ul><h3 id="3-9-安全"><a href="#3-9-安全" class="headerlink" title="3.9. 安全"></a>3.9. 安全</h3><ul><li><strong>密码</strong> 和 <strong>手机校验码</strong> 进行身份认证</li><li>登录、交易等重要操作需要对网络通信进行 <strong>加密</strong>，存储的敏感数据如用户信息等也进行加密处理</li><li>防止机器人程序攻击网站，使用 <strong>验证码</strong> 进行识别</li><li>对常见用于 <strong>攻击</strong> 网站的 XSS 攻击、SQL 注入、进行编码转换等相应处理</li><li>对垃圾信息、敏感信息进行 <strong>过滤</strong></li><li>对交易转账等重要操作根据交易模式和交易信息进行 <strong>风险控制</strong></li></ul><h2 id="4-大型网站核心架构要素"><a href="#4-大型网站核心架构要素" class="headerlink" title="4. 大型网站核心架构要素"></a>4. 大型网站核心架构要素</h2><p><strong>架构</strong> 的一种通俗说法是：<strong>最高层次的规划，难以改变的决定。</strong></p><p>除了系统功能需求外，架构还需要关注以下架构要素：</p><h3 id="4-1-性能"><a href="#4-1-性能" class="headerlink" title="4.1. 性能"></a>4.1. 性能</h3><p>性能问题无处不在，所以网站性能优化手段也十分繁多：</p><ul><li>前端<ul><li>浏览器缓存</li><li>静态资源压缩</li><li>合理布局页面</li><li>减少 cookie 传输</li><li>CDN</li></ul></li><li>应用服务器<ul><li>本地缓存</li><li>分布式缓存</li><li>异步消息队列</li><li>集群</li><li>代码层面：使用多线程、改善内存管理</li></ul></li><li>数据库<ul><li>索引</li><li>数据库缓存</li><li>SQL 优化</li></ul></li></ul><h3 id="4-2-可用性"><a href="#4-2-可用性" class="headerlink" title="4.2. 可用性"></a>4.2. 可用性</h3><p>可用性指部分服务器出现故障时，还能否对用户提供服务</p><ul><li>冗余<ul><li>通过负载均衡设备建立集群共同对外提供服务</li><li>数据存储在多台服务器，互相备份</li></ul></li><li>自动化：通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能</li></ul><h3 id="4-3-伸缩性"><a href="#4-3-伸缩性" class="headerlink" title="4.3. 伸缩性"></a>4.3. 伸缩性</h3><p>衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。</p><ul><li>应用服务器集群 - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可</li><li>缓存服务器集群 - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。</li><li>关系型数据库集群 - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。</li><li>NOSql 数据库集群 - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。</li></ul><h3 id="4-4-扩展性"><a href="#4-4-扩展性" class="headerlink" title="4.4. 扩展性"></a>4.4. 扩展性</h3><p>衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。主要手段有：事件驱动架构和分布式服务。</p><h3 id="4-5-安全性"><a href="#4-5-安全性" class="headerlink" title="4.5. 安全性"></a>4.5. 安全性</h3><p>安全性保护网站不受恶意攻击，保护网站重要数据不被窃取。</p><h2 id="5-资料"><a href="#5-资料" class="headerlink" title="5. 资料"></a>5. 资料</h2><ul><li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大型网站架构概述&quot;&gt;&lt;a href=&quot;#大型网站架构概述&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构概述&quot;&gt;&lt;/a&gt;大型网站架构概述&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网站的伸缩性架构</title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javaweb/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javaweb/architecture/网站的伸缩性架构/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站的伸缩性架构"><a href="#网站的伸缩性架构" class="headerlink" title="网站的伸缩性架构"></a>网站的伸缩性架构</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-网站架构的伸缩性设计">1. 网站架构的伸缩性设计</a><ul><li><a href="#11-不同功能进行物理分离实现伸缩">1.1. 不同功能进行物理分离实现伸缩</a></li><li><a href="#12-单一功能通过集群规模实现伸缩">1.2. 单一功能通过集群规模实现伸缩</a></li></ul></li><li><a href="#2-应用服务器集群的伸缩性设计">2. 应用服务器集群的伸缩性设计</a><ul><li><a href="#21-http-重定向负载均衡">2.1. HTTP 重定向负载均衡</a></li><li><a href="#22-dns-域名解析负载均衡">2.2. DNS 域名解析负载均衡</a></li><li><a href="#23-反向代理负载均衡">2.3. 反向代理负载均衡</a></li><li><a href="#24-ip-负载均衡">2.4. IP 负载均衡</a></li><li><a href="#25-数据链路层负载均衡">2.5. 数据链路层负载均衡</a></li><li><a href="#26-负载均衡算法">2.6. 负载均衡算法</a></li></ul></li><li><a href="#3-分布式缓存集群的伸缩性设计">3. 分布式缓存集群的伸缩性设计</a></li><li><a href="#4-数据存储服务器集群的伸缩性设计">4. 数据存储服务器集群的伸缩性设计</a><ul><li><a href="#41-关系型数据库的伸缩性设计">4.1. 关系型数据库的伸缩性设计</a></li><li><a href="#42-nosql-数据库的伸缩性设计">4.2. NoSql 数据库的伸缩性设计</a></li></ul></li><li><a href="#5-资料">5. 资料</a></li></ul><!-- /TOC --><h2 id="1-网站架构的伸缩性设计"><a href="#1-网站架构的伸缩性设计" class="headerlink" title="1. 网站架构的伸缩性设计"></a>1. 网站架构的伸缩性设计</h2><h3 id="1-1-不同功能进行物理分离实现伸缩"><a href="#1-1-不同功能进行物理分离实现伸缩" class="headerlink" title="1.1. 不同功能进行物理分离实现伸缩"></a>1.1. 不同功能进行物理分离实现伸缩</h3><p>纵向分离（分层后分离）：将业务处理流程上的不同部分分离部署，实现系统伸缩性。</p><p>横向分离（业务分割后分离）：将不同的业务模块分离部署，实现系统伸缩性。</p><h3 id="1-2-单一功能通过集群规模实现伸缩"><a href="#1-2-单一功能通过集群规模实现伸缩" class="headerlink" title="1.2. 单一功能通过集群规模实现伸缩"></a>1.2. 单一功能通过集群规模实现伸缩</h3><p>将不同功能分离部署可以实现一定程度的伸缩性，但是随着网站的访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。</p><h2 id="2-应用服务器集群的伸缩性设计"><a href="#2-应用服务器集群的伸缩性设计" class="headerlink" title="2. 应用服务器集群的伸缩性设计"></a>2. 应用服务器集群的伸缩性设计</h2><h3 id="2-1-HTTP-重定向负载均衡"><a href="#2-1-HTTP-重定向负载均衡" class="headerlink" title="2.1. HTTP 重定向负载均衡"></a>2.1. HTTP 重定向负载均衡</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/负载均衡-HTTP重定向.png" width="500"><br></div><p>利用 HTTP 重定向协议实现负载均衡。</p><p>这种负载均衡方案的优点是比较简单。缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 HTTP 302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</p><h3 id="2-2-DNS-域名解析负载均衡"><a href="#2-2-DNS-域名解析负载均衡" class="headerlink" title="2.2. DNS 域名解析负载均衡"></a>2.2. DNS 域名解析负载均衡</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/负载均衡-DNS域名解析.png" width="500"><br></div><p>利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。</p><p>在 DNS 服务器中配置多个 A 记录，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">114.100.40.1 www.mysite.com</span><br><span class="line">114.100.40.2 www.mysite.com</span><br><span class="line">114.100.40.3 www.mysite.com</span><br></pre></td></tr></table></figure><p>每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回，这样 A 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。</p><p>DNS 域名解析负载均衡的优点：</p><ul><li>将负载均衡的工作转交给了 DNS，省掉了网站管理维护的麻烦。</li><li>同时，许多 DNS 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。</li></ul><p>DNS 域名解析负载均衡的缺点：</p><ul><li>DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。</li><li>DNS 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。</li></ul><h3 id="2-3-反向代理负载均衡"><a href="#2-3-反向代理负载均衡" class="headerlink" title="2.3. 反向代理负载均衡"></a>2.3. 反向代理负载均衡</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/负载均衡-反向代理.png" width="500"><br></div><p>大多数反向代理服务器同时提供反向代理和负载均衡的功能。</p><p>反向代理服务器的优点是部署简单。缺点是反向代理服务器时所有请求和响应的中转站，其性能可能会成为瓶颈。</p><h3 id="2-4-IP-负载均衡"><a href="#2-4-IP-负载均衡" class="headerlink" title="2.4. IP 负载均衡"></a>2.4. IP 负载均衡</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/负载均衡-IP层.png" width="500"><br></div><p>在网络层通过修改请求目标地址进行负载均衡。负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 Web 服务器 10.0.0.1，然后将目的 IP 地址修改为 10.0.0.1，不需要通过用户进程。真实 Web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 IP 地址（114.100.80.10）发送给浏览器。</p><p>IP 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。</p><h3 id="2-5-数据链路层负载均衡"><a href="#2-5-数据链路层负载均衡" class="headerlink" title="2.5. 数据链路层负载均衡"></a>2.5. 数据链路层负载均衡</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/负载均衡-数据链路层.png" width="500"><br></div><p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p><p>这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 IP 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 IP 和负载均衡服务器 IP 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 IP 和数据请求目的 IP 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。</p><p>在 Linux 平台上最好的链路层负载均衡开源产品是 LVS(Linux Virtual Server)。</p><h3 id="2-6-负载均衡算法"><a href="#2-6-负载均衡算法" class="headerlink" title="2.6. 负载均衡算法"></a>2.6. 负载均衡算法</h3><p>负载均衡服务器的实现可以分为两个部分：</p><ol><li>根据负载均衡算法和 Web 服务器列表计算得到集群中一台 Web 服务器的地址。</li><li>将请求数据发送到该地址对应的 Web 服务器上。</li></ol><p>负载均衡算法通常有以下几种：</p><ul><li><strong>轮询（Round Robin）</strong> - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。</li><li><strong>加权轮询（Weighted Round Robin）</strong> - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。</li><li><strong>随机（Random）</strong> - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。</li><li><strong>最少连接（Least Connection）</strong> - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。</li><li><strong>源地址 Hash（Source Hash）</strong> - 根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。</li></ul><h2 id="3-分布式缓存集群的伸缩性设计"><a href="#3-分布式缓存集群的伸缩性设计" class="headerlink" title="3. 分布式缓存集群的伸缩性设计"></a>3. 分布式缓存集群的伸缩性设计</h2><p>一致性 HASH 算法</p><h2 id="4-数据存储服务器集群的伸缩性设计"><a href="#4-数据存储服务器集群的伸缩性设计" class="headerlink" title="4. 数据存储服务器集群的伸缩性设计"></a>4. 数据存储服务器集群的伸缩性设计</h2><h3 id="4-1-关系型数据库的伸缩性设计"><a href="#4-1-关系型数据库的伸缩性设计" class="headerlink" title="4.1. 关系型数据库的伸缩性设计"></a>4.1. 关系型数据库的伸缩性设计</h3><ul><li><strong>主从复制</strong> - 主流关系型数据库一般都支持主从复制。</li><li><strong>分库</strong> - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 Join 操作。</li><li><strong>分表</strong> - 使用数据库分片中间件，如 Cobar 等。</li></ul><h3 id="4-2-NoSql-数据库的伸缩性设计"><a href="#4-2-NoSql-数据库的伸缩性设计" class="headerlink" title="4.2. NoSql 数据库的伸缩性设计"></a>4.2. NoSql 数据库的伸缩性设计</h3><p>一般而言，Nosql 不支持 SQL 和 ACID，但是强化了对于高可用和伸缩性的支持。</p><h2 id="5-资料"><a href="#5-资料" class="headerlink" title="5. 资料"></a>5. 资料</h2><ul><li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网站的伸缩性架构&quot;&gt;&lt;a href=&quot;#网站的伸缩性架构&quot; class=&quot;headerlink&quot; title=&quot;网站的伸缩性架构&quot;&gt;&lt;/a&gt;网站的伸缩性架构&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Elastic 技术栈</title>
    <link href="https://dunwu.github.io/2019/03/06/os/linux/ops/service/elastic/README/"/>
    <id>https://dunwu.github.io/2019/03/06/os/linux/ops/service/elastic/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elastic-技术栈"><a href="#Elastic-技术栈" class="headerlink" title="Elastic 技术栈"></a>Elastic 技术栈</h1><blockquote><p><strong>Elastic 技术栈通常被用来作为日志中心。</strong></p><p>ELK 是 elastic 公司旗下三款产品 <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">ElasticSearch</a> 、<a href="https://www.elastic.co/products/logstash" target="_blank" rel="noopener">Logstash</a> 、<a href="https://www.elastic.co/products/kibana" target="_blank" rel="noopener">Kibana</a> 的首字母组合。</p><p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">ElasticSearch</a> 是一个基于 <a href="http://lucene.apache.org/core/documentation.html" target="_blank" rel="noopener">Lucene</a> 构建的开源，分布式，RESTful 搜索引擎。</p><p><a href="https://www.elastic.co/products/logstash" target="_blank" rel="noopener">Logstash</a> 传输和处理你的日志、事务或其他数据。</p><p><a href="https://www.elastic.co/products/kibana" target="_blank" rel="noopener">Kibana</a> 将 Elasticsearch 的数据分析并渲染为可视化的报表。</p><p>Elastic 技术栈，在 ELK 的基础上扩展了一些新的产品，如：<a href="https://www.elastic.co/products/beats" target="_blank" rel="noopener">Beats</a> 、<a href="https://www.elastic.co/products/x-pack" target="_blank" rel="noopener">X-Pack</a> 。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="elastic-quickstart.md">Elastic 技术栈之快速指南</a></p><p><a href="elastic-logstash.md">Elastic 技术栈之 Logstash 基础</a></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><strong>官方资源</strong></p><p><a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">Elastic 官方文档</a></p><p><strong>第三方工具</strong></p><p><a href="https://github.com/logstash/logstash-logback-encoder" target="_blank" rel="noopener">logstash-logback-encoder</a></p><p><strong>教程</strong></p><p><a href="https://es.xiaoleilu.com/index.html" target="_blank" rel="noopener">Elasticsearch 权威指南（中文版）</a></p><p><a href="https://github.com/chenryn/logstash-best-practice-cn" target="_blank" rel="noopener">ELK Stack权威指南</a></p><p><strong>博文</strong></p><p><a href="https://www.cnblogs.com/xing901022/p/4704319.html" target="_blank" rel="noopener">Elasticsearch+Logstash+Kibana教程</a></p><p><a href="https://github.com/judasn/Linux-Tutorial/blob/master/ELK-Install-And-Settings.md" target="_blank" rel="noopener">ELK（Elasticsearch、Logstash、Kibana）安装和配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Elastic-技术栈&quot;&gt;&lt;a href=&quot;#Elastic-技术栈&quot; class=&quot;headerlink&quot; title=&quot;Elastic 技术栈&quot;&gt;&lt;/a&gt;Elastic 技术栈&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Elastic 技术栈通常
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://dunwu.github.io/2019/03/06/database/README/"/>
    <id>https://dunwu.github.io/2019/03/06/database/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><blockquote><p>:dart: 所有配套源码整理归档在 <a href="https://github.com/dunwu/db-tutorial" target="_blank" rel="noopener"><strong>db-tutorial</strong></a> 项目中。</p></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><ul><li><a href="sql">关系型数据库</a></li><li><a href="nosql">非关系型数据库</a></li></ul><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;:dart: 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/dunwu/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统设计</title>
    <link href="https://dunwu.github.io/2019/03/06/design/README/"/>
    <id>https://dunwu.github.io/2019/03/06/design/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统设计&quot;&gt;&lt;a href=&quot;#系统设计&quot; class=&quot;headerlink&quot; title=&quot;系统设计&quot;&gt;&lt;/a&gt;系统设计&lt;/h1&gt;&lt;h2 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;资源&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端技术</title>
    <link href="https://dunwu.github.io/2019/03/06/frontend/README/"/>
    <id>https://dunwu.github.io/2019/03/06/frontend/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h1><blockquote><p>:dart: 所有配套源码整理归档在 <a href="https://github.com/dunwu/frontend-tutorial" target="_blank" rel="noopener"><strong>frontend-tutorial</strong></a> 项目中。</p></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><blockquote><p>前端 web 技术的基石： <code>html</code> + <code>css</code> + <code>js</code></p><ul><li>HTML 定义了网页的内容。</li><li>CSS 定义了网页的样式。</li><li>JavaScript 定义了网页的行为。</li></ul></blockquote><ul><li><a href="base/html.md">Html</a></li><li><a href="base/css.md">Css</a></li><li><a href="base/js.md">Javascript</a></li></ul><h3 id="Nodejs-Npm-Yarn"><a href="#Nodejs-Npm-Yarn" class="headerlink" title="Nodejs, Npm, Yarn"></a>Nodejs, Npm, Yarn</h3><blockquote><p>Nodejs 和包管理器</p><p>流行： <code>npm</code>, <code>yarn</code></p></blockquote><ul><li><a href="nodejs/nodejs.md">Nodejs</a> - 关键词： <code>nodejs</code>, <code>REPL</code>， <code>require</code>, <code>exports</code></li><li><a href="nodejs/npm.md">Npm</a> - 关键词： <code>nodejs</code>, <code>包管理</code>, <code>npm</code>, <code>cnpm</code>, <code>package.json</code>, <code>node_modules</code></li><li><a href="nodejs/yarn.md">Yarn</a> - 关键词： <code>nodejs</code>, <code>包管理</code>, <code>yarn</code>, <code>yarn.lock</code></li></ul><h3 id="ES6-TypeScript-Babel"><a href="#ES6-TypeScript-Babel" class="headerlink" title="ES6, TypeScript, Babel"></a>ES6, TypeScript, Babel</h3><blockquote><p>下一代 Javascript 语言</p></blockquote><ul><li><a href="es6/ES6.md">ES6</a> - 关键词： <code>ES6</code>, <code>ECMAScript</code>, <code>arrow</code>, <code>this</code>, <code>let</code>, <code>const</code>, <code>class</code>, <code>extends</code>, <code>super</code>, <code>arrow</code> …</li><li><a href="es6/babel.md">Babel</a> - 关键词： <code>babel-cli</code>, <code>.babelrc</code>, <code>preset</code>, <code>polyfill</code></li><li><a href="es6/typescript.md">TypeScript</a> - 关键词： <code>typescript</code>, <code>tsc</code></li></ul><h3 id="Bundlers"><a href="#Bundlers" class="headerlink" title="Bundlers"></a>Bundlers</h3><blockquote><p>捆绑资源管理器</p><p>流行： <code>Webpack</code></p></blockquote><ul><li><a href="webpack/webpack.md">Webpack 入门</a></li><li><a href="webpack/concept.md">Webpack 概念</a></li><li><a href="webpack/asset-management.md">Webpack 资源管理</a></li><li><a href="webpack/code-splitting.md">Webpack 代码分离</a></li><li><a href="webpack/development.md">Webpack 开发工具</a></li></ul><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><blockquote><p>静态检查工具、代码格式化工具</p><p>流行： <code>JSLint</code>, <code>JSHint</code>, <code>ESLint</code>, <code>Prettier</code>, <code>Standard</code>, <code>TSlint</code></p></blockquote><ul><li><a href="qa/qa-summary.md">JavaScript QA 工具总结</a></li><li><a href="qa/eslint.md">eslint</a></li></ul><h3 id="MVC-React-Vue-Angular"><a href="#MVC-React-Vue-Angular" class="headerlink" title="MVC - React, Vue, Angular"></a>MVC - React, Vue, Angular</h3><ul><li><a href="mvc/Angular,React,Vue比较.md">Angular,React,Vue 比较</a></li></ul><h4 id="React-技术栈"><a href="#React-技术栈" class="headerlink" title="React 技术栈"></a>React 技术栈</h4><ul><li><a href="mvc/react/react.md">React</a></li></ul><h4 id="Vue-技术栈"><a href="#Vue-技术栈" class="headerlink" title="Vue 技术栈"></a>Vue 技术栈</h4><h4 id="Angular-技术栈"><a href="#Angular-技术栈" class="headerlink" title="Angular 技术栈"></a>Angular 技术栈</h4><ul><li><a href="mvc/angular/angular.md">Angular</a></li></ul><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端技术&quot;&gt;&lt;a href=&quot;#前端技术&quot; class=&quot;headerlink&quot; title=&quot;前端技术&quot;&gt;&lt;/a&gt;前端技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;:dart: 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/du
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://dunwu.github.io/2019/03/06/network/README/"/>
    <id>https://dunwu.github.io/2019/03/06/network/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p></blockquote><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/network.jpg"></div><br></p><h2 id="bulb-指南"><a href="#bulb-指南" class="headerlink" title=":bulb: 指南"></a>:bulb: 指南</h2><p>学习之前，先看一下入门三问：</p><blockquote><p><strong>一、什么是计算机网络？</strong></p><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p><p>——摘自百度百科</p></blockquote><blockquote><p><strong>二、为什么学习计算机网络？</strong></p><p>计算机网络是计算机科学的基础课程，也是计算机专业考研必考科目，可见其重要性。作为一名程序员，了解计算机网络，对于 Web 领域，通信领域的开发有莫大的帮助。</p><p>在浏览器中访问网页的原理是什么？Wifi 是如何工作的？防火墙是如何保障网络安全的？什么是安全证书？Cookie 和 Session 是什么东西？。。。</p><p>如果你接触过这些技术，如果你想了解这些技术的原理，那么你就有必要学习一下计算机网络了。</p></blockquote><blockquote><p><strong>三、如何学习计算机网络？</strong></p><p>本人有 2 年通信领域开发经验，从事通信设备上的协议开发。就我个人的学习经验来看，学习计算机网络可以分为以下阶段：</p><ul><li><strong>基础阶段——一般性的了解网络协议分层及各层功能</strong><ul><li>了解计算机网络协议分层（OSI）有哪些层，分层的依据是什么（即每层的功能是什么）</li><li>了解每层的主要通信设备有哪些；</li><li>了解每层有哪些重要网络协议，这些协议有什么作用，基本原理是什么？</li><li>了解每层的传输数据形式（如：报文、帧等）</li></ul></li><li><strong>进阶阶段——系统学习计算机网络知识，将各层主要协议功能串联起来</strong><ul><li>学习 TCP/IP 详解 卷 1、卷 2、卷 3（内容详实，但文字较为晦涩，不适合初学者）</li></ul></li><li><strong>专业阶段——根据业务领域，有针对性的学习</strong><ul><li>网络协议很多，而且专业性非常强。精通所有协议，几乎是不可能的，所以有必要根据自己的业务领域，有针对性的深入学习协议。如果你是做 web 开发，那么你很有必要认真学习一下 HTTP、DNS 协议；如果你是做路由器、交换机领域通信开发，那么你应该更深入学习一下 IP/TCP/UDP 协议。。。</li><li>如何深入学习协议，最好的学习方式，就是深入学习 RFC，并结合实际的协议报文去了解。</li></ul></li></ul></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><ul><li><a href="network-guide.md">计算机网络指南</a> - 关键词：核心概念、拓扑结构、作用范围、性能指标、体系结构</li><li><a href="physical">物理层</a> - 关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li><li><a href="data-link-layer.md">数据链路层</a> - 关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li><li><a href="network">网络层</a> - 关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li><li><a href="transport">传输层</a> - 关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li><li><a href="application">应用层</a> - 关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li></ul><h2 id="books-学习资源"><a href="#books-学习资源" class="headerlink" title=":books: 学习资源"></a>:books: 学习资源</h2><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><ul><li>谢希仁, 计算机网络 - 国内很多大学将其作为计算机网络课程的指定教材，通俗易懂，适合作为入门教材。</li><li>W·Richard Stevens, <a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP 详解 卷 1：协议</a> - TCP/IP 详解三部曲，适合作为进阶教材</li><li>W·Richard Stevens, <a href="https://book.douban.com/subject/1087767/" target="_blank" rel="noopener">TCP/IP 详解 卷 2：实现</a></li><li>W·Richard Stevens, <a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP 详解 卷 3：TCP 事务协议、HTTP、NNTP 和 UNIX 域协议</a></li></ul><h3 id="站点"><a href="#站点" class="headerlink" title="站点"></a>站点</h3><ul><li><a href="https://www.rfc-editor.org/" target="_blank" rel="noopener">https://www.rfc-editor.org/</a> - 在线查阅、下载 RFC 文档</li></ul><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络指南</title>
    <link href="https://dunwu.github.io/2019/03/06/network/network-guide/"/>
    <id>https://dunwu.github.io/2019/03/06/network/network-guide/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络指南"><a href="#计算机网络指南" class="headerlink" title="计算机网络指南"></a>计算机网络指南</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#核心概念">核心概念</a></li><li><a href="#拓扑结构">拓扑结构</a></li><li><a href="#作用范围">作用范围</a></li><li><a href="#性能指标">性能指标</a></li><li><a href="#体系结构">体系结构</a></li></ul><!-- /TOC --><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>计算机网络</strong> - 计算机网络（computer network），通常也简称网络，是利用通信设备和线路将地理位置不同的、功能独立的多个<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F" target="_blank" rel="noopener">计算机</a>系统连接起来，以功能完善的网络<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">软件</a>实现网络的<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6" target="_blank" rel="noopener">硬件</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6" target="_blank" rel="noopener">软件</a>及资源<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB" target="_blank" rel="noopener">共享</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">信息</a>传递的系统。简单的说即连接两台或多台计算机进行<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">通信</a>的系统。</li><li><strong>互联网</strong> - 互联网（Internet），即网络的网络。</li></ul><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>计算机网络的拓扑结构可分为：</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/overview/network-topological-structure.gif"></div><br></p><ul><li>网型拓扑网型网（Mesh network）</li><li>环型拓扑环型网（Ring network）</li><li>星型拓扑星型网（Star network）</li><li>树状拓扑树型网（Tree network）</li><li>总线拓扑总线网（Bus network）</li></ul><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><ul><li>广域网 WAN（Wide Area Network）</li><li>城域网 MAN（Metropolitan Area Network）</li><li>局域网 LAN（Local Area Network）</li><li>个人区域网 PAN（Personal Area Network）</li></ul><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ul><li><strong>速率</strong> - 速率的单位是 bit/s（比特每秒）。</li><li><strong>带宽（bandwidth）</strong> - 带宽有以下两种不同的意义。<ul><li>信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫 （或千赫，兆赫，吉赫等）。</li><li>网络的带宽表示在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>。这种意义的带宽的单位是 bit/s（比特每秒）。</li></ul></li><li><strong>吞吐量（throughput）</strong> - 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。例如，对于一个 100 Mbit/s 的以太网，其额定速率是 100 Mbit/s。</li><li><strong>时延（delay）</strong><ul><li>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</li></ul></li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/overview/network-layers.png"></div><br></p><ul><li><strong>物理层（Physical Layer）</strong> - 物理层只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。<ul><li>数据单元：比特流。</li><li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li></ul></li><li><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<ul><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul></li><li><strong>网络层（network layer）</strong> - 为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。<ul><li>主要协议：<code>IP</code>。</li><li>数据单元：IP 数据报（packet）。</li><li>典型设备：网关、路由器。</li></ul></li><li><strong>传输层（transport layer）</strong> - 为两台主机中进程间的通信提供通用的数据传输服务。<ul><li>主要协议：<code>TCP</code>、<code>UDP</code>。</li><li>数据单元：报文段（segment）或用户数据报。</li></ul></li><li><strong>会话层（Session Layer）</strong> - 会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。</li><li><strong>表示层（Presentation Layer）</strong> - 表示层是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。</li><li><strong>应用层（application layer）</strong> - 通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。<ul><li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li><li>数据单元：报文（message）。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络指南&quot;&gt;&lt;a href=&quot;#计算机网络指南&quot; class=&quot;headerlink&quot; title=&quot;计算机网络指南&quot;&gt;&lt;/a&gt;计算机网络指南&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://dunwu.github.io/2019/03/06/os/README/"/>
    <id>https://dunwu.github.io/2019/03/06/os/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>:dart: 所有配套源码整理归档在 <a href="https://github.com/dunwu/os-tutorial" target="_blank" rel="noopener"><strong>os-tutorial</strong></a> 项目中。</p></blockquote><h2 id="memo-知识点"><a href="#memo-知识点" class="headerlink" title=":memo: 知识点"></a>:memo: 知识点</h2><ul><li><a href="linux">Linux</a></li><li><a href="windows">Windows</a></li><li><a href="docker">Docker</a></li></ul><h2 id="books-学习资源"><a href="#books-学习资源" class="headerlink" title=":books: 学习资源"></a>:books: 学习资源</h2><h2 id="door-传送门"><a href="#door-传送门" class="headerlink" title=":door: 传送门"></a>:door: 传送门</h2><p>| <a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;:dart: 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/du
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><blockquote><p>:coffee: <strong>编程语言</strong></p><p>任何建筑都是一砖一瓦的堆砌，任何软件都是通过编程语言一行一行编写的。每种编程语言都有自身的优缺点，有适合的应用场景。编程语言那么多，人生苦胆，不可能全部掌握。但是，作为程序员，至少应该精通一门高级编程语言，一门脚本语言。所谓一通百通，万变不离其宗，精通一两门编程语言后，自然会发现语言之间也有很多相似性。</p></blockquote><ul><li><a href="java">Java</a></li><li><a href="python.md">Python</a></li><li><a href="shell.md">Shell</a> - 关键词：解释器、注释、变量、Shell 扩展、数组、运算符、语句、函数、流和重定向、Debugging</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编程语言&quot;&gt;&lt;a href=&quot;#编程语言&quot; class=&quot;headerlink&quot; title=&quot;编程语言&quot;&gt;&lt;/a&gt;编程语言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;:coffee: &lt;strong&gt;编程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何建筑都是一砖一瓦的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>目录规范</title>
    <link href="https://dunwu.github.io/2019/03/06/style/dir-style/"/>
    <id>https://dunwu.github.io/2019/03/06/style/dir-style/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-目录结构规范">1. 目录结构规范</a></li><li><a href="#2-文件管理软件">2. 文件管理软件</a><ul><li><a href="#21-clover">2.1. Clover</a></li><li><a href="#22-everything">2.2. Everything</a></li><li><a href="#23-wox">2.3. Wox</a></li><li><a href="#24-q-dir">2.4. Q-dir</a></li></ul></li></ul><!-- /TOC --><h2 id="1-目录结构规范"><a href="#1-目录结构规范" class="headerlink" title="1. 目录结构规范"></a>1. 目录结构规范</h2><blockquote><p>作为程序员，想必每个人都会有大量的资料、数据。按照条理清晰的目录结构去分类化存储，十分有助于管理文件。</p></blockquote><p>以下是我个人整理的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Codes           #代码目录</span><br><span class="line">│   ├── Other       #第三方代码目录</span><br><span class="line">│   ├── My          #个人代码目录</span><br><span class="line">│   └── Work        #工作代码目录</span><br><span class="line">├── Data            #数据目录</span><br><span class="line">├── Downloads       #下载文件目录</span><br><span class="line">├── Docs            #文档目录</span><br><span class="line">│   ├── Books       #电子书目录</span><br><span class="line">│   ├── My          #个人文档目录</span><br><span class="line">│   └── Work        #工作文档目录</span><br><span class="line">├── Movies          #视频目录</span><br><span class="line">├── Music           #音乐目录</span><br><span class="line">├── Pictures        #图片目录</span><br><span class="line">├── Public          #共享目录</span><br><span class="line">├── Temp            #临时文件目录</span><br><span class="line">└── Tools           #工具软件目录</span><br><span class="line">    └── Packages    #安装包目录</span><br></pre></td></tr></table></figure><p>注：如果您使用的操作系统是 Mac 这种可以为目录或文件添加 tag 的操作系统，那么您可以根据自己的喜好更细致化的管理。</p><h2 id="2-文件管理软件"><a href="#2-文件管理软件" class="headerlink" title="2. 文件管理软件"></a>2. 文件管理软件</h2><blockquote><p>选用便利的文件管理软件，可以让你的文件管理如虎添翼。这里推荐几款经典的文件管理工具。</p></blockquote><h3 id="2-1-Clover"><a href="#2-1-Clover" class="headerlink" title="2.1. Clover"></a>2.1. Clover</h3><blockquote><p><a href="http://cn.ejie.me/" target="_blank" rel="noopener">Clover</a> 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。</p></blockquote><div align="center"><br><img src="http://cn.ejie.me/images/clover.jpg" width="640"><br></div><h3 id="2-2-Everything"><a href="#2-2-Everything" class="headerlink" title="2.2. Everything"></a>2.2. Everything</h3><blockquote><p><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> 可以立即在 windows 系统中找到制定名称的文件和文件夹。</p></blockquote><div align="center"><br><img src="http://www.voidtools.com/sssmall2.gif" width="640"><br></div><h3 id="2-3-Wox"><a href="#2-3-Wox" class="headerlink" title="2.3. Wox"></a>2.3. Wox</h3><blockquote><p><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">Wox</a> 是一款简单易用的 Windows 启动器。可以把它视为 windows 版的 Alfred。</p></blockquote><div align="center"><br><img src="https://camo.githubusercontent.com/9db33546d3a905a9ad915e0948d3ba3f47f57b64/687474703a2f2f692e696d6775722e636f6d2f4474784e424a692e676966" width="640"><br></div><h3 id="2-4-Q-dir"><a href="#2-4-Q-dir" class="headerlink" title="2.4. Q-dir"></a>2.4. Q-dir</h3><blockquote><p><a href="http://www.softpedia.com/get/File-managers/Q-Dir.shtml" target="_blank" rel="noopener">Q-dir</a> 是轻量的文件管理器,特点鲜明,各种布局视图切换灵活,默认四个小窗口组成一个大窗口,操作快捷。</p></blockquote><div align="center"><br><img src="http://i1-win.softpedia-static.com/screenshots/q-dir_1.png" width="640"><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目录规范&quot;&gt;&lt;a href=&quot;#目录规范&quot; class=&quot;headerlink&quot; title=&quot;目录规范&quot;&gt;&lt;/a&gt;目录规范&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-目录结构规范&quot;&gt;1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>命令行的艺术</title>
    <link href="https://dunwu.github.io/2019/03/06/os/linux/cli/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://dunwu.github.io/2019/03/06/os/linux/cli/命令行的艺术/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:46.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自 <a href="https://github.com/jlevy/the-art-of-command-line" target="_blank" rel="noopener">https://github.com/jlevy/the-art-of-command-line</a> </p></blockquote><p><em><a href="README-cs.md">Čeština</a> ∙ <a href="README-de.md">Deutsch</a> ∙ <a href="README-el.md">Ελληνικά</a> ∙ <a href="../README.md">English</a> ∙ <a href="README-es.md">Español</a> ∙ <a href="README-fr.md">Français</a> ∙ <a href="README-id.md">Indonesia</a> ∙ <a href="README-it.md">Italiano</a> ∙ <a href="README-ja.md">日本語</a> ∙ <a href="README-ko.md">한국어</a> ∙ <a href="README-pt.md">Português</a> ∙ <a href="README-ro.md">Română</a> ∙ <a href="README-ru.md">Русский</a> ∙ <a href="README-sl.md">Slovenščina</a> ∙ <a href="README-uk.md">Українська</a> ∙ <a href="README-zh.md">简体中文</a> ∙ <a href="README-zh-Hant.md">繁體中文</a></em></p><h1 id="命令行的艺术"><a href="#命令行的艺术" class="headerlink" title="命令行的艺术"></a>命令行的艺术</h1><p><br><div align="center"><img src="https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge"></div><br></p><ul><li><a href="#前言">前言</a></li><li><a href="#基础">基础</a></li><li><a href="#日常使用">日常使用</a></li><li><a href="#文件及数据处理">文件及数据处理</a></li><li><a href="#系统调试">系统调试</a></li><li><a href="#单行脚本">单行脚本</a></li><li><a href="#冷门但有用">冷门但有用</a></li><li><a href="#仅限-os-x-系统">仅限 OS X 系统</a></li><li><a href="#仅限-windows-系统">仅限 Windows 系统</a></li><li><a href="#更多资源">更多资源</a></li><li><a href="#免责声明">免责声明</a></li></ul><p><br><div align="center"><img src="https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/cowsay.png"></div><br></p><p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p><p>这篇文章是<a href="AUTHORS.md">许多作者和译者</a>共同的成果。<br>这里的部分内容<br><a href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands" target="_blank" rel="noopener">首次</a><br><a href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix" target="_blank" rel="noopener">出现</a><br>于 <a href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know" target="_blank" rel="noopener">Quora</a>，<br>但已经迁移到了 Github，并由众多高手做出了许多改进。<br>如果你在本文中发现了错误或者存在可以改善的地方，请<a href="/CONTRIBUTING.md"><strong>贡献你的一份力量</strong></a>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>涵盖范围：</p><ul><li>这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到<em>覆盖面广</em>（涉及所有重要的内容），<em>具体</em>（给出具体的最常用的例子），以及<em>简洁</em>（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。</li><li>本文主要为 Linux 所写，但在<a href="#仅限-os-x-系统">仅限 OS X 系统</a>章节和<a href="#仅限-windows-系统">仅限 Windows 系统</a>章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。</li><li>本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。</li><li>除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。</li></ul><p>注意事项：</p><ul><li>为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code>，<code>pacman</code>，<br><code>pip</code> 或 <code>brew</code>（以及其它合适的包管理器）来安装依赖的程序。</li><li>遇到问题的话，请尝试使用 <a href="http://explainshell.com/" target="_blank" rel="noopener">Explainshell</a> 去获取相关命令、参数、管道等内容的解释。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>学习 Bash 的基础知识。具体地，在命令行中输入 <code>man bash</code> 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你<em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。</p></li><li><p>熟悉至少一个基于文本的编辑器。通常而言 Vim （<code>vi</code>） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。</p></li><li><p>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。你可以用 <code>type 命令</code> 来判断这个命令到底是可执行文件、shell 内置命令还是别名。</p></li><li><p>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。</p></li><li><p>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别（后文中有一些具体的例子）。</p></li><li><p>熟悉 Bash 中的任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</p></li><li><p>学会使用 <code>ssh</code> 进行远程命令行登录，最好知道如何使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基础的无密码认证登录。</p></li><li><p>学会基本的文件管理工具：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</p></li><li><p>学习基本的网络管理工具：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</p></li><li><p>学习并使用一种版本控制管理系统，例如 <code>git</code>。</p></li><li><p>熟悉正则表达式，学会使用 <code>grep</code>／<code>egrep</code>，它们的参数中 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code> 这些是很常用并值得认真学习的。</p></li><li><p>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</p></li></ul><h2 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h2><ul><li><p>在 Bash 中，可以通过按 <strong>Tab</strong> 键实现自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 <strong>ctrl-r</strong> 会向后查找匹配项，按下 <strong>Enter</strong> 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。</p></li><li><p>在 Bash 中，可以按下 <strong>ctrl-w</strong> 删除你键入的最后一个单词，<strong>ctrl-u</strong> 可以删除行内光标所在位置之前的内容，<strong>alt-b</strong> 和 <strong>alt-f</strong> 可以以单词为单位移动光标，<strong>ctrl-a</strong> 可以将光标移至行首，<strong>ctrl-e</strong> 可以将光标移至行尾，<strong>ctrl-k</strong> 可以删除光标至行尾的所有内容，<strong>ctrl-l</strong> 可以清屏。键入 <code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <strong>alt-.</strong> 循环地移向前一个参数，而 <strong>alt-*</strong> 可以展开通配符。</p></li></ul><ul><li><p>你喜欢的话，可以执行 <code>set -o vi</code> 来使用 vi 风格的快捷键，而执行 <code>set -o emacs</code> 可以把它改回来。</p></li><li><p>为了便于编辑长命令，在设置你的默认编辑器后（例如 <code>export EDITOR=vim</code>），<strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 <strong>escape-v</strong>。</p></li><li><p>键入 <code>history</code> 查看命令行历史记录，再用 <code>!n</code>（<code>n</code> 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 <code>!$</code>， 它用于指代上次键入的参数，而 <code>!!</code> 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 来实现。</p></li><li><p><code>cd</code> 命令可以切换工作路径，输入 <code>cd \~</code> 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 <code>\~</code>（例如 <code>\~/.bashrc</code>）。在 <code>sh</code> 脚本里则用环境变量 <code>$HOME</code> 指代 home 目录的路径。</p></li><li><p>回到前一个工作路径：<code>cd -</code>。</p></li><li><p>如果你输入命令的时候中途改了主意，按下 <strong>alt-#</strong> 在行首添加 <code>#</code> 把它当做注释再按下回车执行（或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。</p></li><li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I{}</code> 会很方便。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.py'</span> | xargs grep some_function</span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure></li><li><p><code>pstree -p</code> 以一种优雅的方式展示进程树。</p></li><li><p>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</p></li><li><p>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</p></li><li><p>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</p></li><li><p>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 <code>-u</code> 则检查 UDP 端口）或者 <code>lsof -iTCP -sTCP:LISTEN -P -n</code> (这也可以在 OS X 上运行)。</p></li><li><p><code>lsof</code> 来查看开启的套接字和文件。</p></li><li><p>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</p></li><li><p>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 创建了一个新的命令别名 <code>ll</code>。</p></li><li><p>可以把别名、shell 选项和常用函数保存在 <code>\~/.bashrc</code>，具体看下这篇<a href="http://superuser.com/a/183980/7106" target="_blank" rel="noopener">文章</a>。这样做的话你就可以在所有 shell 会话中使用你的设定。</p></li><li><p>把环境变量的设定以及登陆时要执行的命令保存在 <code>\~/.bash_profile</code>。而对于从图形界面启动的 shell 和 <code>cron</code> 启动的 shell，则需要单独配置文件。</p></li><li><p>要想在几台电脑中同步你的配置文件（例如 <code>.bashrc</code> 和 <code>.bash_profile</code>），可以借助 Git。</p></li><li><p>当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 <code>&quot;$FOO&quot;</code>。尽量使用 <code>-0</code> 或 <code>-print0</code> 选项以便用 NULL 来分隔文件名，例如 <code>locate -0 pattern | xargs -0 ls -al</code> 或 <code>find / -print0 -type d | xargs -0 ls -al</code>。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 <code>IFS=$&#39;\n&#39;</code> 把内部字段分隔符设为换行符。</p></li><li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出（或者使用它的变体 <code>set -v</code>，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行；使用 <code>set -u</code> 来检查是否使用了未赋值的变量；试试 <code>set -o pipefail</code>，它可以监测管道中的错误。当牵扯到很多脚本时，使用 <code>trap</code> 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo 'error: Script failed: see failed command above'"</span> ERR</span><br></pre></td></tr></table></figure></li><li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure></li><li><p>在 Bash 中，变量有许多的扩展方式。<code>${name:?error message}</code> 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 <code>input_file=${1:?usage: $0 input_file}</code>。在变量为空时使用默认值：<code>${name:-default}</code>。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 <code>output_file=${2:-logfile}</code>，如果省略了 $2，它的值就为空，于是 <code>output_file</code> 就会被设为 <code>logfile</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>{1..10}</code>。截断字符串：<code>${var%suffix}</code> 和 <code>${var#prefix}</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo ${var%.pdf}.txt</code> 将输出 <code>foo.txt</code>。</p></li><li><p>使用括号扩展（<code>{</code>…<code>}</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.{txt,pdf} some-dir</code>（同时移动两个文件），<code>cp somefile{,.bak}</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p></li><li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br></pre></td></tr></table></figure></li><li><p>编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="comment"># 在这里写代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p></li><li><p>在 Bash 中，同时重定向标准输出和标准错误：<code>some-command &gt;logfile 2&gt;&amp;1</code> 或者 <code>some-command &amp;&gt;logfile</code>。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 <code>&lt;/dev/null</code> 是一个好习惯。</p></li><li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p></li><li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/" target="_blank" rel="noopener"><code>tmux</code></a> 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 <code>byobu</code> 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 <a href="https://github.com/bogner/dtach" target="_blank" rel="noopener"><code>dtach</code></a>。</p></li><li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。</p></li><li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>\~/.ssh/config</code> 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive=yes</span><br><span class="line">ServerAliveInterval=15</span><br><span class="line">ServerAliveCountMax=6</span><br><span class="line">Compression=yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/%r@%h:%p</span><br><span class="line">ControlPersist yes</span><br></pre></td></tr></table></figure></li><li><p>一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 <code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code>。</p></li><li><p>考虑使用 <a href="https://mosh.mit.edu/" target="_blank" rel="noopener"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。</p></li><li><p>获取八进制形式的文件访问权限（修改系统设置时通常需要，但 <code>ls</code> 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> -c <span class="string">'%A %a %n'</span> /etc/timezone</span><br></pre></td></tr></table></figure></li><li><p>使用 <a href="https://github.com/mooz/percol" target="_blank" rel="noopener"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p></li><li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker" target="_blank" rel="noopener">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p></li><li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p></li><li><p>以其他用户的身份执行命令，使用 <code>sudo</code>。默认以 root 用户的身份执行；使用 <code>-u</code> 来指定其他用户。使用 <code>-i</code> 来以该用户登录（需要输入<em>你自己的</em>密码）。</p></li><li><p>将 shell 切换为其他用户，使用 <code>su username</code> 或者 <code>sudo - username</code>。加入 <code>-</code> 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入<em>哪个用户的</em>密码。</p></li><li><p>了解命令行的 <a href="https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong" target="_blank" rel="noopener">128K 限制</a>。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 <code>find</code> 或 <code>xargs</code> 通常可以解决。）</p></li><li><p>当你需要一个基本的计算器时，可以使用 <code>python</code> 解释器（当然你要用 python 的时候也是这样）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2+3</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件及数据处理"><a href="#文件及数据处理" class="headerlink" title="文件及数据处理"></a>文件及数据处理</h2><ul><li><p>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：<code>find . -iname &#39;*something*&#39;</code>。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但注意到 <code>updatedb</code> 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。</p></li><li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="noopener"><code>ag</code></a> 在源代码或数据文件里检索（<code>grep -r</code> 同样可以做到，但相比之下 <code>ag</code> 更加先进）。</p></li><li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code>。</p></li><li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/" target="_blank" rel="noopener"><code>pandoc</code></a>。</p></li><li><p>当你要处理棘手的 XML 时候，<code>xmlstarlet</code> 算是上古时代流传下来的神器。</p></li><li><p>使用 <a href="http://stedolan.github.io/jq/" target="_blank" rel="noopener"><code>jq</code></a> 处理 JSON。</p></li><li><p>使用 <a href="https://github.com/0k/shyaml" target="_blank" rel="noopener"><code>shyaml</code></a> 处理 YAML。</p></li><li><p>要处理 Excel 或 CSV 文件的话，<a href="https://github.com/onyxfish/csvkit" target="_blank" rel="noopener">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等方便易用的工具。</p></li><li><p>当你要处理 Amazon S3 相关的工作的时候，<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="noopener"><code>s3cmd</code></a> 是一个很方便的工具而 <a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="noopener"><code>s4cmd</code></a> 的效率更高。Amazon 官方提供的 <a href="https://github.com/aws/aws-cli" target="_blank" rel="noopener"><code>aws</code></a> 以及  <a href="https://github.com/donnemartin/saws" target="_blank" rel="noopener"><code>saws</code></a> 是其他 AWS 相关工作的基础，值得学习。</p></li><li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，具体内容在后文单行脚本节中。另外可以了解一下 <code>comm</code>。</p></li><li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但遗忘了 <code>join</code>。</p></li><li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p></li><li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p></li><li><p>要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 <a href="https://www.gnu.org/software/datamash/" target="_blank" rel="noopener"><code>datamash</code></a>。</p></li><li><p>注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并按照字节来判断顺序。</p></li><li><p>你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 <code>TZ=Pacific/Fiji date</code> 可以获取斐济的时间。</p></li><li><p>了解如何使用 <code>awk</code> 和 <code>sed</code> 来进行简单的数据处理。 参阅 <a href="#one-liners">One-liners</a> 获取示例。</p></li><li><p>替换一个或多个文件中出现的字符串：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pi.bak -e <span class="string">'s/old-string/new-string/g'</span> my-files-*.txt</span><br></pre></td></tr></table></figure></li><li><p>使用 <a href="https://github.com/jlevy/repren" target="_blank" rel="noopener"><code>repren</code></a> 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件、目录和内容全部重命名 foo -&gt; bar:</span></span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"><span class="comment"># 还原所有备份文件 whatever.bak -&gt; whatever:</span></span><br><span class="line">repren --renames --from <span class="string">'(.*)\.bak'</span> --to <span class="string">'\1'</span> *.bak</span><br><span class="line"><span class="comment"># 用 rename 实现上述功能（若可用）:</span></span><br><span class="line">rename <span class="string">'s/\.bak$//'</span> *.bak</span><br></pre></td></tr></table></figure></li><li><p>根据 man 页面的描述，<code>rsync</code> 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 <code>rsync</code> 代替 <code>scp</code> 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html" target="_blank" rel="noopener">最快方法</a>之一：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure></li><li><p>若要在复制文件时获取当前进度，可使用 <code>pv</code>，<a href="https://github.com/dmerejkowsky/pycp" target="_blank" rel="noopener"><code>pycp</code></a>，<a href="https://github.com/Xfennec/progress" target="_blank" rel="noopener"><code>progress</code></a>，<code>rsync --progress</code>。若所执行的复制为block块拷贝，可以使用 <code>dd status=progress</code>。</p></li><li><p>使用 <code>shuf</code> 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。</p></li><li><p>了解 <code>sort</code> 的参数。显示数字时，使用 <code>-n</code> 或者 <code>-h</code> 来显示更易读的数（例如 <code>du -h</code> 的输出）。明白排序时关键字的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p></li><li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p></li><li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更的统计数据。<code>vimdiff</code> 用于比对并编辑文件。</p></li><li><p>对于二进制文件，使用 <code>hd</code>，<code>hexdump</code> 或者 <code>xxd</code> 使其以十六进制显示，使用 <code>bvi</code>，<code>hexedit</code> 或者 <code>biew</code> 来进行二进制编辑。</p></li><li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等工具）可以帮助在二进制文件中查找特定比特。</p></li><li><p>制作二进制差分文件（Delta 压缩），使用 <code>xdelta3</code>。</p></li><li><p>使用 <code>iconv</code> 更改文本编码。需要更高级的功能，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uconv -f utf-8 -t utf-8 -x <span class="string">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure></li><li><p>拆分文件可以使用 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p></li><li><p>操作日期和时间表达式，可以用 <a href="http://www.fresse.org/dateutils/" target="_blank" rel="noopener"><code>dateutils</code></a> 中的 <code>dateadd</code>、<code>datediff</code>、<code>strptime</code> 等工具。</p></li><li><p>使用 <code>zless</code>、<code>zmore</code>、<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p></li><li><p>文件属性可以通过 <code>chattr</code> 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：<code>sudo chattr +i /critical/directory/or/file</code></p></li><li><p>使用 <code>getfacl</code> 和 <code>setfacl</code> 以保存和恢复文件权限。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getfacl -R /some/path &gt; permissions.txt</span><br><span class="line">setfacl --restore=permissions.txt</span><br></pre></td></tr></table></figure></li><li><p>为了高效地创建空文件，请使用 <code>truncate</code>（创建<a href="https://zh.wikipedia.org/wiki/稀疏文件" target="_blank" rel="noopener">稀疏文件</a>），<code>fallocate</code>（用于 ext4，xfs，btrf 和 ocfs2 文件系统），<code>xfs_mkfile</code>（适用于几乎所有的文件系统，包含在 xfsprogs 包中），<code>mkfile</code>（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。</p></li></ul><h2 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h2><ul><li><p><code>curl</code> 和 <code>curl -I</code> 可以被轻松地应用于 web 调试中，它们的好兄弟 <code>wget</code> 也是如此，或者也可以试试更潮的 <a href="https://github.com/jkbrzt/httpie" target="_blank" rel="noopener"><code>httpie</code></a>。</p></li><li><p>获取 CPU 和硬盘的使用状态，通常使用使用 <code>top</code>（<code>htop</code> 更佳），<code>iostat</code> 和 <code>iotop</code>。而 <code>iostat -mxz 15</code> 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。</p></li><li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p></li><li><p><code>dstat</code> 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances" target="_blank" rel="noopener"><code>glances</code></a>，它会在一个终端窗口中向你提供一些系统级的数据。</p></li><li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。</p></li><li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools" target="_blank" rel="noopener">SJK tools</a> 更高级。</p></li><li><p>使用 <a href="http://www.bitwizard.nl/mtr/" target="_blank" rel="noopener"><code>mtr</code></a> 去跟踪路由，用于确定网络问题。</p></li><li><p>用 <a href="https://dev.yorhel.nl/ncdu" target="_blank" rel="noopener"><code>ncdu</code></a> 来查看磁盘使用情况，它比寻常的命令，如 <code>du -sh *</code>，更节省时间。</p></li><li><p>查找正在使用带宽的套接字连接或进程，使用 <a href="http://www.ex-parrot.com/\~pdw/iftop/" target="_blank" rel="noopener"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs" target="_blank" rel="noopener"><code>nethogs</code></a>。</p></li><li><p><code>ab</code> 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p></li><li><p><a href="https://wireshark.org/" target="_blank" rel="noopener"><code>wireshark</code></a>，<a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html" target="_blank" rel="noopener"><code>tshark</code></a> 和 <a href="http://ngrep.sourceforge.net/" target="_blank" rel="noopener"><code>ngrep</code></a> 可用于复杂的网络调试。</p></li><li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p></li><li><p>了解使用 <code>ldd</code> 来检查共享库。但是<a href="http://www.catonmat.net/blog/ldd-arbitrary-code-execution/" target="_blank" rel="noopener">永远不要在不信任的文件上运行</a>。</p></li><li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p></li><li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p></li><li><p>当调试一些之前出现的问题的时候，<a href="http://sebastien.godard.pagesperso-orange.fr/" target="_blank" rel="noopener"><code>sar</code></a> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p></li><li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="noopener">SystemTap</a>），<a href="https://en.wikipedia.org/wiki/Perf_(Linux" target="_blank" rel="noopener"><code>perf</code></a>)，以及<a href="https://github.com/draios/sysdig" target="_blank" rel="noopener"><code>sysdig</code></a>。</p></li><li><p>查看你当前使用的系统，使用 <code>uname</code>，<code>uname -a</code>（Unix／kernel 信息）或者 <code>lsb_release -a</code>（Linux 发行版信息）。</p></li><li><p>无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 <code>dmesg</code>。</p></li><li><p>如果你删除了一个文件，但通过 <code>du</code> 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：<br><code>lsof | grep deleted | grep &quot;filename-of-my-big-file&quot;</code></p></li></ul><h2 id="单行脚本"><a href="#单行脚本" class="headerlink" title="单行脚本"></a>单行脚本</h2><p>一些命令组合的例子：</p><ul><li><p>当你需要对文本文件做集合交、并、差运算时，<code>sort</code> 和 <code>uniq</code> 会是你的好帮手。具体例子请参照代码后面的，此处假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数，但是实际上 <code>sort</code> 并不被内存大小约束），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort a b | uniq &gt; c   <span class="comment"># c 是 a 并 b</span></span><br><span class="line">sort a b | uniq -d &gt; c   <span class="comment"># c 是 a 交 b</span></span><br><span class="line">sort a b b | uniq -u &gt; c   <span class="comment"># c 是 a - b</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p></li></ul><ul><li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; x += $3 &#125; END &#123; print x &#125;'</span> myfile</span><br></pre></td></tr></table></figure></li><li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -ls</span><br></pre></td></tr></table></figure></li><li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在 URI 中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o <span class="string">'acct_id=[0-9]+'</span> access.log | cut -d= -f2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure></li><li><p>要持续监测文件改动，可以使用 <code>watch</code>，例如检查某个文件夹中文件的改变，可以用 <code>watch -d -n 2 &#39;ls -rtlh | tail&#39;</code>；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 <code>watch -d -n 2 ifconfig</code>。</p></li><li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() &#123;</span><br><span class="line">  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|</span><br><span class="line">    pandoc -f markdown -t html |</span><br><span class="line">    iconv -f <span class="string">'utf-8'</span> -t <span class="string">'unicode'</span> |</span><br><span class="line">    xmlstarlet fo --html --dropdtd |</span><br><span class="line">    xmlstarlet sel -t -v <span class="string">"(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]"</span> |</span><br><span class="line">    xmlstarlet unesc | fmt -80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="冷门但有用"><a href="#冷门但有用" class="headerlink" title="冷门但有用"></a>冷门但有用</h2><ul><li><p><code>expr</code>：计算表达式或正则匹配</p></li><li><p><code>m4</code>：简单的宏处理器</p></li><li><p><code>yes</code>：多次打印字符串</p></li><li><p><code>cal</code>：漂亮的日历</p></li><li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p></li><li><p><code>printenv</code>：打印环境变量（调试时或在写脚本文件时很有用）</p></li><li><p><code>look</code>：查找以特定字符串开头的单词或行</p></li><li><p><code>cut</code>，<code>paste</code> 和 <code>join</code>：数据修改</p></li><li><p><code>fmt</code>：格式化文本段落</p></li><li><p><code>pr</code>：将文本格式化成页／列形式</p></li><li><p><code>fold</code>：包裹文本中的几行</p></li><li><p><code>column</code>：将文本格式化成多个对齐、定宽的列或表格</p></li><li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p></li><li><p><code>nl</code>：添加行号</p></li><li><p><code>seq</code>：打印数字</p></li><li><p><code>bc</code>：计算器</p></li><li><p><code>factor</code>：分解因数</p></li><li><p><a href="https://gnupg.org/" target="_blank" rel="noopener"><code>gpg</code></a>：加密并签名文件</p></li><li><p><code>toe</code>：terminfo 入口列表</p></li><li><p><code>nc</code>：网络调试及数据传输</p></li><li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p></li><li><p><a href="https://github.com/mattthias/slurm" target="_blank" rel="noopener"><code>slurm</code></a>：网络流量可视化</p></li><li><p><code>dd</code>：文件或设备间传输数据</p></li><li><p><code>file</code>：确定文件类型</p></li><li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p></li><li><p><code>stat</code>：文件信息</p></li><li><p><code>time</code>：执行命令，并计算执行时间</p></li><li><p><code>timeout</code>：在指定时长范围内执行命令，并在规定时间结束后停止进程</p></li><li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p></li><li><p><code>logrotate</code>： 切换、压缩以及发送日志文件</p></li><li><p><code>watch</code>：重复运行同一个命令，展示结果并／或高亮有更改的部分</p></li><li><p><a href="https://github.com/joh/when-changed" target="_blank" rel="noopener"><code>when-changed</code></a>：当检测到文件更改时执行指定命令。参阅 <code>inotifywait</code> 和 <code>entr</code>。</p></li><li><p><code>tac</code>：反向输出文件</p></li><li><p><code>shuf</code>：文件中随机选取几行</p></li><li><p><code>comm</code>：一行一行的比较排序过的文件</p></li><li><p><code>strings</code>：从二进制文件中抽取文本</p></li><li><p><code>tr</code>：转换字母</p></li><li><p><code>iconv</code> 或 <code>uconv</code>：文本编码转换</p></li><li><p><code>split</code> 和 <code>csplit</code>：分割文件</p></li><li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p></li><li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p></li><li><p><code>apg</code>：随机生成密码</p></li><li><p><code>xz</code>：高比例的文件压缩</p></li><li><p><code>ldd</code>：动态库信息</p></li><li><p><code>nm</code>：提取 obj 文件中的符号</p></li><li><p><code>ab</code> 或 <a href="https://github.com/wg/wrk" target="_blank" rel="noopener"><code>wrk</code></a>：web 服务器性能分析</p></li><li><p><code>strace</code>：调试系统调用</p></li><li><p><a href="http://www.bitwizard.nl/mtr/" target="_blank" rel="noopener"><code>mtr</code></a>：更好的网络调试跟踪工具</p></li><li><p><code>cssh</code>：可视化的并发 shell</p></li><li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p></li><li><p><a href="https://wireshark.org/" target="_blank" rel="noopener"><code>wireshark</code></a> 和 <a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html" target="_blank" rel="noopener"><code>tshark</code></a>：抓包和网络调试工具</p></li><li><p><a href="http://ngrep.sourceforge.net/" target="_blank" rel="noopener"><code>ngrep</code></a>：网络层的 grep</p></li><li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p></li><li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p></li><li><p><code>dstat</code>：系统状态查看</p></li><li><p><a href="https://github.com/nicolargo/glances" target="_blank" rel="noopener"><code>glances</code></a>：高层次的多子系统总览</p></li><li><p><code>iostat</code>：硬盘使用状态</p></li><li><p><code>mpstat</code>： CPU 使用状态</p></li><li><p><code>vmstat</code>： 内存使用状态</p></li><li><p><code>htop</code>：top 的加强版</p></li><li><p><code>last</code>：登入记录</p></li><li><p><code>w</code>：查看处于登录状态的用户</p></li><li><p><code>id</code>：用户/组 ID 信息</p></li><li><p><a href="http://sebastien.godard.pagesperso-orange.fr/" target="_blank" rel="noopener"><code>sar</code></a>：系统历史数据</p></li><li><p><a href="http://www.ex-parrot.com/\~pdw/iftop/" target="_blank" rel="noopener"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs" target="_blank" rel="noopener"><code>nethogs</code></a>：套接字及进程的网络利用情况</p></li><li><p><code>ss</code>：套接字数据</p></li><li><p><code>dmesg</code>：引导及系统错误信息</p></li><li><p><code>sysctl</code>： 在内核运行时动态地查看和修改内核的运行参数</p></li><li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p></li><li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p></li><li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p></li><li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p></li><li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p></li></ul><h2 id="仅限-OS-X-系统"><a href="#仅限-OS-X-系统" class="headerlink" title="仅限 OS X 系统"></a>仅限 OS X 系统</h2><p>以下是<em>仅限于</em> OS X 系统的技巧。</p><ul><li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。</p></li><li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p></li><li><p>若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>、<strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p></li><li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p></li><li><p>Spotlight：用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p></li><li><p>注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p></li><li><p>用 <code>sw_vers</code> 获取 OS X 的版本信息。</p></li></ul><h2 id="仅限-Windows-系统"><a href="#仅限-Windows-系统" class="headerlink" title="仅限 Windows 系统"></a>仅限 Windows 系统</h2><p>以下是<em>仅限于</em> Windows 系统的技巧。</p><h3 id="在-Winodws-下获取-Unix-工具"><a href="#在-Winodws-下获取-Unix-工具" class="headerlink" title="在 Winodws 下获取 Unix 工具"></a>在 Winodws 下获取 Unix 工具</h3><ul><li><p>可以安装 <a href="https://cygwin.com/" target="_blank" rel="noopener">Cygwin</a> 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。</p></li><li><p>在 Windows 10 上，你可以使用 <a href="https://msdn.microsoft.com/commandline/wsl/about" target="_blank" rel="noopener">Bash on Ubuntu on Windows</a>，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。</p></li><li><p>如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 <a href="http://www.mingw.org/" target="_blank" rel="noopener">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys" target="_blank" rel="noopener">MSYS</a> 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。</p></li><li><p>另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 <a href="https://github.com/dthree/cash" target="_blank" rel="noopener">Cash</a>。注意在此环境下只有很少的 Unix 命令和命令行可用。</p></li></ul><h3 id="实用-Windows-命令行工具"><a href="#实用-Windows-命令行工具" class="headerlink" title="实用 Windows 命令行工具"></a>实用 Windows 命令行工具</h3><ul><li><p>可以使用 <code>wmic</code> 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。</p></li><li><p>Windows 实用的原生命令行网络工具包括 <code>ping</code>，<code>ipconfig</code>，<code>tracert</code>，和 <code>netstat</code>。</p></li><li><p>可以使用 <code>Rundll32</code> 命令来实现<a href="http://www.thewindowsclub.com/rundll32-shortcut-commands-windows" target="_blank" rel="noopener">许多有用的 Windows 任务</a> 。</p></li></ul><h3 id="Cygwin-技巧"><a href="#Cygwin-技巧" class="headerlink" title="Cygwin 技巧"></a>Cygwin 技巧</h3><ul><li><p>通过 Cygwin 的包管理器来安装额外的 Unix 程序。</p></li><li><p>使用 <code>mintty</code> 作为你的命令行窗口。</p></li><li><p>要访问 Windows 剪贴板，可以通过 <code>/dev/clipboard</code>。</p></li><li><p>运行 <code>cygstart</code> 以通过默认程序打开一个文件。</p></li><li><p>要访问 Windows 注册表，可以使用 <code>regtool</code>。</p></li><li><p>注意 Windows 驱动器路径 <code>C:\</code> 在 Cygwin 中用 <code>/cygdrive/c</code> 代表，而 Cygwin 的 <code>/</code> 代表 Windows 中的 <code>C:\cygwin</code>。要转换 Cygwin 和 Windows 风格的路径可以用 <code>cygpath</code>。这在需要调用 Windows 程序的脚本里很有用。</p></li><li><p>学会使用 <code>wmic</code>，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。</p></li><li><p>要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 <a href="https://github.com/dthree/cash" target="_blank" rel="noopener">Cash</a>。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。</p></li><li><p>要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 <a href="http://www.mingw.org/" target="_blank" rel="noopener">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys" target="_blank" rel="noopener">MSYS</a> 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。</p></li></ul><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><ul><li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li><li><a href="https://github.com/herrbischoff/awesome-osx-command-line" target="_blank" rel="noopener">awesome-osx-command-line</a>：一份针对 OS X 命令行的更深入的指南。</li><li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/" target="_blank" rel="noopener">Strict mode</a>：为了编写更好的脚本文件。</li><li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li><li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html" target="_blank" rel="noopener">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li><li><a href="http://datascienceatthecommandline.com/#tools" target="_blank" rel="noopener">Data Science at the Command Line</a>：用于数据科学的一些命令和工具，摘自同名书籍。</li></ul><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 <em>有能力</em> 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)</p><h2 id="授权条款"><a href="#授权条款" class="headerlink" title="授权条款"></a>授权条款</h2><p><br><div align="center"><img src="http://creativecommons.org/licenses/by-sa/4.0/"></div><br></p><p>本文使用授权协议 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">Creative Commons Attribution-ShareAlike 4.0 International License</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载自 &lt;a href=&quot;https://github.com/jlevy/the-art-of-command-line&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jlevy/the-a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://dunwu.github.io/2019/03/06/network/data-link-layer/"/>
    <id>https://dunwu.github.io/2019/03/06/network/data-link-layer/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:45.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><blockquote><p><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p><ul><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#简介">简介</a></li><li><a href="#基本问题">基本问题</a><ul><li><a href="#封装成帧">封装成帧</a></li><li><a href="#透明传输">透明传输</a></li><li><a href="#差错检测">差错检测</a></li></ul></li><li><a href="#点对点信道">点对点信道</a><ul><li><a href="#ppp-协议">PPP 协议</a></li></ul></li><li><a href="#广播信道">广播信道</a><ul><li><a href="#csmacd-协议">CSMA/CD 协议</a></li></ul></li><li><a href="#局域网">局域网</a></li><li><a href="#以太网">以太网</a></li><li><a href="#mac-地址">MAC 地址</a></li><li><a href="#设备">设备</a><ul><li><a href="#适配器">适配器</a></li><li><a href="#集线器">集线器</a></li><li><a href="#网桥">网桥</a></li><li><a href="#以太网交换机">以太网交换机</a></li></ul></li></ul><!-- /TOC --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>链路是从一个节点到相邻节点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（网络适配器）和软件（协议）。</li><li>数据链路层三个基本问题：封装成帧、透明传输、差错检测。</li><li>数据链路层有两种信道类型：点对点信道（主要使用 <code>PPP</code>）和广播信道（主要使用 <code>CSMA/CD</code>）。</li><li>以太网 MAC 层的地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用及使用场合。</li></ul><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>为网络层传下来的 IP 数据报添加首部和尾部，用于标记帧的开始和结束。</p><p>为了提高传输效率，应该让数据部分长度尽可能大于首部和尾部。但是，每种链路层协议都限制了帧的数据部分长度上线——最大传送单元 MTU（Maximum Transfer Unit）</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/数据链路帧.png"></div><br></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p><strong>透明</strong>表示：某一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/经过字节填充后发送的数据.png"></div><br></p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>目前数据链路层广泛使用了<a href="https://zh.wikipedia.org/wiki/循环冗余检验" target="_blank" rel="noopener"><strong>循环冗余检验 CRC（Cyclic redundancy check）</strong></a>来检查比特差错。</p><h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><p>点对点信道使用一对一的点对点通信方式。</p><p>对于点对点的链路，点对点协议 PPP（Point-to-Point Protocol）是使用最广泛的数据链路层协议。</p><h3 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h3><p>互联网用户通常都要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/PPP协议.png"></div><br></p><p>PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/PPP帧.png"></div><br></p><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p>广播信道(broadcast channel)是通过广播的方式传输信息的信息通道。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h3><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p><ul><li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</li><li><strong>碰撞检测</strong> ：即边发送边检测。若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。计算退避等待时间采用的是<a href="https://baike.baidu.com/item/二进制指数退避算法" target="_blank" rel="noopener">二进制指数退避算法</a>。</li></ul><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网 LAN（Local Area Network）是指在某一区域内由多台计算机互联成的计算机组。</p><p>局域网的拓扑结构通常为总线型和环型。</p><p>局域网技术主要有：以太网、令牌环网、FDDI 网和无线局域网等。</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网（Ethernet）是一种星型拓扑结构局域网。</p><p>以太网是目前应用最广泛的局域网。</p><p>以太网使用 CSMA/CD 协议。</p><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址（Media Access Control Address），也称为以太网地址或物理地址，它是一个用来确认网上设备位置的地址。</p><p>MAC 地址长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/network/data-link/MAC帧.png"></div><br></p><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>网络适配器一般指网卡。</p><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>网卡和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而网卡和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行。</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器（Hub）的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p><p>使用集线器可以在物理层扩展以太网。</p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。</p><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p><ul><li>以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。</li><li>交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</li><li>用户独占传输媒体的带宽，若一个接口到主机的带宽是 10Mbit 每秒，那么有 10 个接口的交换机的总容量是 100Mbit 每秒。这是交换机的最大优点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据链路层（Data Link Layer）&lt;/strong&gt; - 网络层
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件工程</title>
    <link href="https://dunwu.github.io/2019/03/06/software/README/"/>
    <id>https://dunwu.github.io/2019/03/06/software/README/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><blockquote><p>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p><p>关键词： <code>瀑布模型</code>, <code>螺旋模型</code>, <code>敏捷开发</code>, <code>极限编程</code></p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#软件工程的基本内容">软件工程的基本内容</a></li><li><a href="#软件工程的目标">软件工程的目标</a></li><li><a href="#软件工程的方法">软件工程的方法</a></li><li><a href="#软件生命周期">软件生命周期</a></li><li><a href="#软件生命周期模型">软件生命周期模型</a><ul><li><a href="#瀑布模型">瀑布模型</a></li><li><a href="#螺旋模型">螺旋模型</a></li></ul></li><li><a href="#软件工程术语">软件工程术语</a></li><li><a href="#更多内容">更多内容</a></li></ul><!-- /TOC --><h2 id="软件工程的基本内容"><a href="#软件工程的基本内容" class="headerlink" title="软件工程的基本内容"></a>软件工程的基本内容</h2><p>软件工程的七条基本原理</p><ol><li>用分阶段的生存周期计划进行严格的管理。</li><li>坚持进行阶段评审。</li><li>实行严格的产品控制。</li><li>采用现代程序设计技术。</li><li>软件工程结果应能清楚地审查。</li><li>开发小组的人员应该少而精。</li><li>承认不断改进软件工程实践的必要性。</li></ol><h2 id="软件工程的目标"><a href="#软件工程的目标" class="headerlink" title="软件工程的目标"></a>软件工程的目标</h2><ol><li><strong>适用性</strong> - 软件在不同的系统约束条件下，使用户需求得到满足的难易程度。</li><li><strong>有效性</strong> - 软件系统能最有效的利用计算机的时间和空间资源。各种软件无不把系统的时/空开销作为衡量软件质量的一项重要技术指标。很多场合，在追求时间有效性和空间有效性时会发生矛盾，这时不得不牺牲时间有效性换取空间有效性或牺牲空间有效性换取时间有效性。时/空折衷是经常采用的技巧。</li><li><strong>可修改性</strong> - 允许对系统进行修改而不增加原系统的复杂性。它支持软件的调试和维护，是一个难以达到的目标。</li><li><strong>可靠性</strong> - 能防止因概念、设计和结构等方面的不完善造成的软件系统失效，具有挽回因操作不当造成软件系统失效的能力。</li><li><strong>可理解性</strong> - 系统具有清晰的结构，能直接反映问题的需求。可理解性有助于控制系统软件复杂性，并支持软件的维护、移植或重用。</li><li><strong>可维护性</strong> - 软件交付使用后，能够对它进行修改，以改正潜伏的错误，改进性能和其它属性，使软件产品适应环境的变化等。软件维护费用在软件开发费用中占有很大的比重。可维护性是软件工程中一项十分重要的目标。</li><li><strong>可重用性</strong> - 把概念或功能相对独立的一个或一组相关模块定义为一个软部件。可组装在系统的任何位置，降低工作量。</li><li><strong>可移植性</strong> - 软件从一个计算机系统或环境搬到另一个计算机系统或环境的难易程度。</li><li><strong>可追踪性</strong> - 根据软件需求对软件设计、程序进行正向追踪，或根据软件设计、程序对软件需求的逆向追踪的能力。</li><li><strong>可互操作性</strong> - 多个软件元素相互通信并协同完成任务的能力。</li></ol><h2 id="软件工程的方法"><a href="#软件工程的方法" class="headerlink" title="软件工程的方法"></a>软件工程的方法</h2><p>著名的重量级开发方法：</p><ul><li><a href="https://zh.wikipedia.org/zh-cn/ISO_9000" target="_blank" rel="noopener">ISO9000</a> - ISO 9000 系列标准是国际标准化组织设立的标准，与品质管理系统有关。</li><li><a href="https://zh.wikipedia.org/wiki/能力成熟度模型" target="_blank" rel="noopener">能力成熟度模型（CMM）</a> - CMM 涵盖一个成熟的软件发展组织所应具备的重要功能与项目，它描述了软件发展的演进过程，从毫无章法、不成熟的软件开发阶段到成熟软件开发阶段的过程。</li><li><a href="https://zh.wikipedia.org/wiki/统一软件开发过程" target="_blank" rel="noopener">统一软件开发过程（RUP）</a> - RUP 是一种软件工程方法，为迭代式软件开发流程。</li></ul><p>著名的轻量级开发方法：</p><ul><li><a href="https://zh.wikipedia.org/wiki/敏捷软件开发" target="_blank" rel="noopener">敏捷开发（Agile Development）</a> - 是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。</li><li><a href="https://zh.wikipedia.org/wiki/极限编程" target="_blank" rel="noopener">极限编程（XP）</a> - 极限编程是敏捷软件开发中最有成效的方法学之一。极限编程技术以沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）和尊重（Respect）为价值标准。</li></ul><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><blockquote><p>软件生命周期(Software Life Cycle,SLC)是软件的产生直到报废或停止使用的生命周期。</p></blockquote><ul><li>问题定义 - 要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。</li><li>可行性研究 - 一方面在于把待开发的系统的目标以明确的语言描述出来；另一方面从经济、技术、法律等多方面进行可行性分析。</li><li>需求分析 - 弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。</li><li>开发阶段<ul><li>概要设计</li><li>详细设计</li><li>编码实现</li><li>软件测试 - 测试的过程分单元测试、组装测试以及系统测试三个阶段进行。测试的方法主要有白盒测试和黑盒测试两种。</li></ul></li><li>维护</li></ul><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/software-engineering/软件生命周期.gif"></div><br></p><h2 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><blockquote><p>瀑布模型（Waterfall Model）强调系统开发应有完整的周期，且必须完整的经历周期的每一开发阶段，并系统化的考量分析与设计的技术、时间与资源之投入等。</p></blockquote><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/software-engineering/瀑布模型.jpg"></div><br></p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>瀑布模型核心思想是按工序将问题拆分，将功能的实现与设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>为项目提供了按阶段划分的检查点。</li><li>当前一阶段完成后，您只需要去关注后续阶段。</li><li>可在迭代模型中应用瀑布模型。</li><li>它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。</li></ul><p><strong>缺点</strong></p><ul><li>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。</li><li>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。</li><li>通过过多的强制完成日期和里程碑来跟踪各个项目阶段。</li><li>瀑布模型的突出缺点是不适应用户需求的变化。</li></ul><p><strong>适用场景</strong></p><p>是否使用这一模型主要取决于是否能理解客户的需求以及在项目的进程中这些需求的变化程度。对于需求经常变化的项目，不要适用瀑布模型。</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><blockquote><p>螺旋模型基本做法是在“瀑布模型”的每一个开发阶段前引入一个非常严格的风险识别、风险分析和风险控制，它把软件项目分解成一个个小项目。每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。</p></blockquote><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/software-engineering/螺旋模型.png"></div><br></p><h4 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h4><p>螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：</p><ol><li>制定计划 - 确定软件目标，选定实施方案，弄清项目开发的限制条件；</li><li>风险分析 - 分析评估所选方案，考虑如何识别和消除风险；</li><li>实施工程 - 实施软件开发和验证；</li><li>客户评估 - 评价开发工作，提出修正建议，制定下一步计划。</li></ol><p>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>设计上的灵活性,可以在项目的各个阶段进行变更。</li><li>以小的分段来构建大型系统,使成本计算变得简单容易。</li><li>客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。</li><li>随着项目推进,客户始终掌握项目的最新信息, 从而他或她能够和管理层有效地交互。</li><li>客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品。</li></ul><p><strong>缺点</strong></p><p>很难让用户确信这种演化方法的结果是可以控制的。建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。</p><p><strong>适用场景</strong></p><p>对于新项目，需求不明确的情况下，适合用螺旋模型进行开发，便于风险控制和需求变更。</p><h2 id="软件工程术语"><a href="#软件工程术语" class="headerlink" title="软件工程术语"></a>软件工程术语</h2><ul><li><strong>里程碑（Milestone）</strong> - 在制定项目进度计划时，在进度时间表上设立一些重要的时间检查点，这样一来，就可以在项目执行过程中利用这些重要的时间检查点来对项目的进程进行检查和控制。这些重要的时间检查点被称作项目的里程碑。</li><li><strong>人月</strong> - 软件开发的工作量单位。如 200 人月，10 个人开发，那算来就是花 20 个月就可完工。</li><li><strong>基线</strong> - 基线是项目储存库中每个工件版本在特定时期的一个“快照”。它提供一个正式标准，随后的工作基于此标准，并且只有经过授权后才能变更这个标准。建立一个初始基线后，以后每次对其进行的变更都将记录为一个差值，直到建成下一个基线。</li></ul><h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul><li>《没有银弹》</li><li>《人月神话》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件工程&quot;&gt;&lt;a href=&quot;#软件工程&quot; class=&quot;headerlink&quot; title=&quot;软件工程&quot;&gt;&lt;/a&gt;软件工程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目规范</title>
    <link href="https://dunwu.github.io/2019/03/06/style/project-style/"/>
    <id>https://dunwu.github.io/2019/03/06/style/project-style/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h1><blockquote><p>软件项目开发规范。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#项目结构">项目结构</a><ul><li><a href="#目录">目录</a></li><li><a href="#文件">文件</a></li></ul></li><li><a href="#目录名">目录名</a></li><li><a href="#文件名">文件名</a></li></ul><!-- /TOC --><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>以下为项目根目录下的文件和目录的组织结构：</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><strong>codes</strong>：代码目录。</p><p><strong>configurations</strong>：配置目录。一般存放项目相关的配置文件。如 maven 的 settings.xml，nginx 的 nginx.conf 等。</p><p><strong>demos</strong>：示例目录。</p><p><strong>docs</strong>：文档目录。</p><p><strong>libs</strong>：第三方库文件。</p><p><strong>scripts</strong>：脚本目录。一般存放用于启动、构建项目的可执行脚本文件。</p><p><strong>packages</strong>：打包文件目录。Java 项目中可能是 jar、war 等；前端项目中可能是 zip、rar 等；电子书项目中可能是 pdf 等。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><strong>.gitignore</strong>：git 忽略规则。</p><p><strong>.gitattributes</strong>：git 属性规则。</p><p><strong>.editorconfig</strong>：编辑器书写规则。</p><p><strong>README.md</strong>：项目说明文件。</p><p><strong>LICENSE</strong>：开源协议。如果项目是开源文件，需要添加。</p><h2 id="目录名"><a href="#目录名" class="headerlink" title="目录名"></a>目录名</h2><p>目录名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><p>目录名建议只使用小写字母，不使用大写字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不佳： Test</span><br><span class="line">正确： test</span><br></pre></td></tr></table></figure><p>目录名可以使用数字，但不应该是首字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不佳： 1-demo</span><br><span class="line">正确： demo1</span><br></pre></td></tr></table></figure><p>目录名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不佳： common_demo</span><br><span class="line">正确： common-demo</span><br></pre></td></tr></table></figure><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误： 名词解释.md</span><br><span class="line">正确： glossary.md</span><br></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误：TroubleShooting.md</span><br><span class="line">正确：troubleshooting.md</span><br></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>一些约定俗成的习惯可以保持传统写法，如：Java 的文件名一般使用驼峰命名法，且首字母大写；配置文件 <code>applicationContext.xml</code> ；React 中的 JSX 组件文件名一般使用驼峰命名法，且首字母大写等。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不佳：advanced_usage.md</span><br><span class="line">正确：advanced-usage.md</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目规范&quot;&gt;&lt;a href=&quot;#项目规范&quot; class=&quot;headerlink&quot; title=&quot;项目规范&quot;&gt;&lt;/a&gt;项目规范&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;软件项目开发规范。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- TOC depthFrom:2 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Markdown 语法</title>
    <link href="https://dunwu.github.io/2019/03/06/style/markdown/"/>
    <id>https://dunwu.github.io/2019/03/06/style/markdown/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-03-06T08:43:47.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-标题">1. 标题</a></li><li><a href="#2-文本">2. 文本</a><ul><li><a href="#21-普通文本">2.1. 普通文本</a></li><li><a href="#22-单行文本">2.2. 单行文本</a></li><li><a href="#23-文本块">2.3. 文本块</a></li><li><a href="#24-代码高亮">2.4. 代码高亮</a></li><li><a href="#25-文字高亮">2.5. 文字高亮</a></li><li><a href="#26-换行">2.6. 换行</a></li><li><a href="#27-粗体斜体删除线">2.7. 粗体、斜体、删除线</a></li><li><a href="#28-分割线">2.8. 分割线</a></li></ul></li><li><a href="#3-块引用">3. 块引用</a></li><li><a href="#4-列表">4. 列表</a><ul><li><a href="#41-无序列表">4.1. 无序列表</a></li><li><a href="#42-有序列表">4.2. 有序列表</a></li><li><a href="#43-复选框列表">4.3. 复选框列表</a></li></ul></li><li><a href="#5-链接">5. 链接</a><ul><li><a href="#51-链接外部-url">5.1. 链接外部 URL</a></li><li><a href="#52-链接本仓库里的-url">5.2. 链接本仓库里的 URL</a></li><li><a href="#53-图片链接">5.3. 图片链接</a></li><li><a href="#54-锚点">5.4. 锚点</a></li></ul></li><li><a href="#6-图片">6. 图片</a></li><li><a href="#7-表格">7. 表格</a><ul><li><a href="#71-对齐">7.1. 对齐</a></li><li><a href="#72-混合其他语法">7.2. 混合其他语法</a></li></ul></li><li><a href="#8-表情">8. 表情</a></li><li><a href="#9-diff-语法">9. diff 语法</a></li><li><a href="#资料">资料</a></li></ul><!-- /TOC --><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>使用 <code>#</code>，可表示 1-6 级标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h2 id="2-文本"><a href="#2-文本" class="headerlink" title="2. 文本"></a>2. 文本</h2><h3 id="2-1-普通文本"><a href="#2-1-普通文本" class="headerlink" title="2.1. 普通文本"></a>2.1. 普通文本</h3><p>这是一段普通的文本</p><h3 id="2-2-单行文本"><a href="#2-2-单行文本" class="headerlink" title="2.2. 单行文本"></a>2.2. 单行文本</h3><p>在一行开头加入 1 个 Tab 或者 4 个空格。</p><pre><code>人生若只如初见，何事秋风悲画扇。</code></pre><h3 id="2-3-文本块"><a href="#2-3-文本块" class="headerlink" title="2.3. 文本块"></a>2.3. 文本块</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法 1"></a>语法 1</h4><p>在连续几行的文本开头加入 1 个 Tab 或者 4 个空格。</p><pre><code>《一剪梅》红藕香残玉簟秋，轻解罗裳，独上兰舟。云中谁寄锦书来？雁字回时，月满西楼。花自飘零水自流，一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。</code></pre><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法 2"></a>语法 2</h4><p>使用一对各三个的反引号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">欢迎到访</span><br><span class="line">我是C++码农</span><br><span class="line">你可以在知乎、CSDN、简书搜索【果冻虾仁】找到我</span><br></pre></td></tr></table></figure><p>该语法也可以实现代码高亮，见<a href="#代码高亮">代码高亮</a></p><h3 id="2-4-代码高亮"><a href="#2-4-代码高亮" class="headerlink" title="2.4. 代码高亮"></a>2.4. 代码高亮</h3><p>在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; printf(<span class="string">"Hello, Markdown."</span>); &#125; <span class="comment">//Java</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//C</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">string</span>&amp; A,<span class="keyword">const</span> <span class="built_in">string</span>&amp; B) <span class="comment">//Cpp</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello GitHub"</span> <span class="comment">#Bash</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myH1'</span>).innerHTML = <span class="string">'Welcome to my Homepage'</span>; <span class="comment">//Javascipt</span></span><br></pre></td></tr></table></figure><h3 id="2-5-文字高亮"><a href="#2-5-文字高亮" class="headerlink" title="2.5. 文字高亮"></a>2.5. 文字高亮</h3><p>文字高亮功能能使行内部分文字高亮，使用一对反引号。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`linux` `网络编程` `socket` `epoll`</span><br></pre></td></tr></table></figure><p>效果：<code>linux</code> <code>网络编程</code> <code>socket</code> <code>epoll</code></p><p>也适合做一篇文章的 tag</p><h3 id="2-6-换行"><a href="#2-6-换行" class="headerlink" title="2.6. 换行"></a>2.6. 换行</h3><p>在 markdown 中，直接回车不能换行，</p><p>可以在上一行文本后面补两个空格，或者在两行文本直接加一个空行。</p><h3 id="2-7-粗体、斜体、删除线"><a href="#2-7-粗体、斜体、删除线" class="headerlink" title="2.7. 粗体、斜体、删除线"></a>2.7. 粗体、斜体、删除线</h3><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>_斜体_</p><p><strong>粗体</strong></p><p>~~删除线~~</p></blockquote><p>粗体、斜体、删除线也可以组合起来使用：</p><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>*斜体1*</code></td><td><em>斜体 1</em></td></tr><tr><td><code>_斜体2_</code></td><td><em>斜体 2</em></td></tr><tr><td><code>**粗体1**</code></td><td><strong>粗体 1</strong></td></tr><tr><td><code>__粗体2__</code></td><td><strong>粗体 2</strong></td></tr><tr><td><code>\~\~删除线\~\~</code></td><td>~~删除线~~</td></tr><tr><td><code>***斜粗体1***</code></td><td><strong><em>斜粗体 1</em></strong></td></tr><tr><td><code>___斜粗体2___</code></td><td><strong><em>斜粗体 2</em></strong></td></tr><tr><td><code>***\~\~斜粗体删除线1\~\~***</code></td><td><strong><em>~~斜粗体删除线 1~~</em></strong></td></tr><tr><td><code>\~\~***斜粗体删除线2***\~\~</code></td><td>~~<strong><em>斜粗体删除线 2</em></strong>~~</td></tr></tbody></table><h3 id="2-8-分割线"><a href="#2-8-分割线" class="headerlink" title="2.8. 分割线"></a>2.8. 分割线</h3><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><hr><hr><hr></blockquote><h2 id="3-块引用"><a href="#3-块引用" class="headerlink" title="3. 块引用"></a>3. 块引用</h2><p>常用于引用文本。在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 数据结构</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; &gt; 树</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; 二叉树</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; &gt; 平衡二叉树</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; &gt; &gt; 满二叉树</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>数据结构</p><blockquote><p>树</p><blockquote><p>二叉树</p><blockquote><p>平衡二叉树</p><blockquote><p>满二叉树</p></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="4-列表"><a href="#4-列表" class="headerlink" title="4. 列表"></a>4. 列表</h2><h3 id="4-1-无序列表"><a href="#4-1-无序列表" class="headerlink" title="4.1. 无序列表"></a>4.1. 无序列表</h3><p>可以使用 <code>*</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h4 id="多级无序列表"><a href="#多级无序列表" class="headerlink" title="多级无序列表"></a>多级无序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>编程语言</span><br><span class="line">  - 脚本语言</span><br><span class="line"><span class="code">    - Python</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ul><li>编程语言<ul><li>脚本语言<ul><li>Python</li></ul></li></ul></li></ul></blockquote><h3 id="4-2-有序列表"><a href="#4-2-有序列表" class="headerlink" title="4.2. 有序列表"></a>4.2. 有序列表</h3><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.  </span>第一项</span><br><span class="line"><span class="bullet">2.  </span>第二项</span><br><span class="line"><span class="bullet">3.  </span>第三项</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="多级有序列表"><a href="#多级有序列表" class="headerlink" title="多级有序列表"></a>多级有序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.  </span>这是一级的有序列表，数字 1 还是 1</span><br><span class="line"><span class="code">    1.  这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字</span></span><br><span class="line"><span class="code">        1.  这是三级的有序列表，数字在显示的时候变成了英文字母</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ol><li>这是一级的有序列表，数字 1 还是 1<ol><li>这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字<ol><li>这是三级的有序列表，数字在显示的时候变成了英文字母</li></ol></li></ol></li></ol></blockquote><h3 id="4-3-复选框列表"><a href="#4-3-复选框列表" class="headerlink" title="4.3. 复选框列表"></a>4.3. 复选框列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[x] 需求分析</span><br><span class="line"><span class="bullet">- </span>[x] 系统设计</span><br><span class="line"><span class="bullet">- </span>[x] 详细设计</span><br><span class="line"><span class="bullet">- </span>[ ] 编码</span><br><span class="line"><span class="bullet">- </span>[ ] 测试</span><br><span class="line"><span class="bullet">- </span>[ ] 交付</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li style="list-style: none"><input type="checkbox" checked> 需求分析</li><li style="list-style: none"><input type="checkbox" checked> 系统设计</li><li style="list-style: none"><input type="checkbox" checked> 详细设计</li><li style="list-style: none"><input type="checkbox"> 编码</li><li style="list-style: none"><input type="checkbox"> 测试</li><li style="list-style: none"><input type="checkbox"> 交付</li></ul><p>您可以使用这个功能来标注某个项目各项任务的完成情况。</p><blockquote><p>Tip:</p><blockquote><p>在 GitHub 的 <strong>issue</strong> 中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改 issue 原文。</p></blockquote></blockquote><h2 id="5-链接"><a href="#5-链接" class="headerlink" title="5. 链接"></a>5. 链接</h2><h3 id="5-1-链接外部-URL"><a href="#5-1-链接外部-URL" class="headerlink" title="5.1. 链接外部 URL"></a>5.1. 链接外部 URL</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><p>语法 2 由两部分组成：</p><ul><li>第一部分使用两个中括号，[ ]里的标识符（本例中 zhihu），可以是数字，字母等的组合，标识符上下对应就行了（<strong>姑且称之为 URL 标识符</strong>）</li><li>第二部分标记实际 URL。</li></ul><blockquote><p>使用 URL 标识符能达到复用的目的，一般把全文所有的 URL 标识符统一放在文章末尾，这样看起来比较干净。</p></blockquote><h3 id="5-2-链接本仓库里的-URL"><a href="#5-2-链接本仓库里的-URL" class="headerlink" title="5.2. 链接本仓库里的 URL"></a>5.2. 链接本仓库里的 URL</h3><p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="5-3-图片链接"><a href="#5-3-图片链接" class="headerlink" title="5.3. 图片链接"></a>5.3. 图片链接</h3><p>给图片加链接的本质是混合图片显示语法和普通的链接语法。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![baidu</span>](<span class="link">http://www.baidu.com/img/bdlogo.gif '百度logo'</span>)](<span class="link">https://www.baidu.com</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><p><br><div align="center"><img src="http://www.baidu.com/img/bdlogo.gif '百度logo'"></div><br></p><h3 id="5-4-锚点"><a href="#5-4-锚点" class="headerlink" title="5.4. 锚点"></a>5.4. 锚点</h3><p>其实呢，每一个标题都是一个锚点，和 HTML 的锚点（<code>#</code>）类似，比如我们</p><p><a href="#markdown-语法">回到顶部</a></p><p>不过要注意，标题中的英文字母都被转化为<strong>小写字母</strong>了。</p><blockquote><p>以前 GitHub 对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！</p></blockquote><h2 id="6-图片"><a href="#6-图片" class="headerlink" title="6. 图片"></a>6. 图片</h2><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个 <code>!</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">URL title</span>)</span><br></pre></td></tr></table></figure><p>alt 和 title 即对应 HTML 中的 alt 和 title 属性（都可省略）：</p><ul><li><strong>alt</strong> 表示图片显示失败时的替换文本</li><li><strong>title</strong> 表示鼠标悬停在图片时的显示文本（注意这里要加引号）</li><li><strong>URL</strong> 即图片的 url 地址，如果引用本仓库中的图片，直接使用相对路径就可了，如果引用其他 github 仓库中的图片要注意格式，即：仓库地址/raw/分支名/图片路径，如：<a href="https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif" target="_blank" rel="noopener">https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif</a></li></ul><p>效果：</p><p><br><div align="center"><img src="http://www.baidu.com/img/bdlogo.gif '百度logo'"></div><br></p><h2 id="7-表格"><a href="#7-表格" class="headerlink" title="7. 表格"></a>7. 表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头 1   | 表头 2   |</span><br><span class="line">| -------- | -------- |</span><br><span class="line">| 表格单元 | 表格单元 |</span><br><span class="line">| 表格单元 | 表格单元 |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>表头 1</th><th>表头 2</th></tr></thead><tbody><tr><td>表格单元</td><td>表格单元</td></tr><tr><td>表格单元</td><td>表格单元</td></tr></tbody></table><h3 id="7-1-对齐"><a href="#7-1-对齐" class="headerlink" title="7.1. 对齐"></a>7.1. 对齐</h3><p>表格可以指定对齐方式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐        |      居中       | 右对齐 |</span><br><span class="line">| :------------ | :-------------: | -----: |</span><br><span class="line">| col 3 is      | some wordy text | \$1600 |</span><br><span class="line">| col 2 is      |    centered     |   \$12 |</span><br><span class="line">| zebra stripes |    are neat     |    \$1 |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:center">居中</th><th style="text-align:right">右对齐</th></tr></thead><tbody><tr><td style="text-align:left">col 3 is</td><td style="text-align:center">some wordy text</td><td style="text-align:right">\$1600</td></tr><tr><td style="text-align:left">col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">\$12</td></tr><tr><td style="text-align:left">zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">\$1</td></tr></tbody></table><h3 id="7-2-混合其他语法"><a href="#7-2-混合其他语法" class="headerlink" title="7.2. 混合其他语法"></a>7.2. 混合其他语法</h3><p>表格单元中的内容可以和其他大多数 GFM 语法配合使用，如：</p><h4 id="使用普通文本的删除线，斜体等效果"><a href="#使用普通文本的删除线，斜体等效果" class="headerlink" title="使用普通文本的删除线，斜体等效果"></a>使用普通文本的删除线，斜体等效果</h4><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>Help</td><td>~~Display the~~ help window.</td></tr><tr><td>Close</td><td><em>Closes</em> a window</td></tr></tbody></table><h4 id="表格中嵌入图片（链接）"><a href="#表格中嵌入图片（链接）" class="headerlink" title="表格中嵌入图片（链接）"></a>表格中嵌入图片（链接）</h4><p>其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。</p><table><thead><tr><th>图片</th><th>描述</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p><br><div align="center"><img src="http://www.baidu.com/img/bdlogo.gif '百度logo'"></div><br></p><h2 id="8-表情"><a href="#8-表情" class="headerlink" title="8. 表情"></a>8. 表情</h2><p>Github 的 Markdown 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p><p>比如<code>:blush:</code>，可以显示:blush:。</p><p>具体每一个表情的符号码，可以查询 GitHub 的官方网页<a href="http://www.emoji-cheat-sheet.com" target="_blank" rel="noopener">http://www.emoji-cheat-sheet.com</a>。</p><h2 id="9-diff-语法"><a href="#9-diff-语法" class="headerlink" title="9. diff 语法"></a>9. diff 语法</h2><p>版本控制的系统中都少不了 diff 的功能，即展示一个文件内容的增加与删除。<br>GFM 中可以显示的展示 diff 效果。使用绿色表示新增，红色表示删除。</p><p>其语法与代码高亮类似，只是在三个反引号后面写 diff，<br>并且其内容中，以 <code>+</code>开头表示新增，<code>-</code>开头表示删除。</p><p>效果如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ 鸟宿池边树，僧敲月下门</span></span><br><span class="line"><span class="deletion">- 鸟宿池边树，僧推月下门</span></span><br></pre></td></tr></table></figure><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">README</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-语法&quot;&gt;&lt;a href=&quot;#Markdown-语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown 语法&quot;&gt;&lt;/a&gt;Markdown 语法&lt;/h1&gt;&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;u
      
    
    </summary>
    
    
  </entry>
  
</feed>
