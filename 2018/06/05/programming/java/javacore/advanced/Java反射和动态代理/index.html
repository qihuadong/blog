<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/blog/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java 反射和动态代理  反射 反射简介 反射机制 Class Field Method Constructor Array   动态代理 动态代理简介 代理模式 动态代理机制 InvocationHandler Proxy 动态代理实例   推荐阅读 参考资料   反射反射简介什么是反射反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信">
<meta name="keywords" content="javacore,java,advanced">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 反射">
<meta property="og:url" content="https://dunwu.github.io/2018/06/05/programming/java/javacore/advanced/Java反射和动态代理/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:description" content="Java 反射和动态代理  反射 反射简介 反射机制 Class Field Method Constructor Array   动态代理 动态代理简介 代理模式 动态代理机制 InvocationHandler Proxy 动态代理实例   推荐阅读 参考资料   反射反射简介什么是反射反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3101171-65434596b5da72f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3101171-fa2c56240e5f7215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3101171-6269723ea61527bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3101171-6e282fabb28e4dd8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-03-06T08:43:46.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 反射">
<meta name="twitter:description" content="Java 反射和动态代理  反射 反射简介 反射机制 Class Field Method Constructor Array   动态代理 动态代理简介 代理模式 动态代理机制 InvocationHandler Proxy 动态代理实例   推荐阅读 参考资料   反射反射简介什么是反射反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/3101171-65434596b5da72f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">




  <link rel="canonical" href="https://dunwu.github.io/2018/06/05/programming/java/javacore/advanced/Java反射和动态代理/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java 反射 | 张鹏的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
            
            
            
              
              

  
  
    
  
  <li class="menu-item menu-item-docs">

    
    
    
      
    

    

    <a href="/blog/docs/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i> <br>docs</a>

  </li>


            
          
            
            
            
          
        

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/05/programming/java/javacore/advanced/Java反射和动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 反射<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/advanced/Java反射和动态代理.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-05 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-05T00:00:00+08:00">2018-06-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-06 16:43:46" itemprop="dateModified" datetime="2019-03-06T16:43:46+08:00">2019-03-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/javacore/" itemprop="url" rel="index"><span itemprop="name">javacore</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">12k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">11 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java-反射和动态代理"><a href="#Java-反射和动态代理" class="headerlink" title="Java 反射和动态代理"></a>Java 反射和动态代理</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#反射">反射</a><ul>
<li><a href="#反射简介">反射简介</a></li>
<li><a href="#反射机制">反射机制</a></li>
<li><a href="#class">Class</a></li>
<li><a href="#field">Field</a></li>
<li><a href="#method">Method</a></li>
<li><a href="#constructor">Constructor</a></li>
<li><a href="#array">Array</a></li>
</ul>
</li>
<li><a href="#动态代理">动态代理</a><ul>
<li><a href="#动态代理简介">动态代理简介</a></li>
<li><a href="#代理模式">代理模式</a></li>
<li><a href="#动态代理机制">动态代理机制</a></li>
<li><a href="#invocationhandler">InvocationHandler</a></li>
<li><a href="#proxy">Proxy</a></li>
<li><a href="#动态代理实例">动态代理实例</a></li>
</ul>
</li>
<li><a href="#推荐阅读">推荐阅读</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h3><h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<p>简而言之：<strong>通过反射，我们可以在运行时获得程序或程序集中每一个类的成员和方法。</strong></p>
<h4 id="反射的主要用途"><a href="#反射的主要用途" class="headerlink" title="反射的主要用途"></a>反射的主要用途</h4><ul>
<li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li>
<li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> - 类浏览器需要能够枚举类的成员。可视化开发环境可以利用反射中可用的类型信息来帮助开发人员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> - 调试器需要能够检查类上的私有成员。测试工具可以利用反射来系统地调用在类中定义的可发现集 API，以确保测试套件中的高级代码覆盖率。</li>
</ul>
<h4 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h4><ul>
<li><strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li>
<li><strong>安全限制</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li>
<li><strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li>
</ul>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</p>
<p>先了解一下 JVM 的类加载过程：</p>
<p><br><div align="center"><img src="https://upload-images.jianshu.io/upload_images/3101171-65434596b5da72f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>Java 编译器编译好 <code>.java</code> 文件之后，产生 <code>.class</code> 文件在磁盘中。<code>.class</code> 文件是二进制文件，内容是只有 JVM 虚拟机能够识别的机器码。JVM 虚拟机读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息，生成对应的 Class 对象。</p>
<blockquote>
<p>Tip:</p>
<p>较为流行的字节码库：</p>
<ul>
<li><strong>Javassist</strong> - 主要的优点，在于简单，而且快速。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</li>
<li><strong>ASM</strong> - 能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</li>
</ul>
</blockquote>
<p>下图为反射机制的步骤：</p>
<p><br><div align="center"><img src="https://upload-images.jianshu.io/upload_images/3101171-fa2c56240e5f7215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>步骤说明：</p>
<ol>
<li>JVM 加载方法的时候，遇到 <code>new Student()</code>，JVM 会根据 Student 的全限定名去加载 Student.class</li>
<li>JVM 会去本地磁盘查找 Student.class 文件并加载 JVM 内存中</li>
<li>JVM 通过调用类加载器自动创建这个类对应的 Class 对象，并且存储在 JVM 的方法区。注意：一个类有且只有一个 Class 对象。</li>
</ol>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>对于每种类型的对象，JVM 实例化一个 <code>java.lang.Class</code> 的不可变实例，该实例提供了检查对象的运行时属性（包括其成员和类型信息）的方法。类还提供了创建新类和对象的功能。</p>
<p>最重要的是，<strong><code>java.lang.Class</code> 是所有反射 API 的入口点</strong>。</p>
<p>java.lang.reflect 包中的类都没有 public 构造方法。</p>
<h4 id="获得-Class-对象"><a href="#获得-Class-对象" class="headerlink" title="获得 Class 对象"></a>获得 Class 对象</h4><p>获得 Class 的三种方法：</p>
<p>（1）<strong>使用 Class 类的 <code>forName</code> 静态方法</strong>，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = Class.forName(<span class="string">"io.github.dunwu.javacore.reflect.ReflectClassTest"</span>);</span><br><span class="line">Class c2 = Class.forName(<span class="string">"[D"</span>);</span><br><span class="line">Class c3 = Class.forName(<span class="string">"[[Ljava.lang.String;"</span>);</span><br></pre></td></tr></table></figure>
<p>使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。</p>
<p>（2）<strong>直接获取某一个对象的 <code>class</code></strong>，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = <span class="keyword">boolean</span>.class;</span><br><span class="line">Class c2 = java.io.PrintStream.class;</span><br><span class="line">Class c3 = <span class="keyword">int</span>[][][].class;</span><br></pre></td></tr></table></figure>
<p>（3）<strong>调用 Object 的 <code>getClass()</code> 方法</strong>，示例：</p>
<p>Object 类中有 getClass 方法，因为所有类都继承 Object 类。从而调用 Object 类来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c = <span class="string">"foo"</span>.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> E &#123;A, B&#125;</span><br><span class="line">Class c2 = E.A.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">Class c3 = bytes.getClass();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Class c4 = set.getClass();</span><br></pre></td></tr></table></figure>
<h4 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h4><p>一般地，我们用 instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 isInstance()方法来判断是否为某个类的实例，它是一个 Native 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">if</span> (arrayList <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">    System.out.println(<span class="string">"ArrayList is List"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (List.class.isInstance(arrayList)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"ArrayList is List"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>通过反射来生成对象主要有两种方式。</p>
<p>（1）使用 Class 对象的 newInstance() 方法来创建 Class 对象对应类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c1 = String.class;</span><br><span class="line">Object str1 = c1.newInstance();</span><br><span class="line">System.out.println(str1.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>
<p>（2）先通过 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c2 = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c2.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"bbb"</span>);</span><br><span class="line">System.out.println(obj.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>
<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>获取某个 Class 对象的成员变量的方法有：</p>
<ul>
<li>getFiled: 访问公有的成员变量</li>
<li>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldSpy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[][] b = &#123; &#123; <span class="keyword">false</span>, <span class="keyword">false</span> &#125;, &#123; <span class="keyword">true</span>, <span class="keyword">true</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">public</span> String name  = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> T val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field f1 = FieldSpy.class.getField(<span class="string">"b"</span>);</span><br><span class="line">Field f2 = FieldSpy.class.getField(<span class="string">"name"</span>);</span><br><span class="line">Field f3 = FieldSpy.class.getField(<span class="string">"list"</span>);</span><br><span class="line">Field f4 = FieldSpy.class.getField(<span class="string">"val"</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Type</span>: <span class="keyword">class</span> [[Z</span><br><span class="line"><span class="keyword">Type</span>: <span class="keyword">class</span> java.lang.<span class="keyword">String</span></span><br><span class="line"><span class="keyword">Type</span>: <span class="keyword">interface</span> java.util.List</span><br><span class="line"><span class="keyword">Type</span>: <span class="keyword">class</span> java.lang.<span class="keyword">Object</span></span><br></pre></td></tr></table></figure>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>获取某个 Class 对象的方法集合的方法有：</p>
<p>（1）getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods1 = Thread.class.getDeclaredMethods();</span><br><span class="line">System.out.println(<span class="string">"Thread getDeclaredMethods 清单（数量 = "</span> + methods1.length + <span class="string">"）："</span>);</span><br><span class="line"><span class="keyword">for</span> (Method m : methods1) &#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）getMethods() 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods2 = Thread.class.getMethods();</span><br><span class="line">System.out.println(<span class="string">"Thread getMethods 清单（数量 = "</span> + methods2.length + <span class="string">"）："</span>);</span><br><span class="line"><span class="keyword">for</span> (Method m : methods2) &#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）getMethod() 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应 Class 的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method = Thread.class.getMethod(<span class="string">"join"</span>, <span class="keyword">long</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(method);</span><br></pre></td></tr></table></figure>
<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>获取某个 Class 对象的构造方法集合的方法有：</p>
<p>（1）getDeclaredConstructor()方法返回类的所有构造方法，包括公共、保护、默认（包）访问和私有方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods1 = Thread.class.getDeclaredMethods();</span><br><span class="line">System.out.println(<span class="string">"Thread getDeclaredMethods 清单（数量 = "</span> + methods1.length + <span class="string">"）："</span>);</span><br><span class="line"><span class="keyword">for</span> (Method m : methods1) &#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）getConstructors() 方法返回某个类的所有公用（public）构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = FileOutputStream.class.getConstructors();</span><br><span class="line">System.out.println(<span class="string">"FileOutputStream 构造方法清单（数量 = "</span> + constructors.length + <span class="string">"）："</span>);</span><br><span class="line"><span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）getConstructor() 方法返回一个特定的方法，参数为方法的参数对应 Class 的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor constructor = FileOutputStream.class.getConstructor(String.class, <span class="keyword">boolean</span>.class);</span><br><span class="line">System.out.println(constructor);</span><br></pre></td></tr></table></figure>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个 Object Reference。下面我们看一看利用反射创建数组的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Object array = Array.newInstance(cls,<span class="number">25</span>);</span><br><span class="line">    <span class="comment">//往数组里添加内容</span></span><br><span class="line">    Array.set(array,<span class="number">0</span>,<span class="string">"hello"</span>);</span><br><span class="line">    Array.set(array,<span class="number">1</span>,<span class="string">"Java"</span>);</span><br><span class="line">    Array.set(array,<span class="number">2</span>,<span class="string">"fuck"</span>);</span><br><span class="line">    Array.set(array,<span class="number">3</span>,<span class="string">"Scala"</span>);</span><br><span class="line">    Array.set(array,<span class="number">4</span>,<span class="string">"Clojure"</span>);</span><br><span class="line">    <span class="comment">//获取某一项的内容</span></span><br><span class="line">    System.out.println(Array.get(array,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 Array 类为 java.lang.reflect.Array 类。我们通过 Array.newInstance()创建数组对象，它的原型是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="动态代理简介"><a href="#动态代理简介" class="headerlink" title="动态代理简介"></a>动态代理简介</h3><p>Java 动态代理常被用于一些 Java 框架中。例如 Spring 的 AOP ，Dubbo 的 SPI 接口，就是基于 Java 动态代理实现的。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>动态代理是设计模式中代理模式的巧妙应用。</p>
<p>先介绍一下代理模式，如下图：</p>
<p><br><div align="center"><img src="https://upload-images.jianshu.io/upload_images/3101171-6269723ea61527bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>当在代码阶段规定这种代理关系，Proxy 类通过编译器编译成 class 文件，当系统运行时，此 class 已经存在了。这种静态的代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</p>
<h3 id="动态代理机制"><a href="#动态代理机制" class="headerlink" title="动态代理机制"></a>动态代理机制</h3><p>为了解决经典代理模式的问题，就有了创建动态代理的想法：在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。</p>
<p><br><div align="center"><img src="https://upload-images.jianshu.io/upload_images/3101171-6e282fabb28e4dd8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>Java 动态代理基于经典代理模式，引入了一个 InvocationHandler，InvocationHandler 负责统一管理所有的方法调用。</p>
<p>动态代理步骤：</p>
<ol>
<li>获取 RealSubject 上的所有接口列表；</li>
<li>确定要生成的代理类的类名，默认为：<code>com.sun.proxy.$ProxyXXXX</code>；</li>
<li>根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；</li>
<li>将对应的字节码转换为对应的 class 对象；</li>
<li>创建 InvocationHandler 实例 handler，用来处理 Proxy 所有方法调用；</li>
<li>Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。</li>
</ol>
<p>从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。</p>
<p>但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。</p>
<p>在 Java 的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。</p>
<h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p><code>InvocationHandler</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个动态代理类都必须要实现 <code>InvocationHandler</code> 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 <code>InvocationHandler</code> 这个接口的 <code>invoke</code> 方法来进行调用。</p>
<p>我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>proxy</strong> - 代理的真实对象。</li>
<li><strong>method</strong> - 所要调用真实对象的某个方法的 Method 对象</li>
<li><strong>args</strong> - 所要调用真实对象某个方法时接受的参数</li>
</ul>
<p>如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 <code>newProxyInstance</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>
<p>这个方法的作用就是得到一个动态的代理对象。</p>
<p>参数说明：</p>
<ul>
<li><strong>loader</strong> - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。</li>
<li><strong>interfaces</strong> - 一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li>
<li><strong>h</strong> - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上</li>
</ul>
<h3 id="动态代理实例"><a href="#动态代理实例" class="headerlink" title="动态代理实例"></a>动态代理实例</h3><p>上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：</p>
<p>首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">bye</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello  "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Goodbye"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Over"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerDemo</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个就是我们要代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，给我们要代理的真实对象赋初值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerDemo</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"Before method"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Call Method: "</span> + method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        Object obj = method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"After method"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，来看看我们的 Client 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们要代理的真实对象</span></span><br><span class="line">        Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerDemo(realSubject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span></span><br><span class="line"><span class="comment">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        subject.hello(<span class="string">"World"</span>);</span><br><span class="line">        String result = subject.bye();</span><br><span class="line">        System.out.println(<span class="string">"Result is: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看看控制台的输出：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">com<span class="selector-class">.sun</span><span class="selector-class">.proxy</span>.<span class="variable">$Proxy0</span></span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract void io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.reflect</span><span class="selector-class">.InvocationHandlerDemo</span><span class="variable">$Subject</span>.hello(java<span class="selector-class">.lang</span><span class="selector-class">.String</span>)</span><br><span class="line">Hello  World</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract java<span class="selector-class">.lang</span><span class="selector-class">.String</span> io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.reflect</span><span class="selector-class">.InvocationHandlerDemo</span><span class="variable">$Subject</span>.bye()</span><br><span class="line">Goodbye</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Result is: Over</span><br></pre></td></tr></table></figure>
<p>我们首先来看看 <code>com.sun.proxy.$Proxy0</code> 这东西，我们看到，这个东西是由  <code>System.out.println(subject.getClass().getName());</code> 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br></pre></td></tr></table></figure>
<p>可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下<strong>为什么我们这里可以将其转化为 Subject 类型的对象？</strong></p>
<p>原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。</p>
<p><strong>同时我们一定要记住，通过 <code>Proxy.newProxyInstance</code> 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以\$开头，proxy 为中，最后一个数字表示对象的标号</strong>。</p>
<p>接着我们来看看这两句</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">subject.hello(<span class="string">"World"</span>)<span class="comment">;</span></span><br><span class="line">String result = subject.bye()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。</p>
<p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()</span><br></pre></td></tr></table></figure>
<p>正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>本文示例代码见：<a href="https://github.com/dunwu/JavaCore/tree/master/codes/advanced/src/main/java/io/github/dunwu/javacore" target="_blank" rel="noopener">源码</a></p>
<p>本文同步维护在：<a href="https://github.com/dunwu/JavaCore" target="_blank" rel="noopener">Java 系列教程</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://item.jd.com/10058164.html" target="_blank" rel="noopener">Java 编程思想（Thinking in java）</a></li>
<li><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析 Java 反射（1） - 基础</a></li>
<li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java 基础之—反射（非常重要）</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">官方 Reflection API 文档</a></li>
<li><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">java 的动态代理机制详解</a></li>
<li><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java 动态代理机制详解（JDK 和 CGLIB，Javassist，ASM）</a></li>
</ul>

      
    </div>

    
      


    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/javacore/" rel="tag"># javacore</a>
          
            <a href="/blog/tags/java/" rel="tag"># java</a>
          
            <a href="/blog/tags/advanced/" rel="tag"># advanced</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/06/04/programming/java/javacore/io/Java序列化/" rel="next" title="Java 序列化">
                <i class="fa fa-chevron-left"></i> Java 序列化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/06/09/database/nosql/redis/Redis数据类型/" rel="prev" title="Redis 数据类型">
                Redis 数据类型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">381</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/blog/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/blog/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">76</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/dunwu" title="GitHub &rarr; https://github.com/dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:forbreak@163.com" title="E-Mail &rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-反射和动态代理"><span class="nav-text">Java 反射和动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#反射简介"><span class="nav-text">反射简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是反射"><span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反射的主要用途"><span class="nav-text">反射的主要用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反射的缺点"><span class="nav-text">反射的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射机制"><span class="nav-text">反射机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-text">Class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获得-Class-对象"><span class="nav-text">获得 Class 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断是否为某个类的实例"><span class="nav-text">判断是否为某个类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建实例"><span class="nav-text">创建实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Field"><span class="nav-text">Field</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method"><span class="nav-text">Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor"><span class="nav-text">Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array"><span class="nav-text">Array</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态代理"><span class="nav-text">动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理简介"><span class="nav-text">动态代理简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理模式"><span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理机制"><span class="nav-text">动态代理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InvocationHandler"><span class="nav-text">InvocationHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy"><span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理实例"><span class="nav-text">动态代理实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#推荐阅读"><span class="nav-text">推荐阅读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.1m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">31:18</span>
  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>











  



  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/blog/js/src/utils.js?v=7.0.1"></script>

  <script src="/blog/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/blog/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/blog/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/blog/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/blog/js/src/bootstrap.js?v=7.0.1"></script>


  
  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      
        background-color: #eee;
        background-image: linear-gradient(#fcfcfc, #eee);
        border: 1px solid #d5d5d5;
        border-radius: 3px;
      
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      
        right: 4px;
        top: 8px;
      
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1;
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; // Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.readOnly = true;
        ta.value = code;
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, code.length);
        ta.readOnly = false;
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); // For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


</body>
</html>
