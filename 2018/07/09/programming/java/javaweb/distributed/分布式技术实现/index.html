<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="分布式,">





  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">






<meta name="description" content="分布式技术实现  1. 分布式事务 2. 分布式锁 2.1. 基于数据库实现分布式锁 2.2. 基于 Redis 实现分布式锁 2.3. 基于 ZooKeeper 实现分布式锁   3. 分布式 Session 3.1. Sticky Sessions 3.2. Session Replication 3.3. Session Server   4. 分布式存储 5. 分布式缓存 6. 分布式计算">
<meta name="keywords" content="分布式">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式技术实现">
<meta property="og:url" content="http://yoursite.com/2018/07/09/programming/java/javaweb/distributed/分布式技术实现/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:description" content="分布式技术实现  1. 分布式事务 2. 分布式锁 2.1. 基于数据库实现分布式锁 2.2. 基于 Redis 实现分布式锁 2.3. 基于 ZooKeeper 实现分布式锁   3. 分布式 Session 3.1. Sticky Sessions 3.2. Session Replication 3.3. Session Server   4. 分布式存储 5. 分布式缓存 6. 分布式计算">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-StickySessions.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-SessionReplication.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-SpringSession.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之轮询-01.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之轮询-02.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之加权轮询.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之最少连接-01.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之最少连接-02.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之加权最少连接.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之随机.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之IpHash.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/Http重定向.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/Dns重定向.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/修改Mac地址.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/修改IP地址.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/代理自动配置.jpg">
<meta property="og:updated_time" content="2019-03-06T08:43:46.831Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分布式技术实现">
<meta name="twitter:description" content="分布式技术实现  1. 分布式事务 2. 分布式锁 2.1. 基于数据库实现分布式锁 2.2. 基于 Redis 实现分布式锁 2.3. 基于 ZooKeeper 实现分布式锁   3. 分布式 Session 3.1. Sticky Sessions 3.2. Session Replication 3.3. Session Server   4. 分布式存储 5. 分布式缓存 6. 分布式计算">
<meta name="twitter:image" content="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-StickySessions.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/09/programming/java/javaweb/distributed/分布式技术实现/">





  <title>分布式技术实现 | 张鹏的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/09/programming/java/javaweb/distributed/分布式技术实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分布式技术实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="分布式技术实现"><a href="#分布式技术实现" class="headerlink" title="分布式技术实现"></a>分布式技术实现</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-分布式事务">1. 分布式事务</a></li>
<li><a href="#2-分布式锁">2. 分布式锁</a><ul>
<li><a href="#21-基于数据库实现分布式锁">2.1. 基于数据库实现分布式锁</a></li>
<li><a href="#22-基于-redis-实现分布式锁">2.2. 基于 Redis 实现分布式锁</a></li>
<li><a href="#23-基于-zookeeper-实现分布式锁">2.3. 基于 ZooKeeper 实现分布式锁</a></li>
</ul>
</li>
<li><a href="#3-分布式-session">3. 分布式 Session</a><ul>
<li><a href="#31-sticky-sessions">3.1. Sticky Sessions</a></li>
<li><a href="#32-session-replication">3.2. Session Replication</a></li>
<li><a href="#33-session-server">3.3. Session Server</a></li>
</ul>
</li>
<li><a href="#4-分布式存储">4. 分布式存储</a></li>
<li><a href="#5-分布式缓存">5. 分布式缓存</a></li>
<li><a href="#6-分布式计算">6. 分布式计算</a></li>
<li><a href="#7-负载均衡">7. 负载均衡</a><ul>
<li><a href="#71-算法">7.1. 算法</a></li>
<li><a href="#72-实现">7.2. 实现</a></li>
</ul>
</li>
<li><a href="#8-资料">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h2><blockquote>
<p>参考：<a href="分布式原理.md#4-分布式事务问题">分布式原理#4-分布式事务问题</a></p>
</blockquote>
<h2 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h2><p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<h3 id="2-1-基于数据库实现分布式锁"><a href="#2-1-基于数据库实现分布式锁" class="headerlink" title="2.1. 基于数据库实现分布式锁"></a>2.1. 基于数据库实现分布式锁</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-获取锁"><a href="#2-获取锁" class="headerlink" title="2. 获取锁"></a>2. 获取锁</h5><p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<h5 id="3-释放锁"><a href="#3-释放锁" class="headerlink" title="3. 释放锁"></a>3. 释放锁</h5><p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h3 id="2-2-基于-Redis-实现分布式锁"><a href="#2-2-基于-Redis-实现分布式锁" class="headerlink" title="2.2. 基于 Redis 实现分布式锁"></a>2.2. 基于 Redis 实现分布式锁</h3><p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h4 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h4><ul>
<li>setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li>expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li>delete - delete key：删除 key</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>单点实现步骤：</p>
<ol>
<li>获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul>
<li>单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。</li>
<li>如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>可以考虑使用 <a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">redisson 的解决方案</a>。</p>
<h3 id="2-3-基于-ZooKeeper-实现分布式锁"><a href="#2-3-基于-ZooKeeper-实现分布式锁" class="headerlink" title="2.3. 基于 ZooKeeper 实现分布式锁"></a>2.3. 基于 ZooKeeper 实现分布式锁</h3><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="3-分布式-Session"><a href="#3-分布式-Session" class="headerlink" title="3. 分布式 Session"></a>3. 分布式 Session</h2><p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于 cache DB 缓存的 session 共享</li>
</ol>
<h3 id="3-1-Sticky-Sessions"><a href="#3-1-Sticky-Sessions" class="headerlink" title="3.1. Sticky Sessions"></a>3.1. Sticky Sessions</h3><p>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-StickySessions.jpg"><br></div>

<h3 id="3-2-Session-Replication"><a href="#3-2-Session-Replication" class="headerlink" title="3.2. Session Replication"></a>3.2. Session Replication</h3><p>在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-SessionReplication.jpg"><br></div>

<h3 id="3-3-Session-Server"><a href="#3-3-Session-Server" class="headerlink" title="3.3. Session Server"></a>3.3. Session Server</h3><p>使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-SpringSession.jpg"><br></div>

<h2 id="4-分布式存储"><a href="#4-分布式存储" class="headerlink" title="4. 分布式存储"></a>4. 分布式存储</h2><p>通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<blockquote>
<p>参考：<a href="分布式原理.md#2-数据分布">分布式原理.md#2-数据分布</a></p>
</blockquote>
<h2 id="5-分布式缓存"><a href="#5-分布式缓存" class="headerlink" title="5. 分布式缓存"></a>5. 分布式缓存</h2><p>使用缓存的好处：</p>
<ul>
<li>提升数据读取速度</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>应用内缓存：如：EHCache</li>
<li>分布式缓存：如：Memached、Redis</li>
</ul>
<blockquote>
<p>参考：<a href="分布式原理.md#6-分布式缓存问题">分布式原理.md#6-分布式缓存问题</a></p>
</blockquote>
<h2 id="6-分布式计算"><a href="#6-分布式计算" class="headerlink" title="6. 分布式计算"></a>6. 分布式计算</h2><h2 id="7-负载均衡"><a href="#7-负载均衡" class="headerlink" title="7. 负载均衡"></a>7. 负载均衡</h2><h3 id="7-1-算法"><a href="#7-1-算法" class="headerlink" title="7.1. 算法"></a>7.1. 算法</h3><h4 id="轮询（Round-Robin）"><a href="#轮询（Round-Robin）" class="headerlink" title="轮询（Round Robin）"></a>轮询（Round Robin）</h4><p>轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之轮询-01.jpg" width="640"><br></div>

<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之轮询-02.jpg" width="640"><br></div>

<h4 id="加权轮询（Weighted-Round-Robbin）"><a href="#加权轮询（Weighted-Round-Robbin）" class="headerlink" title="加权轮询（Weighted Round Robbin）"></a>加权轮询（Weighted Round Robbin）</h4><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之加权轮询.jpg" width="640"><br></div>

<h4 id="最少连接（least-Connections）"><a href="#最少连接（least-Connections）" class="headerlink" title="最少连接（least Connections）"></a>最少连接（least Connections）</h4><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之最少连接-01.jpg" width="640"><br></div>

<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之最少连接-02.jpg" width="640"><br></div>

<h4 id="加权最少连接（Weighted-Least-Connection）"><a href="#加权最少连接（Weighted-Least-Connection）" class="headerlink" title="加权最少连接（Weighted Least Connection）"></a>加权最少连接（Weighted Least Connection）</h4><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之加权最少连接.jpg" width="640"><br></div>

<h4 id="随机算法（Random）"><a href="#随机算法（Random）" class="headerlink" title="随机算法（Random）"></a>随机算法（Random）</h4><p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之随机.jpg" width="640"><br></div>

<h4 id="源地址哈希法-IP-Hash"><a href="#源地址哈希法-IP-Hash" class="headerlink" title="源地址哈希法 (IP Hash)"></a>源地址哈希法 (IP Hash)</h4><p>源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。</p>
<ul>
<li>优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。</li>
<li>缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之IpHash.jpg" width="640"><br></div>

<h3 id="7-2-实现"><a href="#7-2-实现" class="headerlink" title="7.2. 实现"></a>7.2. 实现</h3><h4 id="HTTP-重定向"><a href="#HTTP-重定向" class="headerlink" title="HTTP 重定向"></a>HTTP 重定向</h4><p>HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/Http重定向.png" width="640"><br></div>

<h4 id="DNS-重定向"><a href="#DNS-重定向" class="headerlink" title="DNS 重定向"></a>DNS 重定向</h4><p>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>缺点：</p>
<ul>
<li>DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/Dns重定向.png" width="640"><br></div>

<h4 id="修改-MAC-地址"><a href="#修改-MAC-地址" class="headerlink" title="修改 MAC 地址"></a>修改 MAC 地址</h4><p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/修改Mac地址.png" width="640"><br></div>

<h4 id="修改-IP-地址"><a href="#修改-IP-地址" class="headerlink" title="修改 IP 地址"></a>修改 IP 地址</h4><p>在网络层修改请求的目的 IP 地址。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/修改IP地址.png" width="640"><br></div>

<h4 id="代理自动配置"><a href="#代理自动配置" class="headerlink" title="代理自动配置"></a>代理自动配置</h4><p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>PAC 服务器是用来判断一个请求是否要经过代理。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/代理自动配置.jpg" width="640"><br></div>

<h2 id="8-资料"><a href="#8-资料" class="headerlink" title="8. 资料"></a>8. 资料</h2><ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></li>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">https://juejin.im/post/5a20cd8bf265da43163cdd9a</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8</a></li>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">https://github.com/L316476844/distributed-session</a></li>
<li><a href="https://juejin.im/entry/57e39e320e3dd90058021bff" target="_blank" rel="noopener">分布式缓存架构基础</a></li>
<li><a href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&amp;utm_campaign=client_share&amp;from=singlemessage&amp;timestamp=1521281305&amp;app=news_article&amp;utm_source=weixin&amp;iid=28128279343&amp;utm_medium=toutiao_android&amp;weixin_list=1&amp;wxshare_count=2&amp;pbid=6517746516513195523" target="_blank" rel="noopener">阿里 P8 技术专家细究分布式缓存问题</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/分布式/" rel="tag"># 分布式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/07/05/programming/java/javaweb/distributed/负载均衡/" rel="next" title="负载均衡">
                <i class="fa fa-chevron-left"></i> 负载均衡
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/07/09/programming/java/javaweb/distributed/分布式原理/" rel="prev" title="分布式原理">
                分布式原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">381</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">76</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dunwu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:forbreak@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式技术实现"><span class="nav-number">1.</span> <span class="nav-text">分布式技术实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-分布式事务"><span class="nav-number">1.1.</span> <span class="nav-text">1. 分布式事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-分布式锁"><span class="nav-number">1.2.</span> <span class="nav-text">2. 分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-基于数据库实现分布式锁"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1. 基于数据库实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-创建表"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">1. 创建表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-获取锁"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">2. 获取锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-释放锁"><span class="nav-number">1.2.1.1.3.</span> <span class="nav-text">3. 释放锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决办法"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-基于-Redis-实现分布式锁"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2. 基于 Redis 实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-命令"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Redis 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-1"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-1"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-1"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-基于-ZooKeeper-实现分布式锁"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3. 基于 ZooKeeper 实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-2"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-2"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-分布式-Session"><span class="nav-number">1.3.</span> <span class="nav-text">3. 分布式 Session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Sticky-Sessions"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1. Sticky Sessions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Session-Replication"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2. Session Replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Session-Server"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3. Session Server</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-分布式存储"><span class="nav-number">1.4.</span> <span class="nav-text">4. 分布式存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-分布式缓存"><span class="nav-number">1.5.</span> <span class="nav-text">5. 分布式缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-分布式计算"><span class="nav-number">1.6.</span> <span class="nav-text">6. 分布式计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-负载均衡"><span class="nav-number">1.7.</span> <span class="nav-text">7. 负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-算法"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1. 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#轮询（Round-Robin）"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">轮询（Round Robin）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加权轮询（Weighted-Round-Robbin）"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">加权轮询（Weighted Round Robbin）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最少连接（least-Connections）"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">最少连接（least Connections）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加权最少连接（Weighted-Least-Connection）"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">加权最少连接（Weighted Least Connection）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机算法（Random）"><span class="nav-number">1.7.1.5.</span> <span class="nav-text">随机算法（Random）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源地址哈希法-IP-Hash"><span class="nav-number">1.7.1.6.</span> <span class="nav-text">源地址哈希法 (IP Hash)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-实现"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2. 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-重定向"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">HTTP 重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS-重定向"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">DNS 重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改-MAC-地址"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">修改 MAC 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改-IP-地址"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">修改 IP 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理自动配置"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">代理自动配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-资料"><span class="nav-number">1.8.</span> <span class="nav-text">8. 资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
