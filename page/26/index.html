<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="张鹏的博客">
<meta property="og:url" content="https://dunwu.github.io/page/26/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张鹏的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dunwu.github.io/page/26/">





  <title>张鹏的博客 - 大道至简，知易行难</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/08/29/programming/java/javacore/basic/3-Java基础语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/29/programming/java/javacore/basic/3-Java基础语法/" itemprop="url">Java 基础语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-29T00:00:00+08:00">
                2018-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javacore/" itemprop="url" rel="index">
                    <span itemprop="name">javacore</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><blockquote>
<p>:pushpin: <strong>关键词：</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#变量">变量</a><ul>
<li><a href="#java-局部变量">Java 局部变量</a></li>
<li><a href="#实例变量">实例变量</a></li>
<li><a href="#类变量静态变量">类变量（静态变量）</a></li>
</ul>
</li>
<li><a href="#注释">注释</a></li>
</ul>
<!-- /TOC -->
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 Java 语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier [ = value][, identifier [= value] ...] ;</span><br></pre></td></tr></table></figure>
<p>格式说明：type 为 Java 数据类型。identifier 是变量名。可以使用逗号隔开来声明多个同类型变量。</p>
<p>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;         <span class="comment">// 声明三个int型整数：a、b、c。</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">3</span>, e, f = <span class="number">5</span>; <span class="comment">// 声明三个整数并赋予初值。</span></span><br><span class="line"><span class="keyword">byte</span> z = <span class="number">22</span>;         <span class="comment">// 声明并初始化z。</span></span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14159</span>; <span class="comment">// 声明了pi。</span></span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'x'</span>;        <span class="comment">// 变量x的值是字符'x'。</span></span><br></pre></td></tr></table></figure>
<p>Java 语言支持的变量类型有：</p>
<ul>
<li>局部变量</li>
<li>实例变量</li>
<li>类变量</li>
</ul>
<h3 id="Java-局部变量"><a href="#Java-局部变量" class="headerlink" title="Java 局部变量"></a>Java 局部变量</h3><ul>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
<li>访问修饰符不能用于局部变量；</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<p>示例：</p>
<p>在以下实例中 age 是一个局部变量。定义在 pupAge() 方法中，它的作用域就限制在这个方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pupAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">      age = age + <span class="number">7</span>;</span><br><span class="line">      System.out.println(<span class="string">"Puppy age is : "</span> + age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Test test = <span class="keyword">new</span> Test();</span><br><span class="line">      test.pupAge();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Puppy age is: 7</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>在下面的例子中 age 变量没有初始化，所以在编译时出错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pupAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> age;</span><br><span class="line">      age = age + <span class="number">7</span>;</span><br><span class="line">      System.out.println(<span class="string">"Puppy age is : "</span> + age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Test test = <span class="keyword">new</span> Test();</span><br><span class="line">      test.pupAge();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:<span class="number">4</span>:variable number might not have been initialized</span><br><span class="line">age = age + <span class="number">7</span>;</span><br><span class="line">         ^</span><br><span class="line"><span class="number">1</span> error</span><br></pre></td></tr></table></figure>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量可以声明在使用前或者使用后；</li>
<li>访问修饰符可以修饰实例变量；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">   <span class="comment">// 这个成员变量对子类可见</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="comment">// 私有变量，仅在该类可见</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">   <span class="comment">//在构造器中对name赋值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span> <span class="params">(String empName)</span></span>&#123;</span><br><span class="line">      name = empName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//设定salary的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> empSal)</span></span>&#123;</span><br><span class="line">      salary = empSal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 打印信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"name  : "</span> + name );</span><br><span class="line">      System.out.println(<span class="string">"salary :"</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Employee empOne = <span class="keyword">new</span> Employee(<span class="string">"Ransika"</span>);</span><br><span class="line">      empOne.setSalary(<span class="number">1000</span>);</span><br><span class="line">      empOne.printEmp();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name  : Ransika</span><br><span class="line">salary :1000.0</span><br></pre></td></tr></table></figure>
<h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法、构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li>静态变量在程序开始时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
<li>类变量被声明为 public static final 类型时，类变量名称必须使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">   <span class="comment">//salary是静态的私有变量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> salary;</span><br><span class="line">   <span class="comment">// DEPARTMENT是一个常量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEPARTMENT = <span class="string">"Development "</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      salary = <span class="number">1000</span>;</span><br><span class="line">      System.out.println(DEPARTMENT+<span class="string">"average salary:"</span>+salary);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Development average salary:1000</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。</p>
<p>本章节中我们学习了 Java 的变量类型，下一章节中我们将介绍 Java 修饰符的使用。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>空白行，或者注释的内容，都会被 Java 编译器忽略掉。</p>
<p>Java 支持多种注释方式，下面的示例展示了各种注释的使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * JavaDoc 注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单行注释</span></span><br><span class="line">        <span class="comment">/* 多行注释：</span></span><br><span class="line"><span class="comment">           1. 注意点a</span></span><br><span class="line"><span class="comment">           2. 注意点b</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/08/22/database/sql/h2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/22/database/sql/h2/" itemprop="url">H2 数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T00:00:00+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="H2-数据库"><a href="#H2-数据库" class="headerlink" title="H2 数据库"></a>H2 数据库</h1><!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#使用说明">使用说明</a></li>
<li><a href="#spring-整合-h2">Spring 整合 H2</a></li>
<li><a href="#h2-sql">H2 SQL</a></li>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#集群">集群</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>H2 是一个开源的嵌入式数据库引擎，采用 java 语言编写，不受平台的限制。同时 H2 提供了一个十分方便的 web 控制台用于操作和管理数据库内容。H2 还提供兼容模式，可以兼容一些主流的数据库，因此采用 H2 作为开发期的数据库非常方便。</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="H2-控制台应用"><a href="#H2-控制台应用" class="headerlink" title="H2 控制台应用"></a>H2 控制台应用</h3><p>H2 允许用户通过浏览器接口方式访问 SQL 数据库。</p>
<ol>
<li>进入<a href="http://www.h2database.com/html/download.html" target="_blank" rel="noopener">官方下载地址</a>，选择合适版本，下载并安装到本地。</li>
<li>启动方式：在 bin 目录下，双击 jar 包；执行 <code>java -jar h2*.jar</code>；执行脚本：<code>h2.bat</code> 或 <code>h2.sh</code>。</li>
<li>在浏览器中访问：<a href="http://localhost:8082，应该可以看到下图中的页面：" target="_blank" rel="noopener">http://localhost:8082，应该可以看到下图中的页面：</a></li>
</ol>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/h2/h2-console.png"></div><br></p>
<p>点击 <strong>Connect</strong> ，可以进入操作界面：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/h2/h2-console-02.png"></div><br></p>
<p>操作界面十分简单，不一一细说。</p>
<h3 id="嵌入式应用"><a href="#嵌入式应用" class="headerlink" title="嵌入式应用"></a>嵌入式应用</h3><h4 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.</span><br><span class="line">    getConnection(<span class="string">"jdbc:h2:~/test"</span>);</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详见：<a href="http://www.h2database.com/html/tutorial.html#connecting_using_jdbc" target="_blank" rel="noopener">Using the JDBC API</a></p>
</blockquote>
<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.h2.jdbcx.JdbcConnectionPool;</span><br><span class="line">JdbcConnectionPool cp = JdbcConnectionPool.</span><br><span class="line">create(<span class="string">"jdbc:h2:~/test"</span>, <span class="string">"sa"</span>, <span class="string">"sa"</span>);</span><br><span class="line">Connection conn = cp.getConnection();</span><br><span class="line">conn.close(); cp.dispose();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详见：<a href="http://www.h2database.com/html/tutorial.html#connection_pool" target="_blank" rel="noopener">Connection Pool</a></p>
</blockquote>
<h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.197<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详见：<a href="http://www.h2database.com/html/build.html#maven2" target="_blank" rel="noopener">Maven 2</a></p>
</blockquote>
<h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><p>hibernate.cfg.xml (or use the HSQLDialect):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span></span><br><span class="line">    org.hibernate.dialect.H2Dialect</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详见：<a href="http://www.h2database.com/html/tutorial.html#using_hibernate" target="_blank" rel="noopener">Hibernate</a></p>
</blockquote>
<h4 id="TopLink-和-Glassfish"><a href="#TopLink-和-Glassfish" class="headerlink" title="TopLink 和 Glassfish"></a>TopLink 和 Glassfish</h4><p>Datasource class: <code>org.h2.jdbcx.JdbcDataSource</code><br><code>oracle.toplink.essentials.platform.database.H2Platform</code></p>
<blockquote>
<p>详见：<a href="http://www.h2database.com/html/tutorial.html#using_toplink" target="_blank" rel="noopener">TopLink and Glassfish</a></p>
</blockquote>
<h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><h4 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h4><p>数据库持久化存储为单个文件。</p>
<p>连接字符串：<code>\~/.h2/DBName</code> 表示数据库文件的存储位置，如果第一次连接则会自动创建数据库。</p>
<ul>
<li><code>jdbc:h2:\~/test</code> - ‘test’ 在用户根目录下</li>
<li><code>jdbc:h2:/data/test</code> - ‘test’ 在 /data 目录下</li>
<li><code>jdbc:h2:test</code> - ‘test’ 在当前工作目录</li>
</ul>
<h4 id="内存式"><a href="#内存式" class="headerlink" title="内存式"></a>内存式</h4><p>数据库只在内存中运行，关闭连接后数据库将被清空，适合测试环境</p>
<p>连接字符串：<code>jdbc:h2:mem:DBName;DB_CLOSE_DELAY=-1</code></p>
<p>如果不指定 DBName，则以私有方式启动，只允许一个连接。</p>
<ul>
<li><code>jdbc:h2:mem:test</code> -  一个进程中有多个连接</li>
<li><code>jdbc:h2:mem:</code> -  未命名的私有库，一个连接</li>
</ul>
<h4 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h4><p>H2 支持三种服务模式：</p>
<ul>
<li>web server：此种运行方式支持使用浏览器访问 H2 Console</li>
<li>TCP server：支持客户端/服务器端的连接方式</li>
<li>PG server：支持 PostgreSQL 客户端</li>
</ul>
<p>启动 tcp 服务连接字符串示例：</p>
<ul>
<li><code>jdbc:h2:tcp://localhost/\~/test</code> - 用户根目录</li>
<li><code>jdbc:h2:tcp://localhost//data/test</code> - 绝对路径</li>
</ul>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>执行 <code>java -cp *.jar org.h2.tools.Server</code></p>
<p>执行如下命令，获取选项列表及默认值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp h2*.jar org.h2.tools.Server -?</span><br></pre></td></tr></table></figure>
<p>常见的选项如下：</p>
<ul>
<li>-web：启动支持 H2 Console 的服务</li>
<li>-webPort <port>：服务启动端口，默认为 8082</port></li>
<li>-browser：启动 H2 Console web 管理页面</li>
<li>-tcp：使用 TCP server 模式启动</li>
<li>-pg：使用 PG server 模式启动</li>
</ul>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ul>
<li><code>jdbc:h2:..;MODE=MySQL</code>  兼容模式（或 HSQLDB 等）</li>
<li><code>jdbc:h2:..;TRACE_LEVEL_FILE=3</code>  记录到 <code>*.trace.db</code></li>
</ul>
<h4 id="连接字符串参数"><a href="#连接字符串参数" class="headerlink" title="连接字符串参数"></a>连接字符串参数</h4><ul>
<li><code>DB_CLOSE_DELAY</code> - 要求最后一个正在连接的连接断开后，不要关闭数据库</li>
<li><code>MODE=MySQL</code> - 兼容模式，H2 兼容多种数据库，该值可以为：DB2、Derby、HSQLDB、MSSQLServer、MySQL、Oracle、PostgreSQL</li>
<li><code>AUTO_RECONNECT=TRUE</code> - 连接丢失后自动重新连接</li>
<li><code>AUTO_SERVER=TRUE</code> - 启动自动混合模式，允许开启多个连接，该参数不支持在内存中运行模式</li>
<li><code>TRACE_LEVEL_SYSTEM_OUT</code>、<code>TRACE_LEVEL_FILE</code> - 输出跟踪日志到控制台或文件， 取值 0 为 OFF，1 为 ERROR（默认值），2 为 INFO，3 为 DEBUG</li>
<li><code>SET TRACE_MAX_FILE_SIZE mb</code> - 设置跟踪日志文件的大小，默认为 16M</li>
</ul>
<h4 id="maven-方式"><a href="#maven-方式" class="headerlink" title="maven 方式"></a>maven 方式</h4><p>此外，使用 maven 也可以启动 H2 服务。添加以下插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>exec-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.h2.tools.Server<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arguments</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">argument</span>&gt;</span>-web<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">argument</span>&gt;</span>-webPort<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">argument</span>&gt;</span>8090<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">argument</span>&gt;</span>-browser<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在命令行中执行如下命令启动 H2 Console</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn exec:java</span><br></pre></td></tr></table></figure>
<p>或者建立一个 bat 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">call mvn exec:java</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>此操作相当于执行了如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar h2-1.3.168.jar -web -webPort 8090 -browser</span><br></pre></td></tr></table></figure>
<h2 id="Spring-整合-H2"><a href="#Spring-整合-H2" class="headerlink" title="Spring 整合 H2"></a>Spring 整合 H2</h2><ol>
<li>添加依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.194<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>spring 配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/jdbc</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/jdbc/spring-jdbc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.h2.jdbcx.JdbcConnectionPool"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"dispose"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.h2.jdbcx.JdbcDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内存模式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"URL"</span> <span class="attr">value</span>=<span class="string">"jdbc:h2:mem:test"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件模式 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="URL" value="jdbc:h2:testRestDB" /&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- JDBC模板 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myJdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.zp.notes.spring.jdbc.MyJdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">ref</span>=<span class="string">"jdbcTemplate"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 初始化数据表结构 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jdbc:initialize-database</span> <span class="attr">data-source</span>=<span class="string">"dataSource"</span> <span class="attr">ignore-failures</span>=<span class="string">"ALL"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:sql/h2/create_table_student.sql"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">jdbc:initialize-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="H2-SQL"><a href="#H2-SQL" class="headerlink" title="H2 SQL"></a>H2 SQL</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-a3f90c0d1f1f3437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-6a92ae4362c3468a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-dddf0e26995d46c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-96e72023445a6fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="BACKUP"><a href="#BACKUP" class="headerlink" title="BACKUP"></a>BACKUP</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-6267894d24fab47f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-bbed6bb69f998b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>7、MERGE<br><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-bd021648431d12a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="RUNSCRIPT"><a href="#RUNSCRIPT" class="headerlink" title="RUNSCRIPT"></a>RUNSCRIPT</h3><p>运行 sql 脚本文件</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-d6fe03eff0037e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="SCRIPT"><a href="#SCRIPT" class="headerlink" title="SCRIPT"></a>SCRIPT</h3><p>根据数据库创建 sql 脚本</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-9ba7547ab8bcaeab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="SHOW"><a href="#SHOW" class="headerlink" title="SHOW"></a>SHOW</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-67449c6cc5cbb8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h3><h4 id="ALTER-INDEX-RENAME"><a href="#ALTER-INDEX-RENAME" class="headerlink" title="ALTER INDEX RENAME"></a>ALTER INDEX RENAME</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-230bd3f97e185d2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="ALTER-SCHEMA-RENAME"><a href="#ALTER-SCHEMA-RENAME" class="headerlink" title="ALTER SCHEMA RENAME"></a>ALTER SCHEMA RENAME</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-797a028938e46ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="ALTER-SEQUENCE"><a href="#ALTER-SEQUENCE" class="headerlink" title="ALTER SEQUENCE"></a>ALTER SEQUENCE</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-46f343da1b6c6a29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-7e146a4010f2f357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h5 id="增加约束"><a href="#增加约束" class="headerlink" title="增加约束"></a>增加约束</h5><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-4e5605a9c87a79cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h5 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h5><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-fbc1358c553e6614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h5 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h5><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-dc3b897413700981.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h5 id="删除序列"><a href="#删除序列" class="headerlink" title="删除序列"></a>删除序列</h5><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-ec83899cb8724966.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="ALTER-USER"><a href="#ALTER-USER" class="headerlink" title="ALTER USER"></a>ALTER USER</h4><h5 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h5><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-a1e429c0d8ece66c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h5 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h5><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-5b86f98796606e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="ALTER-VIEW"><a href="#ALTER-VIEW" class="headerlink" title="ALTER VIEW"></a>ALTER VIEW</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-8832ecbc2db63a13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="COMMENT"><a href="#COMMENT" class="headerlink" title="COMMENT"></a>COMMENT</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-467ce031883f0020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-CONSTANT"><a href="#CREATE-CONSTANT" class="headerlink" title="CREATE CONSTANT"></a>CREATE CONSTANT</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-1231c83563bfec9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-d66d59bd7803d5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-ROLE"><a href="#CREATE-ROLE" class="headerlink" title="CREATE ROLE"></a>CREATE ROLE</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-7df1dee098e1127b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-SCHEMA"><a href="#CREATE-SCHEMA" class="headerlink" title="CREATE SCHEMA"></a>CREATE SCHEMA</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c485123c62c0866e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-SEQUENCE"><a href="#CREATE-SEQUENCE" class="headerlink" title="CREATE SEQUENCE"></a>CREATE SEQUENCE</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-cc25860776d361ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-36ffc66327df8b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-TRIGGER"><a href="#CREATE-TRIGGER" class="headerlink" title="CREATE TRIGGER"></a>CREATE TRIGGER</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-9a7bfa4425281213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-USER"><a href="#CREATE-USER" class="headerlink" title="CREATE USER"></a>CREATE USER</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-a1e45e308be6dac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="CREATE-VIEW"><a href="#CREATE-VIEW" class="headerlink" title="CREATE VIEW"></a>CREATE VIEW</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-45c4cd516fd36611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-52a3562d76411811.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="GRANT-RIGHT"><a href="#GRANT-RIGHT" class="headerlink" title="GRANT RIGHT"></a>GRANT RIGHT</h3><p>给 schema 授权授权</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-750e96ceff00c4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>给 schema 授权给 schema 授权</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-22cfd65c2ff1eea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="复制角色的权限"><a href="#复制角色的权限" class="headerlink" title="复制角色的权限"></a>复制角色的权限</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-6cba2f1585fd913b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="REVOKE-RIGHT"><a href="#REVOKE-RIGHT" class="headerlink" title="REVOKE RIGHT"></a>REVOKE RIGHT</h3><h4 id="移除授权"><a href="#移除授权" class="headerlink" title="移除授权"></a>移除授权</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-3f905669cbb331b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="移除角色具有的权限"><a href="#移除角色具有的权限" class="headerlink" title="移除角色具有的权限"></a>移除角色具有的权限</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-af77f495222f1b30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h3><h4 id="从某个还原点（savepoint）回滚"><a href="#从某个还原点（savepoint）回滚" class="headerlink" title="从某个还原点（savepoint）回滚"></a>从某个还原点（savepoint）回滚</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c71a226ac4fff913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-efb65c504c7d69c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h4 id="创建-savepoint"><a href="#创建-savepoint" class="headerlink" title="创建 savepoint"></a>创建 savepoint</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-feefdc236d4b211d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-52296dd53249cdae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="INT-Type"><a href="#INT-Type" class="headerlink" title="INT Type"></a>INT Type</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-fe62e3d07eb93d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>H2 支持两台服务器运行两个数据库成为集群，两个数据库互为备份，如果一个服务器失效，另一个服务器仍然可以工作。另外只有服务模式支持集群配置。</p>
<p>H2 可以通过 CreateCluster 工具创建集群，示例步骤如下（在在一台服务器上模拟两个数据库组成集群）：</p>
<ul>
<li>创建目录<ul>
<li>创建两个服务器工作的目录</li>
</ul>
</li>
<li>启动 tcp 服务<ul>
<li>执行如下命令分别在 9101、9102 端口启动两个使用 tcp 服务模式的数据库</li>
</ul>
</li>
<li>使用 CreateCluster 工具创建集群<ul>
<li>如果两个数据库不存在，该命令将会自动创建数据库。如果一个数据库失效，可以先删除坏的数据库文件，重新启动数据库，然后重新运行 CreateCluster 工具</li>
</ul>
</li>
<li>连接数据库现在可以使用如下连接字符串连接集群数据库<ul>
<li>监控集群<strong>运行状态</strong></li>
<li>可以使用如下命令查看配置的集群服务器是否都在运行</li>
</ul>
</li>
<li>限制<ul>
<li>H2 的集群并不支持针对事务的负载均衡，所以很多操作会使两个数据库产生不一致的结果</li>
</ul>
</li>
<li>执行如下操作时请小心：<ul>
<li>自动增长列和标识列不支持集群，当插入数据时，序列值需要手动创建不支持 SET AUTOCOMMIT FALSE 语句；</li>
<li>如果需要设置成为不自动提交，可以执行方法 Connection.setAutoCommit(false)</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.h2database.com/html/main.html" target="_blank" rel="noopener">h2database 官网</a></li>
<li><a href="https://www.cnblogs.com/xdp-gacl/p/4171024.html" target="_blank" rel="noopener">Java 嵌入式数据库 H2 学习总结(一)——H2 数据库入门</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/08/06/programming/java/javaweb/architecture/网站的安全架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/06/programming/java/javaweb/architecture/网站的安全架构/" itemprop="url">网站的安全架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-06T00:00:00+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javaweb/" itemprop="url" rel="index">
                    <span itemprop="name">javaweb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网站的安全架构"><a href="#网站的安全架构" class="headerlink" title="网站的安全架构"></a>网站的安全架构</h1><blockquote>
<p>关键词：XSS、CSRF、SQL 注入、DoS、消息摘要、加密算法、证书</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-网站安全的攻与防">1. 网站安全的攻与防</a><ul>
<li><a href="#11-跨站脚本攻击xss">1.1. 跨站脚本攻击（XSS）</a></li>
<li><a href="#12-跨站请求伪造csrf">1.2. 跨站请求伪造（CSRF）</a></li>
<li><a href="#13-sql-注入攻击">1.3. SQL 注入攻击</a></li>
<li><a href="#14-拒绝服务攻击dos">1.4. 拒绝服务攻击（DoS）</a></li>
</ul>
</li>
<li><a href="#2-加密技术及密钥安全管理">2. 加密技术及密钥安全管理</a><ul>
<li><a href="#21-消息摘要">2.1. 消息摘要</a></li>
<li><a href="#22-加密算法">2.2. 加密算法</a></li>
<li><a href="#23-证书">2.3. 证书</a></li>
</ul>
</li>
<li><a href="#3-资料">3. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-网站安全的攻与防"><a href="#1-网站安全的攻与防" class="headerlink" title="1. 网站安全的攻与防"></a>1. 网站安全的攻与防</h2><p>互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：</p>
<h3 id="1-1-跨站脚本攻击（XSS）"><a href="#1-1-跨站脚本攻击（XSS）" class="headerlink" title="1.1. 跨站脚本攻击（XSS）"></a>1.1. 跨站脚本攻击（XSS）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>跨站脚本攻击（Cross-Site Scripting, XSS），是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。</p>
<p>XSS 攻击示例：</p>
<p>假如有下面一个 textbox</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">"value1from"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>value1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 <code>&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</code> 那么就会变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">!-</span> "&gt;</span></span><br></pre></td></tr></table></figure>
<p>嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。</p>
<h4 id="攻击手段和目的"><a href="#攻击手段和目的" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h4><p>常用的 XSS 攻击手段和目的有：</p>
<ul>
<li>盗用 cookie，获取敏感信息。</li>
<li>利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。</li>
<li>利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>
<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>
<li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。</li>
</ul>
<h4 id="应对手段"><a href="#应对手段" class="headerlink" title="应对手段"></a>应对手段</h4><ul>
<li><strong>过滤特殊字符</strong> - 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如 <code>&gt;</code> 转义为 <code>&amp;gt</code>、<code>&lt;</code> 转义为 <code>&amp;lt</code> 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 <code>3&lt;5</code> 中的 <code>&lt;</code> 需要进行文本匹配后再转移，如：<code>&lt;img src=</code> 这样的上下文中的 <code>&lt;</code> 才转义。</li>
<li><strong>设置 Cookie 为 HttpOnly</strong> - 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
</ul>
</blockquote>
<h3 id="1-2-跨站请求伪造（CSRF）"><a href="#1-2-跨站请求伪造（CSRF）" class="headerlink" title="1.2. 跨站请求伪造（CSRF）"></a>1.2. 跨站请求伪造（CSRF）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>跨站请求伪造（Cross-site request forgery，CSRF），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<h4 id="攻击手段和目的-1"><a href="#攻击手段和目的-1" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h4><p>可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。</p>
<p>CSRF 能做的事太多：</p>
<ul>
<li>以你名义发送邮件，发消息</li>
<li>用你的账号购买商品</li>
<li>用你的名义完成虚拟货币转账</li>
<li>泄露个人隐私</li>
<li>…</li>
</ul>
<h4 id="应对手段-1"><a href="#应对手段-1" class="headerlink" title="应对手段"></a>应对手段</h4><ul>
<li><strong>表单 Token</strong> - CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。</li>
<li><strong>验证码</strong> - 请求提交是，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。</li>
<li><strong>Referer check</strong> - HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
</ul>
</blockquote>
<h3 id="1-3-SQL-注入攻击"><a href="#1-3-SQL-注入攻击" class="headerlink" title="1.3. SQL 注入攻击"></a>1.3. SQL 注入攻击</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>SQL 注入攻击（SQL injection），是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p>
<p>攻击示例：</p>
<p>考虑以下简单的登录表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们的处理里面的 SQL 可能是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username:=r.Form.Get("username")</span><br><span class="line">password:=r.Form.Get("password")</span><br><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'"+username+"'</span> <span class="keyword">AND</span> <span class="keyword">password</span>=<span class="string">'"+password+"'</span><span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>如果用户的输入的用户名如下，密码任意</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myuser' or 'foo' = 'foo' <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>那么我们的 SQL 变成了如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'myuser'</span> <span class="keyword">or</span> <span class="string">'foo'</span> = <span class="string">'foo'</span> <span class="comment">--'' AND password='xxx'</span></span><br></pre></td></tr></table></figure>
<p>在 SQL 里面 <code>--</code> 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p>
<p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%"+prod+"%'</span><span class="string">"</span></span><br><span class="line"><span class="string">Db.Exec(sql)</span></span><br></pre></td></tr></table></figure>
<p>如果攻击提交 <code>a%&#39; exec master..xp_cmdshell &#39;net user test testpass /ADD&#39; --</code> 作为变量 prod 的值，那么 sql 将会变成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%a%'</span> exec master..xp_cmdshell <span class="string">'net user test testpass /ADD'</span><span class="comment">--%'"</span></span><br></pre></td></tr></table></figure>
<p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p>
<p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p>
<h4 id="攻击手段和目的-2"><a href="#攻击手段和目的-2" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h4><ul>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如 <code>SELECT * FROM sys.tables</code>）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如 <code>ALTER LOGIN sa WITH PASSWORD=&#39;xxxxxx&#39;</code>）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin”可停止服务器的 IIS 服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。</li>
</ul>
<h4 id="应对手段-2"><a href="#应对手段-2" class="headerlink" title="应对手段"></a>应对手段</h4><ul>
<li><strong>使用参数化查询</strong> - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database/sql 里面的查询函数 <code>Prepare</code> 和 <code>Query</code> ，或者 <code>Exec(query string, args ...interface{})</code>。</li>
<li><strong>单引号转换</strong> - 在组合 SQL 字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续 2 个单引号字符）。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
</ul>
</blockquote>
<h3 id="1-4-拒绝服务攻击（DoS）"><a href="#1-4-拒绝服务攻击（DoS）" class="headerlink" title="1.4. 拒绝服务攻击（DoS）"></a>1.4. 拒绝服务攻击（DoS）</h3><p>拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。</p>
<h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><ul>
<li>带宽消耗型攻击</li>
<li>资源消耗型攻击</li>
</ul>
<h4 id="应对手段-3"><a href="#应对手段-3" class="headerlink" title="应对手段"></a>应对手段</h4><ul>
<li>防火墙 - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。</li>
<li>路由器、交换机 - 具有速度限制和访问控制能力。</li>
<li>流量清洗 - 通过采用抗 DDoS 软件处理，将正常流量和恶意流量区分开。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
</ul>
</blockquote>
<h2 id="2-加密技术及密钥安全管理"><a href="#2-加密技术及密钥安全管理" class="headerlink" title="2. 加密技术及密钥安全管理"></a>2. 加密技术及密钥安全管理</h2><p>对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。</p>
<p>信息加密技术一般分为：</p>
<ul>
<li>消息摘要</li>
<li>加密算法<ul>
<li>对称加密</li>
<li>非对称加密</li>
</ul>
</li>
<li>证书</li>
</ul>
<h3 id="2-1-消息摘要"><a href="#2-1-消息摘要" class="headerlink" title="2.1. 消息摘要"></a>2.1. 消息摘要</h3><p>常用数字签名算法：MD5、SHA 等。</p>
<p>应用场景：将用户密码以消息摘要形式保存到数据库中。</p>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/JavaCore/blob/master/docs/advanced/encode/java-message-digest.md" target="_blank" rel="noopener">消息摘要</a></li>
</ul>
</blockquote>
<h3 id="2-2-加密算法"><a href="#2-2-加密算法" class="headerlink" title="2.2. 加密算法"></a>2.2. 加密算法</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密指加密和解密所使用的密钥是同一个密钥。</p>
<p>常用对称加密算法：DES 等。</p>
<p>应用场景：Cookie 加密、通信机密等。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。</p>
<p>常用非对称加密算法：RSA 等。</p>
<p>应用场景：HTTPS 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。</p>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/JavaCore/blob/master/docs/advanced/encode/java-encryption.md" target="_blank" rel="noopener">加密</a></li>
</ul>
</blockquote>
<h4 id="2-3-密钥安全管理"><a href="#2-3-密钥安全管理" class="headerlink" title="2.3. 密钥安全管理"></a>2.3. 密钥安全管理</h4><p>保证密钥安全的方法：</p>
<ol>
<li>把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。</li>
<li>把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。</li>
</ol>
<h3 id="2-3-证书"><a href="#2-3-证书" class="headerlink" title="2.3. 证书"></a>2.3. 证书</h3><p>证书可以称为信息安全加密的终极手段。公开密钥认证（英语：Public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。</p>
<p>透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 TLS 实现并在万维网的 HTTP 以 HTTPS、在电子邮件的 SMTP 以 STARTTLS 引入并广泛应用。</p>
<p>众所周知，常见的应用层协议 HTTP、FTP、Telnet 本身不保证信息安全。但是加入了 SSL/TLS 加密数据包机制的 HTTPS、FTPS、Telnets 是信息安全的。</p>
<h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>传输层安全性协议（Transport Layer Security, TLS），及其前身安全套接层（Secure Sockets Layer, SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。</p>
<h4 id="证书原理"><a href="#证书原理" class="headerlink" title="证书原理"></a>证书原理</h4><p>SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>这里有两个问题：</p>
<p>（1）<strong>如何保证公钥不被篡改？</strong></p>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<p>（2）<strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p>
<p>SSL/TLS 协议的基本过程是这样的：</p>
<ol>
<li>客户端向服务器端索要并验证公钥。</li>
<li>双方协商生成”对话密钥”。</li>
<li>双方采用”对话密钥”进行加密通信。</li>
</ol>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
</ul>
</blockquote>
<h2 id="3-资料"><a href="#3-资料" class="headerlink" title="3. 资料"></a>3. 资料</h2><ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/08/02/programming/java/spring/spring-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/02/programming/java/spring/spring-interview/" itemprop="url">Spring 常见面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T00:00:00+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-常见面试问题"><a href="#Spring-常见面试问题" class="headerlink" title="Spring 常见面试问题"></a>Spring 常见面试问题</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-一般问题">1. 一般问题</a><ul>
<li><a href="#11-不同版本的-spring-framework-有哪些主要功能">1.1. 不同版本的 Spring Framework 有哪些主要功能？</a></li>
<li><a href="#12-什么是-spring-framework">1.2. 什么是 Spring Framework？</a></li>
<li><a href="#13-列举-spring-framework-的优点">1.3. 列举 Spring Framework 的优点。</a></li>
<li><a href="#14-spring-framework-有哪些不同的功能">1.4. Spring Framework 有哪些不同的功能？</a></li>
<li><a href="#15-spring-framework-中有多少个模块它们分别是什么">1.5. Spring Framework 中有多少个模块，它们分别是什么？</a></li>
<li><a href="#16-什么是-spring-配置文件">1.6. 什么是 Spring 配置文件？</a></li>
<li><a href="#17-spring-应用程序有哪些不同组件">1.7. Spring 应用程序有哪些不同组件？</a></li>
<li><a href="#18-使用-spring-有哪些方式">1.8. 使用 Spring 有哪些方式？</a></li>
</ul>
</li>
<li><a href="#2-依赖注入ioc">2. 依赖注入（Ioc）</a><ul>
<li><a href="#21-什么是-spring-ioc-容器">2.1. 什么是 Spring IOC 容器？</a></li>
<li><a href="#22-什么是依赖注入">2.2. 什么是依赖注入？</a></li>
<li><a href="#23-可以通过多少种方式完成依赖注入">2.3. 可以通过多少种方式完成依赖注入？</a></li>
<li><a href="#24-区分构造函数注入和-setter-注入">2.4. 区分构造函数注入和 setter 注入。</a></li>
<li><a href="#25-spring-中有多少种-ioc-容器">2.5. spring 中有多少种 IOC 容器？</a></li>
<li><a href="#26-区分-beanfactory-和-applicationcontext">2.6. 区分 BeanFactory 和 ApplicationContext。</a></li>
<li><a href="#27-列举-ioc-的一些好处">2.7. 列举 IoC 的一些好处。</a></li>
<li><a href="#28-spring-ioc-的实现机制">2.8. Spring IoC 的实现机制。</a></li>
</ul>
</li>
<li><a href="#3-beans">3. Beans</a><ul>
<li><a href="#31-什么是-spring-bean">3.1. 什么是 spring bean？</a></li>
<li><a href="#32-spring-提供了哪些配置方式">3.2. spring 提供了哪些配置方式？</a></li>
<li><a href="#33-spring-支持集中-bean-scope">3.3. spring 支持集中 bean scope？</a></li>
<li><a href="#34-spring-bean-容器的生命周期是什么样的">3.4. spring bean 容器的生命周期是什么样的？</a></li>
<li><a href="#35-什么是-spring-的内部-bean">3.5. 什么是 spring 的内部 bean？</a></li>
<li><a href="#36-什么是-spring-装配">3.6. 什么是 spring 装配</a></li>
<li><a href="#37-自动装配有哪些方式">3.7. 自动装配有哪些方式？</a></li>
<li><a href="#38-自动装配有什么局限">3.8. 自动装配有什么局限？</a></li>
</ul>
</li>
<li><a href="#4-注解">4. 注解</a><ul>
<li><a href="#41-你用过哪些重要的-spring-注解">4.1. 你用过哪些重要的 Spring 注解？</a></li>
<li><a href="#42-如何在-spring-中启动注解装配">4.2. 如何在 spring 中启动注解装配？</a></li>
<li><a href="#43-component-controller-repository-service-有何区别">4.3. @Component, @Controller, @Repository, @Service 有何区别？</a></li>
<li><a href="#44-required-注解有什么用">4.4. @Required 注解有什么用？</a></li>
<li><a href="#45-autowired-注解有什么用">4.5. @Autowired 注解有什么用？</a></li>
<li><a href="#46-qualifier-注解有什么用">4.6. @Qualifier 注解有什么用？</a></li>
<li><a href="#47-requestmapping-注解有什么用">4.7. @RequestMapping 注解有什么用？</a></li>
</ul>
</li>
<li><a href="#5-数据访问">5. 数据访问</a><ul>
<li><a href="#51-spring-dao-有什么用">5.1. spring DAO 有什么用？</a></li>
<li><a href="#52-列举-spring-dao-抛出的异常">5.2. 列举 Spring DAO 抛出的异常。</a></li>
<li><a href="#53-spring-jdbc-api-中存在哪些类">5.3. spring JDBC API 中存在哪些类？</a></li>
<li><a href="#54-使用-spring-访问-hibernate-的方法有哪些">5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</a></li>
<li><a href="#55-列举-spring-支持的事务管理类型">5.5. 列举 spring 支持的事务管理类型</a></li>
<li><a href="#56-spring-支持哪些-orm-框架">5.6. spring 支持哪些 ORM 框架</a></li>
</ul>
</li>
<li><a href="#6-aop">6. AOP</a><ul>
<li><a href="#61-什么是-aop">6.1. 什么是 AOP？</a></li>
<li><a href="#62-aop-中的-aspectadvicepointcutjointpoint-和-advice-参数分别是什么">6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？</a></li>
<li><a href="#63-什么是通知advice">6.3. 什么是通知（Advice）？</a></li>
<li><a href="#64-有哪些类型的通知advice">6.4. 有哪些类型的通知（Advice）？</a></li>
<li><a href="#65-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处">6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</a></li>
<li><a href="#66-aop-有哪些实现方式">6.6. AOP 有哪些实现方式？</a></li>
<li><a href="#67-spring-aop-and-aspectj-aop-有什么区别">6.7. Spring AOP and AspectJ AOP 有什么区别？</a></li>
<li><a href="#68-如何理解-spring-中的代理">6.8. 如何理解 Spring 中的代理？</a></li>
<li><a href="#69-什么是编织weaving">6.9. 什么是编织（Weaving）？</a></li>
</ul>
</li>
<li><a href="#7-mvc">7. MVC</a><ul>
<li><a href="#71-spring-mvc-框架有什么用">7.1. Spring MVC 框架有什么用？</a></li>
<li><a href="#72-描述一下-dispatcherservlet-的工作流程">7.2. 描述一下 DispatcherServlet 的工作流程</a></li>
<li><a href="#73-介绍一下-webapplicationcontext">7.3. 介绍一下 WebApplicationContext</a></li>
</ul>
</li>
<li><a href="#8-资料">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-一般问题"><a href="#1-一般问题" class="headerlink" title="1. 一般问题"></a>1. 一般问题</h2><h3 id="1-1-不同版本的-Spring-Framework-有哪些主要功能？"><a href="#1-1-不同版本的-Spring-Framework-有哪些主要功能？" class="headerlink" title="1.1. 不同版本的 Spring Framework 有哪些主要功能？"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能？</h3><table>
<thead>
<tr>
<th>Version</th>
<th>Feature</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring 2.5</td>
<td>发布于 2007 年。这是第一个支持注解的版本。</td>
</tr>
<tr>
<td>Spring 3.0</td>
<td>发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。</td>
</tr>
<tr>
<td>Spring 4.0</td>
<td>发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</td>
</tr>
</tbody>
</table>
<h3 id="1-2-什么是-Spring-Framework？"><a href="#1-2-什么是-Spring-Framework？" class="headerlink" title="1.2. 什么是 Spring Framework？"></a>1.2. 什么是 Spring Framework？</h3><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h3 id="1-3-列举-Spring-Framework-的优点。"><a href="#1-3-列举-Spring-Framework-的优点。" class="headerlink" title="1.3. 列举 Spring Framework 的优点。"></a>1.3. 列举 Spring Framework 的优点。</h3><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h3 id="1-4-Spring-Framework-有哪些不同的功能？"><a href="#1-4-Spring-Framework-有哪些不同的功能？" class="headerlink" title="1.4. Spring Framework 有哪些不同的功能？"></a>1.4. Spring Framework 有哪些不同的功能？</h3><ul>
<li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li>
<li><strong>IOC</strong> - 控制反转</li>
<li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h3 id="1-5-Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="1.5. Spring Framework 中有多少个模块，它们分别是什么？"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么？</h3><p><br><div align="center"><img src="http://oyz7npk35.bkt.clouddn.com/image/spring/introduction/spring-framework.png"></div><br></p>
<ul>
<li><strong>Spring 核心容器</strong> – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li><strong>数据访问/集成</strong> – 该层提供与数据库交互的支持。它包含以下模块：<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li><strong>Web</strong> – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li><strong>AOP</strong> – 该层支持面向切面编程</li>
<li><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</li>
<li><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li>
<li><strong>几个杂项模块:</strong><ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h3 id="1-6-什么是-Spring-配置文件？"><a href="#1-6-什么是-Spring-配置文件？" class="headerlink" title="1.6. 什么是 Spring 配置文件？"></a>1.6. 什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="1-7-Spring-应用程序有哪些不同组件？"><a href="#1-7-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.7. Spring 应用程序有哪些不同组件？"></a>1.7. Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li><strong>接口</strong> - 定义功能。</li>
<li><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</li>
<li><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</li>
<li><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</li>
<li><strong>用户程序</strong> - 它使用接口。</li>
</ul>
<h3 id="1-8-使用-Spring-有哪些方式？"><a href="#1-8-使用-Spring-有哪些方式？" class="headerlink" title="1.8. 使用 Spring 有哪些方式？"></a>1.8. 使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h2 id="2-依赖注入（Ioc）"><a href="#2-依赖注入（Ioc）" class="headerlink" title="2. 依赖注入（Ioc）"></a>2. 依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器？"><a href="#2-1-什么是-Spring-IOC-容器？" class="headerlink" title="2.1. 什么是 Spring IOC 容器？"></a>2.1. 什么是 Spring IOC 容器？</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p><br><div align="center"><img src="https://upload-images.jianshu.io/upload_images/3101171-33099411d16ca051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h3 id="2-2-什么是依赖注入？"><a href="#2-2-什么是依赖注入？" class="headerlink" title="2.2. 什么是依赖注入？"></a>2.2. 什么是依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<h3 id="2-3-可以通过多少种方式完成依赖注入？"><a href="#2-3-可以通过多少种方式完成依赖注入？" class="headerlink" title="2.3. 可以通过多少种方式完成依赖注入？"></a>2.3. 可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<h3 id="2-4-区分构造函数注入和-setter-注入。"><a href="#2-4-区分构造函数注入和-setter-注入。" class="headerlink" title="2.4. 区分构造函数注入和 setter 注入。"></a>2.4. 区分构造函数注入和 setter 注入。</h3><table>
<thead>
<tr>
<th>构造函数注入</th>
<th>setter 注入</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody>
</table>
<h3 id="2-5-spring-中有多少种-IOC-容器？"><a href="#2-5-spring-中有多少种-IOC-容器？" class="headerlink" title="2.5. spring 中有多少种 IOC 容器？"></a>2.5. spring 中有多少种 IOC 容器？</h3><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h3 id="2-6-区分-BeanFactory-和-ApplicationContext。"><a href="#2-6-区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="2.6. 区分 BeanFactory 和 ApplicationContext。"></a>2.6. 区分 BeanFactory 和 ApplicationContext。</h3><table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody>
<tr>
<td>它使用懒加载</td>
<td>它使用即时加载</td>
</tr>
<tr>
<td>它使用语法显式提供资源对象</td>
<td>它自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody>
</table>
<h3 id="2-7-列举-IoC-的一些好处。"><a href="#2-7-列举-IoC-的一些好处。" class="headerlink" title="2.7. 列举 IoC 的一些好处。"></a>2.7. 列举 IoC 的一些好处。</h3><p>IoC 的一些好处是：</p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h3 id="2-8-Spring-IoC-的实现机制。"><a href="#2-8-Spring-IoC-的实现机制。" class="headerlink" title="2.8. Spring IoC 的实现机制。"></a>2.8. Spring IoC 的实现机制。</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">"io.github.dunwu.spring.Apple"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Beans"><a href="#3-Beans" class="headerlink" title="3. Beans"></a>3. Beans</h2><h3 id="3-1-什么是-spring-bean？"><a href="#3-1-什么是-spring-bean？" class="headerlink" title="3.1. 什么是 spring bean？"></a>3.1. 什么是 spring bean？</h3><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h3 id="3-2-spring-提供了哪些配置方式？"><a href="#3-2-spring-提供了哪些配置方式？" class="headerlink" title="3.2. spring 提供了哪些配置方式？"></a>3.2. spring 提供了哪些配置方式？</h3><ul>
<li>基于 xml 配置</li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentbean"</span> <span class="attr">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Edureka"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>基于注解配置</li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>基于 Java API 配置</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-spring-支持集中-bean-scope？"><a href="#3-3-spring-支持集中-bean-scope？" class="headerlink" title="3.3. spring 支持集中 bean scope？"></a>3.3. spring 支持集中 bean scope？</h3><p>Spring bean 支持 5 种 scope：</p>
<ul>
<li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li>
<li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li>
<li><strong>Request</strong> - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li><strong>Session</strong> - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>Global-session</strong> - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</p>
<h3 id="3-4-spring-bean-容器的生命周期是什么样的？"><a href="#3-4-spring-bean-容器的生命周期是什么样的？" class="headerlink" title="3.4. spring bean 容器的生命周期是什么样的？"></a>3.4. spring bean 容器的生命周期是什么样的？</h3><p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（<code>&lt;bean&gt;</code> 的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（<code>&lt;bean&gt;</code> 的 destroy-method 属性），那么将调用它。</li>
</ol>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/spring-notes/master/images/spring/core/spring-bean-life.png"></div><br></p>
<h3 id="3-5-什么是-spring-的内部-bean？"><a href="#3-5-什么是-spring-的内部-bean？" class="headerlink" title="3.5. 什么是 spring 的内部 bean？"></a>3.5. 什么是 spring 的内部 bean？</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <code>&lt;property&gt;</code> 或 <code>&lt;constructor-arg&gt;</code> 中提供了 <code>&lt;bean&gt;</code> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。</p>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>" <span class="attr">class</span>=<span class="string">"com.edureka.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--This is inner bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.edureka.Person"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">“Scott</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-什么是-spring-装配"><a href="#3-6-什么是-spring-装配" class="headerlink" title="3.6. 什么是 spring 装配"></a>3.6. 什么是 spring 装配</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h3 id="3-7-自动装配有哪些方式？"><a href="#3-7-自动装配有哪些方式？" class="headerlink" title="3.7. 自动装配有哪些方式？"></a>3.7. 自动装配有哪些方式？</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li><strong>构造函数</strong> - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li><strong>autodetect</strong> - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<h3 id="3-8-自动装配有什么局限？"><a href="#3-8-自动装配有什么局限？" class="headerlink" title="3.8. 自动装配有什么局限？"></a>3.8. 自动装配有什么局限？</h3><ul>
<li>覆盖的可能性 - 您始终可以使用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h2 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h2><h3 id="4-1-你用过哪些重要的-Spring-注解？"><a href="#4-1-你用过哪些重要的-Spring-注解？" class="headerlink" title="4.1. 你用过哪些重要的 Spring 注解？"></a>4.1. 你用过哪些重要的 Spring 注解？</h3><ul>
<li><strong>@Controller</strong> - 用于 Spring MVC 项目中的控制器类。</li>
<li><strong>@Service</strong> - 用于服务类。</li>
<li><strong>@RequestMapping</strong> - 用于在控制器处理程序方法中配置 URI 映射。</li>
<li><strong>@ResponseBody</strong> - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。</li>
<li><strong>@PathVariable</strong> - 用于将动态值从 URI 映射到处理程序方法参数。</li>
<li><strong>@Autowired</strong> - 用于在 spring bean 中自动装配依赖项。</li>
<li><strong>@Qualifier</strong> - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。</li>
<li><strong>@Scope</strong> - 用于配置 spring bean 的范围。</li>
<li><strong>@Configuration</strong>，<strong>@ComponentScan</strong> 和 <strong>@Bean</strong> - 用于基于 java 的配置。</li>
<li><strong>@Aspect</strong>，<strong>@Before</strong>，<strong>@After</strong>，<strong>@Around</strong>，<strong>@Pointcut</strong> - 用于切面编程（AOP）。</li>
</ul>
<h3 id="4-2-如何在-spring-中启动注解装配？"><a href="#4-2-如何在-spring-中启动注解装配？" class="headerlink" title="4.2. 如何在 spring 中启动注解装配？"></a>4.2. 如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p>
<h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3. @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h3 id="4-4-Required-注解有什么用？"><a href="#4-4-Required-注解有什么用？" class="headerlink" title="4.4. @Required 注解有什么用？"></a>4.4. @Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-Autowired-注解有什么用？"><a href="#4-5-Autowired-注解有什么用？" class="headerlink" title="4.5. @Autowired 注解有什么用？"></a>4.5. @Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-Qualifier-注解有什么用？"><a href="#4-6-Qualifier-注解有什么用？" class="headerlink" title="4.6. @Qualifier 注解有什么用？"></a>4.6. @Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<p>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p>
<p>Employee.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(emp1)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“Employee name : ”+emp.getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-RequestMapping-注解有什么用？"><a href="#4-7-RequestMapping-注解有什么用？" class="headerlink" title="4.7. @RequestMapping 注解有什么用？"></a>4.7. @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="5-数据访问"><a href="#5-数据访问" class="headerlink" title="5. 数据访问"></a>5. 数据访问</h2><h3 id="5-1-spring-DAO-有什么用？"><a href="#5-1-spring-DAO-有什么用？" class="headerlink" title="5.1. spring DAO 有什么用？"></a>5.1. spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="5-2-列举-Spring-DAO-抛出的异常。"><a href="#5-2-列举-Spring-DAO-抛出的异常。" class="headerlink" title="5.2. 列举 Spring DAO 抛出的异常。"></a>5.2. 列举 Spring DAO 抛出的异常。</h3><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/spring-notes/master/images/spring/data-access/spring-data-access-exception.png"></div><br></p>
<h3 id="5-3-spring-JDBC-API-中存在哪些类？"><a href="#5-3-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.3. spring JDBC API 中存在哪些类？"></a>5.3. spring JDBC API 中存在哪些类？</h3><ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.4. 使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5. 列举 spring 支持的事务管理类型"></a>5.5. 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<h3 id="5-6-spring-支持哪些-ORM-框架"><a href="#5-6-spring-支持哪些-ORM-框架" class="headerlink" title="5.6. spring 支持哪些 ORM 框架"></a>5.6. spring 支持哪些 ORM 框架</h3><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h2 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6. AOP"></a>6. AOP</h2><h3 id="6-1-什么是-AOP？"><a href="#6-1-什么是-AOP？" class="headerlink" title="6.1. 什么是 AOP？"></a>6.1. 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？"><a href="#6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？" class="headerlink" title="6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？"></a>6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？</h3><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/spring-notes/master/images/spring/core/spring-aop.png"></div><br></p>
<ul>
<li><strong>Aspect</strong> - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。</li>
<li><strong>Advice</strong> - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。</li>
<li><strong>Advice Arguments</strong> - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。</li>
<li><strong>Pointcut</strong> - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。 Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。</li>
<li><strong>JoinPoint</strong> - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。</li>
</ul>
<h3 id="6-3-什么是通知（Advice）？"><a href="#6-3-什么是通知（Advice）？" class="headerlink" title="6.3. 什么是通知（Advice）？"></a>6.3. 什么是通知（Advice）？</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h3 id="6-4-有哪些类型的通知（Advice）？"><a href="#6-4-有哪些类型的通知（Advice）？" class="headerlink" title="6.4. 有哪些类型的通知（Advice）？"></a>6.4. 有哪些类型的通知（Advice）？</h3><ul>
<li><strong>Before</strong> - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li><strong>After Returning</strong> - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li><strong>After Throwing</strong> - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li><strong>After (finally)</strong> - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li><strong>Around</strong> - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<h3 id="6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p>
<p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<h3 id="6-6-AOP-有哪些实现方式？"><a href="#6-6-AOP-有哪些实现方式？" class="headerlink" title="6.6. AOP 有哪些实现方式？"></a>6.6. AOP 有哪些实现方式？</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
</ul>
</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<h3 id="6-7-Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#6-7-Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="6.7. Spring AOP and AspectJ AOP 有什么区别？"></a>6.7. Spring AOP and AspectJ AOP 有什么区别？</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h3 id="6-8-如何理解-Spring-中的代理？"><a href="#6-8-如何理解-Spring-中的代理？" class="headerlink" title="6.8. 如何理解 Spring 中的代理？"></a>6.8. 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Advice + Target Object = Proxy</span><br></pre></td></tr></table></figure>
<h3 id="6-9-什么是编织（Weaving）？"><a href="#6-9-什么是编织（Weaving）？" class="headerlink" title="6.9. 什么是编织（Weaving）？"></a>6.9. 什么是编织（Weaving）？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p>
<p><br><div align="center"><img src="https://upload-images.jianshu.io/upload_images/3101171-cfaa92f0e4115b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<h2 id="7-MVC"><a href="#7-MVC" class="headerlink" title="7. MVC"></a>7. MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用？"><a href="#7-1-Spring-MVC-框架有什么用？" class="headerlink" title="7.1. Spring MVC 框架有什么用？"></a>7.1. Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2. 描述一下 DispatcherServlet 的工作流程"></a>7.2. 描述一下 DispatcherServlet 的工作流程</h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>
<p><br><div align="center"><img src="http://oyz7npk35.bkt.clouddn.com/image/spring/web/spring-dispatcher-servlet.png"></div><br></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 <code>DispatcherServlet</code> 捕获。</li>
<li><code>DispatcherServlet</code> 根据 <strong><servlet-name>-servlet.xml</servlet-name></strong> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以<code>HandlerExecutionChain</code> 对象的形式返回。</li>
<li><code>DispatcherServlet</code> 根据获得的<code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。（附注：如果成功获得<code>HandlerAdapter</code>后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取<code>Request</code>中的模型数据，填充<code>Handler</code>入参，开始执行<code>Handler</code>（<code>Controller</code>)。 在填充<code>Handler</code>的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ul>
<li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如<code>String</code>转换成<code>Integer</code>、<code>Double</code>等。</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</li>
</ul>
</li>
<li>Handler(Controller)执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code> 对象；</li>
<li>根据返回的<code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>（必须是已经注册到 Spring 容器中的<code>ViewResolver</code>)返回给<code>DispatcherServlet</code>。</li>
<li><code>ViewResolver</code> 结合<code>Model</code>和<code>View</code>，来渲染视图。</li>
<li>视图负责将渲染结果返回给客户端。</li>
</ol>
<h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3. 介绍一下 WebApplicationContext"></a>7.3. 介绍一下 WebApplicationContext</h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>
<p>（完）</p>
<hr>
<p>:point_right: 想学习更多 Spring 内容可以访问我的 Spring 教程：<strong><a href="https://github.com/dunwu/spring-notes" target="_blank" rel="noopener">spring-notes</a></strong></p>
<h2 id="8-资料"><a href="#8-资料" class="headerlink" title="8. 资料"></a>8. 资料</h2><ul>
<li><a href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/" target="_blank" rel="noopener">Top 50 Spring Interview Questions You Must Prepare In 2018</a></li>
<li><a href="https://www.journaldev.com/2696/spring-interview-questions-and-answers" target="_blank" rel="noopener">Spring Interview Questions and Answers</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/07/17/programming/java/javaweb/distributed/mq/rocketmq-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/17/programming/java/javaweb/distributed/mq/rocketmq-advanced/" itemprop="url">RocketMQ 原理篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T00:00:00+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javaweb/" itemprop="url" rel="index">
                    <span itemprop="name">javaweb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RocketMQ-原理篇"><a href="#RocketMQ-原理篇" class="headerlink" title="RocketMQ 原理篇"></a>RocketMQ 原理篇</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#架构">架构</a><ul>
<li><a href="#nameserver">NameServer</a></li>
<li><a href="#broker">Broker</a></li>
<li><a href="#producer">Producer</a></li>
<li><a href="#consumer">Consumer</a></li>
</ul>
</li>
<li><a href="#关键特性以及其实现原理">关键特性以及其实现原理</a><ul>
<li><a href="#顺序消息">顺序消息</a></li>
<li><a href="#消息重复">消息重复</a></li>
<li><a href="#事务消息">事务消息</a></li>
</ul>
</li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/rocketmq/rmq-basic-arc.png"><br>&lt;/div<br><br>RocketMQ 由四部分组成：NameServer、Broker、Producer、Consumer。其中任意一个组成都可以水平扩展为集群模式，以避免单点故障问题。<br><br>### NameServer<br><br>NameServer 提供轻量级的服务发现和路由能力。每个 NameServer 节点记录全部的路由信息，支持相应的读写操作，并支持快速存储扩展。<br><br>NameServer 是一个功能齐全的服务器，主要包括两个功能：<br><br>1.  Broker 管理 - NameServer 接受来自 Broker 集群的注册，并提供心跳机制来检查 Broker 节点是否存活。<br>2.  路由管理 - 每个 NameServer 将保存有关 Broker 集群的完整路由信息和客户端查询的查询队列。<br><br>RocketMQ 客户端（Producer/Consumer）将从 NameServer 查询队列路由信息。<br><br>将 NameServer 地址列表提供给客户端有四种方法：<br><br>1.  编程方式 - 类似：<code>producer.setNamesrvAddr(&quot;ip:port&quot;)</code><br>2.  Java 选项 - 使用 <code>rocketmq.namesrv.addr</code> 参数<br>3.  环境变量 - 设置环境变量 <code>NAMESRV_ADDR</code><br>4.  HTTP 端点<br><br>&gt; 更详细信息可以参考官方文档：<a href="http://rocketmq.apache.org/rocketmq/four-methods-to-feed-name-server-address-list/" target="_blank" rel="noopener">here</a><br><br>### Broker<br><br>Broker 通过提供轻量级的 TOPIC 和 QUEUE 机制来处理消息存储。它们支持 Push 和 Pull 模型，包含容错机制（2 个副本或 3 个副本），并提供强大的峰值填充和以原始时间顺序累积数千亿条消息的能力。此外，Brokers 还提供灾难恢复，丰富的指标统计和警报机制。<br><br>Broker 有几个重要的子模块：<br><br>- Remoting Module - 即代理的条目，处理来自客户端的请求。<br>- Client Manager - 管理客户（生产者/消费者）并维护消费者的主题订阅。<br>- Store 服务 - 提供简单的 API 来存储或查询物理磁盘中的消息。<br>- HA 服务 - 提供主代理和从代理之间的数据同步功能。<br>- Index 服务 - 按指定密钥构建消息索引，并提供快速消息查询。<br><br><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/rocketmq/rmq-basic-component.png"><br></div>

<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producers 支持分布式部署。Distributed Producers 通过多种负载均衡模式向 Broker 集群发送消息。发送过程支持快速故障并具有低延迟。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer 也支持 Push 和 Pull 模型中的分布式部署。它还支持群集消费和消息广播。它提供实时消息订阅机制，可以满足大多数消费者的需求。 RocketMQ 的网站为感兴趣的用户提供了一个简单的快速入门指南。</p>
<h2 id="关键特性以及其实现原理"><a href="#关键特性以及其实现原理" class="headerlink" title="关键特性以及其实现原理"></a>关键特性以及其实现原理</h2><p>分布式消息系统作为实现分布式系统可扩展、可伸缩性的关键组件，需要具有高吞吐量、高可用等特点。而谈到消息系统的设计，就回避不了两个问题：</p>
<ol>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ol>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><h4 id="第一种模型"><a href="#第一种模型" class="headerlink" title="第一种模型"></a>第一种模型</h4><p>假如生产者产生了 2 条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-bb5ec534363e2fb4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，那么需要 M1 到达消费端被消费后，通知 S2，然后 S2 再将 M2 发送到消费端。</p>
<p>这个模型存在的问题是，如果 M1 和 M2 分别发送到两台 Server 上，就不能保证 M1 先达到 MQ 集群，也不能保证 M1 被先消费。换个角度看，如果 M2 先于 M1 达到 MQ 集群，甚至 M2 被消费后，M1 才达到消费端，这时消息也就乱序了，说明以上模型是不能保证消息的顺序的。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-5a6313fe906a678b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h4 id="第二种模型"><a href="#第二种模型" class="headerlink" title="第二种模型"></a>第二种模型</h4><p>如何才能在 MQ 集群保证消息的顺序？一种简单的方式就是将 M1、M2 发送到同一个 Server 上：</p>
<p>这样可以保证 M1 先于 M2 到达 MQServer（生产者等待 M1 发送成功后再发送 M2），根据先达到先被消费的原则，M1 会先于 M2 被消费，这样就保证了消息的顺序。</p>
<p>这个模型也仅仅是理论上可以保证消息的顺序，在实际场景中可能会遇到下面的问题：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-d430f5a3ec6c48ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送 M1 耗时大于发送 M2 的耗时，那么 M2 就仍将被先消费，仍然不能保证消息的顺序。即使 M1 和 M2 同时到达消费端，由于不清楚消费端 1 和消费端 2 的负载情况，仍然有可能出现 M2 先于 M1 被消费的情况。</p>
<p>如何解决这个问题？将 M1 和 M2 发往同一个消费者，且发送 M1 后，需要消费端响应成功后才能发送 M2。</p>
<p>这可能产生另外的问题：如果 M1 被发送到消费端后，消费端 1 没有响应，那是继续发送 M2 呢，还是重新发送 M1？一般为了保证消息一定被消费，肯定会选择重发 M1 到另外一个消费端 2，就如下图所示。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-3c0e822d37a85e1e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端 1 没有响应 Server 时有两种情况，一种是 M1 确实没有到达(数据在网络传送中丢失)，另外一种消费端已经消费 M1 且已经发送响应消息，只是 MQ Server 端没有收到。如果是第二种情况，重发 M1，就会造成 M1 被重复消费。也就引入了我们要说的第二个问题，消息重复问题，这个后文会详细讲解。</p>
<p>回过头来看消息顺序问题，严格的顺序消息非常容易理解，也可以通过文中所描述的方式来简单处理。总结起来，要实现严格的顺序消息，简单且可行的办法就是：</p>
<p><strong>保证生产者 - MQServer - 消费者是一对一对一的关系。</strong></p>
<p>这样的设计虽然简单易行，但也会存在一些很严重的问题，比如：</p>
<ol>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li>
</ol>
<p>RocketMQ 的解决方案：通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。从这个角度来看消息的顺序问题，我们可以得出两个结论：</p>
<ol>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序</li>
</ol>
<p>最后我们从源码角度分析 RocketMQ 怎么实现发送顺序消息。</p>
<p>RocketMQ 通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RocketMQ 通过 MessageQueueSelector 中实现的算法来确定消息发送到哪一个队列上</span></span><br><span class="line"><span class="comment">// RocketMQ 默认提供了两种 MessageQueueSelector 实现：随机/Hash</span></span><br><span class="line"><span class="comment">// 当然你可以根据业务实现自己的 MessageQueueSelector 来决定消息按照何种策略发送到消息队列中</span></span><br><span class="line">SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        Integer id = (Integer) arg;</span><br><span class="line">        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, orderId);</span><br></pre></td></tr></table></figure>
<p>在获取到路由信息以后，会根据 MessageQueueSelector 实现的算法来选择一个队列，同一个 OrderId 获取到的肯定是同一个队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">send</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 获取topic路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据我们的算法，选择一个发送队列</span></span><br><span class="line">        <span class="comment">// 这里的arg = orderId</span></span><br><span class="line">        mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">        <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h3><p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性。</li>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。</li>
</ol>
<p>第 1 条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</p>
<p>第 2 条原理就是利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<p>第 1 条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。</p>
<p>第 2 条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是 RocketMQ 不解决消息重复的问题的原因。</p>
<p><strong>RocketMQ 不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</strong></p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>RocketMQ 除了支持普通消息，顺序消息，另外还支持事务消息。</p>
<p>假设这样的场景：</p>
<p><br><div align="center"><img src="https://upload-images.jianshu.io/upload_images/3101171-253d8bd65736694f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>图中执行本地事务（Bob 账户扣款）和发送异步消息应该保证同时成功或者同时失败，也就是扣款成功了，发送消息一定要成功，如果扣款失败了，就不能再发送消息。那问题是：我们是先扣款还是先发送消息呢？</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-088dc074c4ecd192?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>RocketMQ 分布式事务步骤：</p>
<p>发送 Prepared 消息 2222222222222222222，并拿到接受消息的地址。<br>执行本地事务<br>通过第 1 步骤拿到的地址去访问消息，并修改消息状态。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="http://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">RocketMQ 官方文档</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></li>
</ul>
</div>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/07/17/programming/java/javaweb/distributed/mq/rocketmq-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/17/programming/java/javaweb/distributed/mq/rocketmq-basics/" itemprop="url">RocketMQ 实战篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T00:00:00+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javaweb/" itemprop="url" rel="index">
                    <span itemprop="name">javaweb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RocketMQ-实战篇"><a href="#RocketMQ-实战篇" class="headerlink" title="RocketMQ 实战篇"></a>RocketMQ 实战篇</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#概述">概述</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#核心概念">核心概念</a></li>
</ul>
</li>
<li><a href="#安装">安装</a><ul>
<li><a href="#环境要求">环境要求</a></li>
<li><a href="#下载解压">下载解压</a></li>
<li><a href="#启动-name-server">启动 Name Server</a></li>
<li><a href="#启动-broker">启动 Broker</a></li>
<li><a href="#收发消息">收发消息</a></li>
<li><a href="#关闭服务器">关闭服务器</a></li>
</ul>
</li>
<li><a href="#api">API</a><ul>
<li><a href="#producer">Producer</a></li>
<li><a href="#consumer">Consumer</a></li>
<li><a href="#faq">FAQ</a></li>
</ul>
</li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>RocketMQ 是一款开源的分布式消息队列，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p>
<p>RocketMQ 被阿里巴巴捐赠给 Apache，成为 Apache 的孵化项目。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/rocketmq/rmq-model.png"><br></div>

<p>RocketMQ 有以下核心概念：</p>
<ul>
<li><strong>Producer</strong> - 将业务应用程序系统生成的消息发送给代理。RocketMQ 提供多种发送范例：同步，异步和单向。<ul>
<li><strong>Producer Group</strong> - 具有相同角色的 Producer 组合在一起。如果原始 Producer 在事务之后崩溃，则代理可以联系同一 Producer 组的不同 Producer 实例以提交或回滚事务。<strong><em>警告：考虑到提供的 Producer 在发送消息方面足够强大，每个 Producer 组只允许一个实例，以避免不必要的生成器实例初始化。</em></strong></li>
</ul>
</li>
<li><strong>Consumer</strong> - Consumer 从 Broker 那里获取消息并将其提供给应用程序。从用户应用的角度来看，提供了两种类型的 Consumer：<ul>
<li><strong>PullConsumer</strong> - PullConsumer 积极地从 Broker 那里获取消息。一旦提取了批量消息，用户应用程序就会启动消费过程。</li>
<li><strong>PushConsumer</strong> - PushConsumer 封装消息提取，消费进度并维护其他内部工作，为最终用户留下回调接口，这个借口会在消息到达时被执行。</li>
<li><strong>Consumer Group</strong> - 完全相同角色的 Consumer 被组合在一起并命名为 Consumer Group。Consumer Group 是一个很好的概念，在消息消费方面实现负载平衡和容错目标非常容易。<strong><em>警告：Consumer Group 中的 Consumer 实例必须具有完全相同的主题订阅。</em></strong></li>
</ul>
</li>
<li><strong>Broker</strong> - Broker 是 RocketMQ 的主要组成部分。它接收从 Producer 发送的消息，存储它们并准备处理来自 Consumer 的消费请求。它还存储与消息相关的元数据，包括 Consumer Group，消耗进度偏移和主题/队列信息。</li>
<li>Name Server - 充当路由信息提供者。Producer/Consumer 客户查找主题以查找相应的 Broker 列表。</li>
<li><strong>Topic</strong> - 是 Producer 传递消息和 Consumer 提取消息的类别。</li>
<li><strong>Message</strong> - 是要传递的信息。消息必须有一个主题，可以将其解释为您要发送给的邮件地址。消息还可以具有可选 Tag 和额外的键值对。例如，您可以为消息设置业务密钥，并在代理服务器上查找消息以诊断开发期间的问题。<ul>
<li><strong>Message Queue</strong> - 主题被划分为一个或多个子主题“消息队列”。</li>
<li><strong>Tag</strong> - 即子主题，为用户提供了额外的灵活性。对于 Tag，来自同一业务模块的具有不同目的的消息可以具有相同的主题和不同的 Tag。</li>
</ul>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><ul>
<li>推荐 64 位操作系统：Linux/Unix/Mac</li>
<li>64bit JDK 1.8+</li>
<li>Maven 3.2.x</li>
<li>Git</li>
</ul>
<h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p>进入官方下载地址：<a href="https://rocketmq.apache.org/dowloading/releases/，选择合适版本" target="_blank" rel="noopener">https://rocketmq.apache.org/dowloading/releases/，选择合适版本</a></p>
<p>建议选择 binary 版本。</p>
<p>解压到本地：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; unzip rocketmq-all-4.2.0-source-release.zip</span><br><span class="line">&gt; <span class="built_in">cd</span> rocketmq-all-4.2.0/</span><br></pre></td></tr></table></figure>
<h3 id="启动-Name-Server"><a href="#启动-Name-Server" class="headerlink" title="启动 Name Server"></a>启动 Name Server</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure>
<h3 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line">The broker[%s, 172.30.30.233:10911] boot success...</span><br></pre></td></tr></table></figure>
<h3 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h3><p>执行收发消息操作之前，不许告诉客户端命名服务器的位置。在 RocketMQ 中有多种方法来实现这个目的。这里，我们使用最简单的方法——设置环境变量 <code>NAMESRV_ADDR</code> ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId= ...</span><br><span class="line"></span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line">ConsumeMessageThread_%d Receive New Messages: [MessageExt...</span><br></pre></td></tr></table></figure>
<h3 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh bin/mqshutdown broker</span><br><span class="line">The mqbroker(36695) is running...</span><br><span class="line">Send shutdown request to mqbroker(36695) OK</span><br><span class="line"></span><br><span class="line">&gt; sh bin/mqshutdown namesrv</span><br><span class="line">The mqnamesrv(36664) is running...</span><br><span class="line">Send shutdown request to mqnamesrv(36664) OK</span><br></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>首先在项目中引入 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producer 在 RocketMQ 中负责发送消息。</p>
<p>RocketMQ 有三种消息发送方式：</p>
<ul>
<li>可靠的同步发送</li>
<li>可靠的异步发送</li>
<li>单项发送</li>
</ul>
<h4 id="可靠的同步发送"><a href="#可靠的同步发送" class="headerlink" title="可靠的同步发送"></a>可靠的同步发送</h4><p>可靠的同步传输用于广泛的场景，如重要的通知消息，短信通知，短信营销系统等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可靠的异步发送"><a href="#可靠的异步发送" class="headerlink" title="可靠的异步发送"></a>可靠的异步发送</h4><p>异步传输通常用于响应时间敏感的业务场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单向传输"><a href="#单向传输" class="headerlink" title="单向传输"></a>单向传输</h4><p>单向传输用于需要中等可靠性的情况，例如日志收集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer 在 RocketMQ 中负责接收消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"example_group_name"</span>);</span><br><span class="line">        consumer.setNamesrvAddr(RocketConfig.HOST);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">            AtomicLong consumeTimes = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                context.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">                System.out.printf(Thread.currentThread().getName() + <span class="string">" Receive New Messages: "</span> + msgs + <span class="string">"%n"</span>);</span><br><span class="line">                <span class="keyword">this</span>.consumeTimes.incrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.ROLLBACK;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.COMMIT;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    context.setSuspendCurrentQueueTimeMillis(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="connect-to-lt-172-17-0-1-10909-gt-failed"><a href="#connect-to-lt-172-17-0-1-10909-gt-failed" class="headerlink" title="connect to &lt;172.17.0.1:10909&gt; failed"></a>connect to &lt;172.17.0.1:10909&gt; failed</h4><p>启动后，Producer 客户端连接 RocketMQ 时报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;<span class="number">172.17</span>.0.1:<span class="number">10909</span>&gt; failed</span><br><span class="line">    at org.apache.rocketmq.remoting.netty.NettyRemotingClient.invokeSync(NettyRemotingClient.java:<span class="number">357</span>)</span><br><span class="line">    at org.apache.rocketmq.client.impl.MQClientAPIImpl.sendMessageSync(MQClientAPIImpl.java:<span class="number">343</span>)</span><br><span class="line">    at org.apache.rocketmq.client.impl.MQClientAPIImpl.sendMessage(MQClientAPIImpl.java:<span class="number">327</span>)</span><br><span class="line">    at org.apache.rocketmq.client.impl.MQClientAPIImpl.sendMessage(MQClientAPIImpl.java:<span class="number">290</span>)</span><br><span class="line">    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendKernelImpl(DefaultMQProducerImpl.java:<span class="number">688</span>)</span><br><span class="line">    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendSelectImpl(DefaultMQProducerImpl.java:<span class="number">901</span>)</span><br><span class="line">    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:<span class="number">878</span>)</span><br><span class="line">    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:<span class="number">873</span>)</span><br><span class="line">    at org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:<span class="number">369</span>)</span><br><span class="line">    at com.emrubik.uc.mdm.sync.utils.MdmInit.sendMessage(MdmInit.java:<span class="number">62</span>)</span><br><span class="line">    at com.emrubik.uc.mdm.sync.utils.MdmInit.main(MdmInit.java:<span class="number">2149</span>)</span><br></pre></td></tr></table></figure>
<p>原因：RocketMQ 部署在虚拟机上，内网 ip 为 10.10.30.63，该虚拟机一个 docker0 网卡，ip 为 172.17.0.1。RocketMQ broker 启动时默认使用了 docker0 网卡，Producer 客户端无法连接 172.17.0.1，造成以上问题。</p>
<p>解决方案</p>
<p>（1）干掉 docker0 网卡或修改网卡名称</p>
<p>（2）停掉 broker，修改 broker 配置文件，重启 broker。</p>
<p>修改 conf/broker.conf，增加两行来指定启动 broker 的 IP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">namesrvAddr = 10.10.30.63:9876</span><br><span class="line">brokerIP1 = 10.10.30.63</span><br></pre></td></tr></table></figure>
<p>启动时需要指定配置文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="http://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">RocketMQ 官方文档</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/07/14/programming/java/javaweb/architecture/大型系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/14/programming/java/javaweb/architecture/大型系统设计/" itemprop="url">大型系统架构设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-14T00:00:00+08:00">
                2018-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="大型系统架构设计"><a href="#大型系统架构设计" class="headerlink" title="大型系统架构设计"></a>大型系统架构设计</h1><!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#1-性能与可扩展性">1. 性能与可扩展性</a></li>
<li><a href="#2-延迟与吞吐量">2. 延迟与吞吐量</a></li>
<li><a href="#3-可用性与一致性">3. 可用性与一致性</a></li>
<li><a href="#4-一致性模式">4. 一致性模式</a></li>
<li><a href="#5-可用性模式">5. 可用性模式</a></li>
<li><a href="#6-域名系统">6. 域名系统</a></li>
<li><a href="#7-内容分发网络cdn">7. 内容分发网络（CDN）</a></li>
<li><a href="#8-负载均衡器">8. 负载均衡器</a></li>
<li><a href="#9-反向代理web-服务器">9. 反向代理（web 服务器）</a></li>
<li><a href="#10-应用层">10. 应用层</a></li>
<li><a href="#11-数据库">11. 数据库</a></li>
<li><a href="#12-缓存">12. 缓存</a></li>
<li><a href="#13-异步">13. 异步</a></li>
<li><a href="#14-通讯">14. 通讯</a></li>
<li><a href="#15-安全">15. 安全</a></li>
<li><a href="#16-附录">16. 附录</a></li>
<li><a href="#17-资料">17. 资料</a></li>
</ul>
<!-- /TOC -->
<div align="center"><br><img src="https://camo.githubusercontent.com/e45e39c36eebcc4c66e1aecd4e4145112d8e88e3/687474703a2f2f692e696d6775722e636f6d2f6a6a3341354e382e706e67" width="640"><br></div>

<p>接下来，我们将看看高阶的权衡和取舍:</p>
<ul>
<li><strong>性能</strong>与<strong>可扩展性</strong></li>
<li><strong>延迟</strong>与<strong>吞吐量</strong></li>
<li><strong>可用性</strong>与<strong>一致性</strong></li>
</ul>
<p>记住<strong>每个方面都面临取舍和权衡</strong>。</p>
<p>然后，我们将深入更具体的主题，如 DNS、CDN 和负载均衡器。</p>
<h2 id="1-性能与可扩展性"><a href="#1-性能与可扩展性" class="headerlink" title="1. 性能与可扩展性"></a>1. 性能与可扩展性</h2><p>如果服务<strong>性能</strong>的增长与资源的增加是成比例的，服务就是可扩展的。通常，提高性能意味着服务于更多的工作单元，另一方面，当数据集增长时，同样也可以处理更大的工作单位。<sup><a href="http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html" target="_blank" rel="noopener">1</a></sup></p>
<p>另一个角度来看待性能与可扩展性:</p>
<ul>
<li>如果你的系统有<strong>性能</strong>问题，对于单个用户来说是缓慢的。</li>
<li>如果你的系统有<strong>可扩展性</strong>问题，单个用户较快但在高负载下会变慢。</li>
</ul>
<h3 id="来源及延伸阅读"><a href="#来源及延伸阅读" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html" target="_blank" rel="noopener">简单谈谈可扩展性</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">可扩展性，可用性，稳定性和模式</a></li>
</ul>
<h2 id="2-延迟与吞吐量"><a href="#2-延迟与吞吐量" class="headerlink" title="2. 延迟与吞吐量"></a>2. 延迟与吞吐量</h2><p><strong>延迟</strong>是执行操作或运算结果所花费的时间。</p>
<p><strong>吞吐量</strong>是单位时间内（执行）此类操作或运算的数量。</p>
<p>通常，你应该以<strong>可接受级延迟</strong>下<strong>最大化吞吐量</strong>为目标。</p>
<h3 id="来源及延伸阅读-1"><a href="#来源及延伸阅读-1" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="https://community.cadence.com/cadence_blogs_8/b/sd/archive/2010/09/13/understanding-latency-vs-throughput" target="_blank" rel="noopener">理解延迟与吞吐量</a></li>
</ul>
<h2 id="3-可用性与一致性"><a href="#3-可用性与一致性" class="headerlink" title="3. 可用性与一致性"></a>3. 可用性与一致性</h2><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p align="center"><br>  <img src="http://i.imgur.com/bgLMI2u.png"><br>  <br><br>  <strong><a href="http://robertgreiner.com/2014/08/cap-theorem-revisited" target="_blank" rel="noopener">来源：再看 CAP 理论</a></strong><br></p>

<p>在一个分布式计算系统中，只能同时满足下列的两点:</p>
<ul>
<li><strong>一致性</strong> ─ 每次访问都能获得最新数据但可能会收到错误响应</li>
<li><strong>可用性</strong> ─ 每次访问都能收到非错响应，但不保证获取到最新数据</li>
<li><strong>分区容错性</strong> ─ 在任意分区网络故障的情况下系统仍能继续运行</li>
</ul>
<p><strong>网络并不可靠，所以你应要支持分区容错性，并需要在软件可用性和一致性间做出取舍。</strong></p>
<h4 id="CP-─-一致性和分区容错性"><a href="#CP-─-一致性和分区容错性" class="headerlink" title="CP ─ 一致性和分区容错性"></a>CP ─ 一致性和分区容错性</h4><p>等待分区节点的响应可能会导致延时错误。如果你的业务需求需要原子读写，CP 是一个不错的选择。</p>
<h4 id="AP-─-可用性与分区容错性"><a href="#AP-─-可用性与分区容错性" class="headerlink" title="AP ─ 可用性与分区容错性"></a>AP ─ 可用性与分区容错性</h4><p>响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。</p>
<p>如果业务需求允许<a href="#最终一致性">最终一致性</a>，或当有外部故障时要求系统继续运行，AP 是一个不错的选择。</p>
<h3 id="来源及延伸阅读-2"><a href="#来源及延伸阅读-2" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/" target="_blank" rel="noopener">再看 CAP 理论</a></li>
<li><a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener">通俗易懂地介绍 CAP 理论</a></li>
<li><a href="https://github.com/henryr/cap-faq" target="_blank" rel="noopener">CAP FAQ</a></li>
</ul>
<h2 id="4-一致性模式"><a href="#4-一致性模式" class="headerlink" title="4. 一致性模式"></a>4. 一致性模式</h2><p>有同一份数据的多份副本，我们面临着怎样同步它们的选择，以便让客户端有一致的显示数据。回想 <a href="#cap-理论">CAP 理论</a>中的一致性定义 ─ 每次访问都能获得最新数据但可能会收到错误响应</p>
<h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>在写入之后，访问可能看到，也可能看不到（写入数据）。尽力优化之让其能访问最新数据。</p>
<p>这种方式可以 memcached 等系统中看到。弱一致性在 VoIP，视频聊天和实时多人游戏等真实用例中表现不错。打个比方，如果你在通话中丢失信号几秒钟时间，当重新连接时你是听不到这几秒钟所说的话的。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>在写入后，访问最终能看到写入数据（通常在数毫秒内）。数据被异步复制。</p>
<p>DNS 和 email 等系统使用的是此种方式。最终一致性在高可用性系统中效果不错。</p>
<h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>在写入后，访问立即可见。数据被同步复制。</p>
<p>文件系统和关系型数据库（RDBMS）中使用的是此种方式。强一致性在需要记录的系统中运作良好。</p>
<h3 id="来源及延伸阅读-3"><a href="#来源及延伸阅读-3" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank" rel="noopener">Transactions across data centers</a></li>
</ul>
<h2 id="5-可用性模式"><a href="#5-可用性模式" class="headerlink" title="5. 可用性模式"></a>5. 可用性模式</h2><p>有两种支持高可用性的模式: <strong>故障切换（fail-over）</strong>和<strong>复制（replication）</strong>。</p>
<h3 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h3><h4 id="工作到备用切换（Active-passive）"><a href="#工作到备用切换（Active-passive）" class="headerlink" title="工作到备用切换（Active-passive）"></a>工作到备用切换（Active-passive）</h4><p>关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。</p>
<p>宕机时间取决于备用服务器处于“热”待机状态还是需要从“冷”待机状态进行启动。只有工作服务器处理流量。</p>
<p>工作到备用的故障切换也被称为主从切换。</p>
<h4 id="双工作切换（Active-active）"><a href="#双工作切换（Active-active）" class="headerlink" title="双工作切换（Active-active）"></a>双工作切换（Active-active）</h4><p>在双工作切换中，双方都在管控流量，在它们之间分散负载。</p>
<p>如果是外网服务器，DNS 将需要对两方都了解。如果是内网服务器，应用程序逻辑将需要对两方都了解。</p>
<p>双工作切换也可以称为主主切换。</p>
<h3 id="缺陷：故障切换"><a href="#缺陷：故障切换" class="headerlink" title="缺陷：故障切换"></a>缺陷：故障切换</h3><ul>
<li>故障切换需要添加额外硬件并增加复杂性。</li>
<li>如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据。</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="主-─-从复制和主-─-主复制"><a href="#主-─-从复制和主-─-主复制" class="headerlink" title="主 ─ 从复制和主 ─ 主复制"></a>主 ─ 从复制和主 ─ 主复制</h4><p>这个主题进一步探讨了<a href="#数据库">数据库</a>部分:</p>
<ul>
<li><a href="#主从复制">主 ─ 从复制</a></li>
<li><a href="#主主复制">主 ─ 主复制</a></li>
</ul>
<h2 id="6-域名系统"><a href="#6-域名系统" class="headerlink" title="6. 域名系统"></a>6. 域名系统</h2><p align="center"><br>  <img src="http://i.imgur.com/IOyLj4i.jpg"><br>  <br><br>  <strong><a href="http://www.slideshare.net/srikrupa5/dns-security-presentation-issa" target="_blank" rel="noopener">来源：DNS 安全介绍</a></strong><br></p>

<p>域名系统是把 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 等域名转换成 IP 地址。</p>
<p>域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名） IP 时，路由或 ISP 提供连接 DNS 服务器的信息。较底层的 DNS 服务器缓存映射，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于<a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener">存活时间 TTL</a>。</p>
<ul>
<li><strong>NS 记录（域名服务）</strong> ─ 指定解析域名或子域名的 DNS 服务器。</li>
<li><strong>MX 记录（邮件交换）</strong> ─ 指定接收信息的邮件服务器。</li>
<li><strong>A 记录（地址）</strong> ─ 指定域名对应的 IP 地址记录。</li>
<li><strong>CNAME（规范）</strong> ─ 一个域名映射到另一个域名或 <code>CNAME</code> 记录（ example.com 指向 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> ）或映射到一个 <code>A</code> 记录。</li>
</ul>
<p><a href="https://www.cloudflare.com/dns/" target="_blank" rel="noopener">CloudFlare</a> 和 <a href="https://aws.amazon.com/route53/" target="_blank" rel="noopener">Route 53</a> 等平台提供管理 DNS 的功能。某些 DNS 服务通过集中方式来路由流量:</p>
<ul>
<li><a href="http://g33kinfo.com/info/archives/2657" target="_blank" rel="noopener">加权轮询调度</a><ul>
<li>防止流量进入维护中的服务器</li>
<li>在不同大小集群间负载均衡</li>
<li>A/B 测试</li>
</ul>
</li>
<li>基于延迟路由</li>
<li>基于地理位置路由</li>
</ul>
<h3 id="缺陷-DNS"><a href="#缺陷-DNS" class="headerlink" title="缺陷:DNS"></a>缺陷:DNS</h3><ul>
<li>虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。</li>
<li>虽然它们通常由<a href="http://superuser.com/questions/472695/who-controls-the-dns-servers/472729" target="_blank" rel="noopener">政府，网络服务提供商和大公司</a>管理，但 DNS 服务管理仍可能是复杂的。</li>
<li>DNS 服务最近遭受 <a href="http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/" target="_blank" rel="noopener">DDoS 攻击</a>，阻止不知道 Twtter IP 地址的用户访问 Twiiter。</li>
</ul>
<h3 id="来源及延伸阅读-4"><a href="#来源及延伸阅读-4" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="https://technet.microsoft.com/en-us/library/dd197427(v=ws.10" target="_blank" rel="noopener">DNS 架构</a>.aspx&gt;)</li>
<li><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://support.dnsimple.com/categories/dns/" target="_blank" rel="noopener">关于 DNS 的文章</a></li>
</ul>
<h2 id="7-内容分发网络（CDN）"><a href="#7-内容分发网络（CDN）" class="headerlink" title="7. 内容分发网络（CDN）"></a>7. 内容分发网络（CDN）</h2><p align="center"><br>  <img src="http://i.imgur.com/h9TAuGI.jpg"><br>  <br><br>  <strong><a href="https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/" target="_blank" rel="noopener">来源：为什么使用 CDN</a></strong><br></p>

<p>内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。</p>
<p>将内容存储在 CDN 上可以从两个方面来提供性能:</p>
<ul>
<li>从靠近用户的数据中心提供资源</li>
<li>通过 CDN 你的服务器不必真的处理请求</li>
</ul>
<h3 id="CDN-推送（push）"><a href="#CDN-推送（push）" class="headerlink" title="CDN 推送（push）"></a>CDN 推送（push）</h3><p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p>
<h3 id="CDN-拉取（pull）"><a href="#CDN-拉取（pull）" class="headerlink" title="CDN 拉取（pull）"></a>CDN 拉取（pull）</h3><p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p>
<p><a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p>
<p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p>
<h3 id="缺陷：CDN"><a href="#缺陷：CDN" class="headerlink" title="缺陷：CDN"></a>缺陷：CDN</h3><ul>
<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>
<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>
<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>
</ul>
<h3 id="来源及延伸阅读-5"><a href="#来源及延伸阅读-5" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci" target="_blank" rel="noopener">全球性内容分发网络</a></li>
<li><a href="http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/" target="_blank" rel="noopener">CDN 拉取和 CDN 推送的区别</a></li>
<li><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">Wikipedia</a></li>
</ul>
<h2 id="8-负载均衡器"><a href="#8-负载均衡器" class="headerlink" title="8. 负载均衡器"></a>8. 负载均衡器</h2><p align="center"><br>  <img src="http://i.imgur.com/h81n9iK.png"><br>  <br><br>  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener">来源：可扩展的系统设计模式</a></strong><br></p>

<p>负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:</p>
<ul>
<li>防止请求进入不好的服务器</li>
<li>防止资源过载</li>
<li>帮助消除单一的故障点</li>
</ul>
<p>负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。<br>增加的好处包括:</p>
<ul>
<li><strong>SSL 终结</strong> ─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。<ul>
<li>不需要再每台服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">X.509 证书</a>。</li>
</ul>
</li>
<li><strong>Session 留存</strong> ─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。</li>
</ul>
<p>通常会设置采用<a href="#工作到备用切换active-passive">工作 ─ 备用</a> 或 <a href="#双工作切换active-active">双工作</a> 模式的多个负载均衡器，以免发生故障。</p>
<p>负载均衡器能基于多种方式来路由流量:</p>
<ul>
<li>随机</li>
<li>最少负载</li>
<li>Session/cookie</li>
<li><a href="http://g33kinfo.com/info/archives/2657" target="_blank" rel="noopener">轮询调度或加权轮询调度算法</a></li>
<li><a href="#四层负载均衡">四层负载均衡</a></li>
<li><a href="#七层负载均衡">七层负载均衡</a></li>
</ul>
<h3 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h3><p>四层负载均衡根据监看<a href="#通讯">传输层</a>的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行<a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">网络地址转换（NAT）</a>来向上游服务器转发网络数据包。</p>
<h3 id="七层负载均衡器"><a href="#七层负载均衡器" class="headerlink" title="七层负载均衡器"></a>七层负载均衡器</h3><p>七层负载均衡器根据监控<a href="#通讯">应用层</a>来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。</p>
<p>以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。</p>
<h3 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h3><p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上<strong>垂直扩展</strong>更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。</p>
<h4 id="缺陷：水平扩展"><a href="#缺陷：水平扩展" class="headerlink" title="缺陷：水平扩展"></a>缺陷：水平扩展</h4><ul>
<li>水平扩展引入了复杂度并涉及服务器复制<ul>
<li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li>
<li>session 可以集中存储在数据库或持久化<a href="#缓存">缓存</a>（Redis、Memcached）的数据存储区中。</li>
</ul>
</li>
<li>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</li>
</ul>
<h3 id="缺陷：负载均衡器"><a href="#缺陷：负载均衡器" class="headerlink" title="缺陷：负载均衡器"></a>缺陷：负载均衡器</h3><ul>
<li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li>
<li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li>
<li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li>
</ul>
<h3 id="来源及延伸阅读-6"><a href="#来源及延伸阅读-6" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener">HAProxy 架构指南</a></li>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener">可扩展性</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing" target="_blank" rel="noopener">Wikipedia</a>&gt;)</li>
<li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">四层负载平衡</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/" target="_blank" rel="noopener">七层负载平衡</a></li>
<li><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html" target="_blank" rel="noopener">ELB 监听器配置</a></li>
</ul>
<h2 id="9-反向代理（web-服务器）"><a href="#9-反向代理（web-服务器）" class="headerlink" title="9. 反向代理（web 服务器）"></a>9. 反向代理（web 服务器）</h2><p align="center"><br>  <img src="http://i.imgur.com/n41Azff.png"><br>  <br><br>  <strong><a href="https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg" target="_blank" rel="noopener">资料来源：维基百科</a></strong><br>  <br><br></p>

<p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p>
<p>带来的好处包括：</p>
<ul>
<li><strong>增加安全性</strong> - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li>
<li><strong>提高可扩展性和灵活性</strong> - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li>
<li><strong>本地终结 SSL 会话</strong> - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。<ul>
<li>免除了在每个服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">X.509</a> 证书的需要</li>
</ul>
</li>
<li><strong>压缩</strong> - 压缩服务器响应</li>
<li><strong>缓存</strong> - 直接返回命中的缓存结果</li>
<li><strong>静态内容</strong> - 直接提供静态内容<ul>
<li>HTML/CSS/JS</li>
<li>图片</li>
<li>视频</li>
<li>等等</li>
</ul>
</li>
</ul>
<h3 id="负载均衡器与反向代理"><a href="#负载均衡器与反向代理" class="headerlink" title="负载均衡器与反向代理"></a>负载均衡器与反向代理</h3><ul>
<li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。</li>
<li>即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。</li>
<li>NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。</li>
</ul>
<h3 id="不利之处：反向代理"><a href="#不利之处：反向代理" class="headerlink" title="不利之处：反向代理"></a>不利之处：反向代理</h3><ul>
<li>引入反向代理会增加系统的复杂度。</li>
<li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如<a href="https://en.wikipedia.org/wiki/Failover" target="_blank" rel="noopener">故障转移</a>）会进一步增加复杂度。</li>
</ul>
<h3 id="来源及延伸阅读-7"><a href="#来源及延伸阅读-7" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/" target="_blank" rel="noopener">反向代理与负载均衡</a></li>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener">HAProxy 架构指南</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reverse_proxy" target="_blank" rel="noopener">Wikipedia</a></li>
</ul>
<h2 id="10-应用层"><a href="#10-应用层" class="headerlink" title="10. 应用层"></a>10. 应用层</h2><p align="center"><br>  <img src="http://i.imgur.com/yB5SYwm.png"><br>  <br><br>  <strong><a href="http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer" target="_blank" rel="noopener">资料来源：可缩放系统构架介绍</a></strong><br></p>

<p>将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。</p>
<p><strong>单一职责原则</strong>提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p>
<p>应用层中的工作进程也有可以实现<a href="#异步">异步化</a>。</p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>与此讨论相关的话题是 <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">微服务</a>，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。<sup>&lt;a href=<a href="https://smartbear.com/learn/api-design/what-are-microservices&gt;1" target="_blank" rel="noopener">https://smartbear.com/learn/api-design/what-are-microservices&gt;1</a></sup></p>
<p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>像 <a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener">Consul</a>，<a href="https://coreos.com/etcd/docs/latest" target="_blank" rel="noopener">Etcd</a> 和 <a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener">Zookeeper</a> 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。<a href="https://www.consul.io/intro/getting-started/checks.html" target="_blank" rel="noopener">Health checks</a> 可以帮助确认服务的完整性和是否经常使用一个 <a href="#超文本传输协议http">HTTP</a> 路径。Consul 和 Etcd 都有一个内建的 <a href="#键-值存储">key-value 存储</a> 用来存储配置信息和其他的共享信息。</p>
<h3 id="不利之处：应用层"><a href="#不利之处：应用层" class="headerlink" title="不利之处：应用层"></a>不利之处：应用层</h3><ul>
<li>添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。</li>
<li>微服务会增加部署和运营的复杂度。</li>
</ul>
<h3 id="来源及延伸阅读-8"><a href="#来源及延伸阅读-8" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale" target="_blank" rel="noopener">可缩放系统构架介绍</a></li>
<li><a href="http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview/" target="_blank" rel="noopener">破解系统设计面试</a></li>
<li><a href="https://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="noopener">面向服务架构</a></li>
<li><a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener">Zookeeper 介绍</a></li>
<li><a href="https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/" target="_blank" rel="noopener">构建微服务，你所需要知道的一切</a></li>
</ul>
<h2 id="11-数据库"><a href="#11-数据库" class="headerlink" title="11. 数据库"></a>11. 数据库</h2><p align="center"><br>  <img src="http://i.imgur.com/Xkm5CXz.png"><br>  <br><br>  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener">资料来源：扩展你的用户数到第一个一千万</a></strong><br></p>

<h3 id="关系型数据库管理系统（RDBMS）"><a href="#关系型数据库管理系统（RDBMS）" class="headerlink" title="关系型数据库管理系统（RDBMS）"></a>关系型数据库管理系统（RDBMS）</h3><p>像 SQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。</p>
<blockquote>
<p>校对注：这里作者 SQL 可能指的是 MySQL</p>
</blockquote>
<p><strong>ACID</strong> 用来描述关系型数据库<a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener">事务</a>的特性。</p>
<ul>
<li><strong>原子性</strong> - 每个事务内部所有操作要么全部完成，要么全部不完成。</li>
<li><strong>一致性</strong> - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。</li>
<li><strong>隔离性</strong> - 并发执行事务的结果与顺序执行事务的结果相同。</li>
<li><strong>持久性</strong> - 事务提交后，对系统的影响是永久的。</li>
</ul>
<p>关系型数据库扩展包括许多技术：<strong>主从复制</strong>、<strong>主主复制</strong>、<strong>联合</strong>、<strong>分片</strong>、<strong>非规范化</strong>和 <strong>SQL 调优</strong>。</p>
<p align="center"><br>  <img src="http://i.imgur.com/C9ioGtn.png"><br>  <br><br>  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">资料来源：可扩展性、可用性、稳定性、模式</a></strong><br></p>

<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。</p>
<h5 id="不利之处：主从复制"><a href="#不利之处：主从复制" class="headerlink" title="不利之处：主从复制"></a>不利之处：主从复制</h5><ul>
<li>将从库提升为主库需要额外的逻辑。</li>
<li>参考<a href="#不利之处复制">不利之处：复制</a>中，主从复制和主主复制<strong>共同</strong>的问题。</li>
</ul>
<p align="center"><br>  <img src="http://i.imgur.com/krAHLGg.png"><br>  <br><br>  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">资料来源：可扩展性、可用性、稳定性、模式</a></strong><br></p>

<h4 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h4><p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p>
<h5 id="不利之处：-主主复制"><a href="#不利之处：-主主复制" class="headerlink" title="不利之处： 主主复制"></a>不利之处： 主主复制</h5><ul>
<li>你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li>
<li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li>
<li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li>
<li>参考<a href="#不利之处复制">不利之处：复制</a>中，主从复制和主主复制<strong>共同</strong>的问题。</li>
</ul>
<h5 id="不利之处：复制"><a href="#不利之处：复制" class="headerlink" title="不利之处：复制"></a>不利之处：复制</h5><ul>
<li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。</li>
<li>写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。</li>
<li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。</li>
<li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。</li>
<li>复制意味着更多的硬件和额外的复杂度。</li>
</ul>
<h5 id="来源及延伸阅读-9"><a href="#来源及延伸阅读-9" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h5><ul>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">扩展性，可用性，稳定性模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multi-master_replication" target="_blank" rel="noopener">多主复制</a></li>
</ul>
<h4 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h4><p align="center"><br>  <img src="http://i.imgur.com/U3qV33e.png"><br>  <br><br>  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener">资料来源：扩展你的用户数到第一个一千万</a></strong><br></p>

<p>联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：<strong>论坛</strong>、<strong>用户</strong>和<strong>产品</strong>，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>
<h5 id="不利之处：联合"><a href="#不利之处：联合" class="headerlink" title="不利之处：联合"></a>不利之处：联合</h5><ul>
<li>如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。</li>
<li>你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li>
<li>用 <a href="http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers" target="_blank" rel="noopener">server link</a> 从两个库联结数据更复杂。</li>
<li>联合需要更多的硬件和额外的复杂度。</li>
</ul>
<h5 id="来源及延伸阅读：联合"><a href="#来源及延伸阅读：联合" class="headerlink" title="来源及延伸阅读：联合"></a>来源及延伸阅读：联合</h5><ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener">扩展你的用户数到第一个一千万</a></li>
</ul>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p align="center"><br>  <img src="http://i.imgur.com/wU8x5Id.png"><br>  <br><br>  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">资料来源：可扩展性、可用性、稳定性、模式</a></strong><br></p>

<p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。</p>
<p>类似<a href="#联合">联合</a>的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>
<p>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p>
<h5 id="不利之处：分片"><a href="#不利之处：分片" class="headerlink" title="不利之处：分片"></a>不利之处：分片</h5><ul>
<li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li>
<li>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。<ul>
<li>再平衡会引入额外的复杂度。基于<a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html" target="_blank" rel="noopener">一致性哈希</a>的分片算法可以减少这种情况。</li>
</ul>
</li>
<li>联结多个分片的数据操作更复杂。</li>
<li>分片需要更多的硬件和额外的复杂度。</li>
</ul>
<h4 id="来源及延伸阅读：分片"><a href="#来源及延伸阅读：分片" class="headerlink" title="来源及延伸阅读：分片"></a>来源及延伸阅读：分片</h4><ul>
<li><a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html" target="_blank" rel="noopener">分片时代来临</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shard_(database_architecture" target="_blank" rel="noopener">数据库分片架构</a>&gt;)</li>
<li><a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html" target="_blank" rel="noopener">一致性哈希</a></li>
</ul>
<h4 id="非规范化"><a href="#非规范化" class="headerlink" title="非规范化"></a>非规范化</h4><p>非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 <a href="https://en.wikipedia.org/wiki/PostgreSQL" target="_blank" rel="noopener">PostgreSQL</a> 和 Oracle 支持<a href="https://en.wikipedia.org/wiki/Materialized_view" target="_blank" rel="noopener">物化视图</a>，可以处理冗余信息存储和保证冗余副本一致。</p>
<p>当数据使用诸如<a href="#联合">联合</a>和<a href="#分片">分片</a>等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。</p>
<p>在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p>
<h5 id="不利之处：非规范化"><a href="#不利之处：非规范化" class="headerlink" title="不利之处：非规范化"></a>不利之处：非规范化</h5><ul>
<li>数据会冗余。</li>
<li>约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。</li>
<li>非规范化的数据库在高写入负载下性能可能比规范化的数据库差。</li>
</ul>
<h5 id="来源及延伸阅读：非规范化"><a href="#来源及延伸阅读：非规范化" class="headerlink" title="来源及延伸阅读：非规范化"></a>来源及延伸阅读：非规范化</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Denormalization" target="_blank" rel="noopener">非规范化</a></li>
</ul>
<h4 id="SQL-调优"><a href="#SQL-调优" class="headerlink" title="SQL 调优"></a>SQL 调优</h4><p>SQL 调优是一个范围很广的话题，有很多相关的<a href="https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=sql+tuning" target="_blank" rel="noopener">书</a>可以作为参考。</p>
<p>利用<strong>基准测试</strong>和<strong>性能分析</strong>来模拟和发现系统瓶颈很重要。</p>
<ul>
<li><strong>基准测试</strong> - 用 <a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="noopener">ab</a> 等工具模拟高负载情况。</li>
<li><strong>性能分析</strong> - 通过启用如<a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener">慢查询日志</a>等工具来辅助追踪性能问题。</li>
</ul>
<p>基准测试和性能分析可能会指引你到以下优化方案。</p>
<h5 id="改进模式"><a href="#改进模式" class="headerlink" title="改进模式"></a>改进模式</h5><ul>
<li>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</li>
<li>使用 <code>CHAR</code> 类型存储固定长度的字段，不要用 <code>VARCHAR</code>。<ul>
<li><code>CHAR</code> 在快速、随机访问时效率很高。如果使用 <code>VARCHAR</code>，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li>
</ul>
</li>
<li>使用 <code>TEXT</code> 类型存储大块的文本，例如博客正文。<code>TEXT</code> 还允许布尔搜索。使用 <code>TEXT</code> 字段需要在磁盘上存储一个用于定位文本块的指针。</li>
<li>使用 <code>INT</code> 类型存储高达 2^32 或 40 亿的较大数字。</li>
<li>使用 <code>DECIMAL</code> 类型存储货币可以避免浮点数表示错误。</li>
<li>避免使用 <code>BLOBS</code> 存储对象，存储存放对象的位置。</li>
<li><code>VARCHAR(255)</code> 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</li>
<li>在适用场景中设置 <code>NOT NULL</code> 约束来<a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search" target="_blank" rel="noopener">提高搜索性能</a>。</li>
</ul>
<h5 id="使用正确的索引"><a href="#使用正确的索引" class="headerlink" title="使用正确的索引"></a>使用正确的索引</h5><ul>
<li>你正查询（<code>SELECT</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>JOIN</code>）的列如果用了索引会更快。</li>
<li>索引通常表示为自平衡的 <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">B 树</a>，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li>
<li>设置索引，会将数据存在内存中，占用了更多内存空间。</li>
<li>写入操作会变慢，因为索引需要被更新。</li>
<li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li>
</ul>
<h5 id="避免高成本的联结操作"><a href="#避免高成本的联结操作" class="headerlink" title="避免高成本的联结操作"></a>避免高成本的联结操作</h5><ul>
<li>有性能需要，可以进行非规范化。</li>
</ul>
<h5 id="分割数据表"><a href="#分割数据表" class="headerlink" title="分割数据表"></a>分割数据表</h5><ul>
<li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li>
</ul>
<h5 id="调优查询缓存"><a href="#调优查询缓存" class="headerlink" title="调优查询缓存"></a>调优查询缓存</h5><ul>
<li>在某些情况下，<a href="http://dev.mysql.com/doc/refman/5.7/en/query-cache" target="_blank" rel="noopener">查询缓存</a>可能会导致<a href="https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/" target="_blank" rel="noopener">性能问题</a>。</li>
</ul>
<h5 id="来源及延伸阅读-10"><a href="#来源及延伸阅读-10" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h5><ul>
<li><a href="http://20bits.com/article/10-tips-for-optimizing-mysql-queries-that-dont-suck" target="_blank" rel="noopener">MySQL 查询优化小贴士</a></li>
<li><a href="http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l" target="_blank" rel="noopener">为什么 VARCHAR(255) 很常见？</a></li>
<li><a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search" target="_blank" rel="noopener">Null 值是如何影响数据库性能的？</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener">慢查询日志</a></li>
</ul>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>NoSQL 是<strong>键-值数据库</strong>、<strong>文档型数据库</strong>、<strong>列型数据库</strong>或<strong>图数据库</strong>的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持<a href="#最终一致性">最终一致</a>。</p>
<p><strong>BASE</strong> 通常被用于描述 NoSQL 数据库的特性。相比 <a href="#cap-理论">CAP 理论</a>，BASE 强调可用性超过一致性。</p>
<ul>
<li><strong>基本可用</strong> - 系统保证可用性。</li>
<li><strong>软状态</strong> - 即使没有输入，系统状态也可能随着时间变化。</li>
<li><strong>最终一致性</strong> - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li>
</ul>
<p>除了在 <a href="#sql-还是-nosql">SQL 还是 NoSQL</a> 之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下 <strong>键-值存储</strong>、<strong>文档型存储</strong>、<strong>列型存储</strong>和<strong>图存储</strong>数据库。</p>
<h4 id="键-值存储"><a href="#键-值存储" class="headerlink" title="键-值存储"></a>键-值存储</h4><blockquote>
<p>抽象模型：哈希表</p>
</blockquote>
<p>键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按<a href="https://en.wikipedia.org/wiki/Lexicographical_order" target="_blank" rel="noopener">字典顺序</a>维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。</p>
<p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。</p>
<p>键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。</p>
<h4 id="来源及延伸阅读-11"><a href="#来源及延伸阅读-11" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Key-value_database" target="_blank" rel="noopener">键-值数据库</a></li>
<li><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or" target="_blank" rel="noopener">键-值存储的劣势</a></li>
<li><a href="http://qnimate.com/overview-of-redis-architecture/" target="_blank" rel="noopener">Redis 架构</a></li>
<li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener">Memcached 架构</a></li>
</ul>
<h4 id="文档类型存储"><a href="#文档类型存储" class="headerlink" title="文档类型存储"></a>文档类型存储</h4><blockquote>
<p>抽象模型：将文档作为值的键-值存储</p>
</blockquote>
<p>文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。</p>
<p>基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</p>
<p>MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。</p>
<p>文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。</p>
<h4 id="来源及延伸阅读：文档类型存储"><a href="#来源及延伸阅读：文档类型存储" class="headerlink" title="来源及延伸阅读：文档类型存储"></a>来源及延伸阅读：文档类型存储</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank" rel="noopener">面向文档的数据库</a></li>
<li><a href="https://www.mongodb.com/mongodb-architecture" target="_blank" rel="noopener">MongoDB 架构</a></li>
<li><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/" target="_blank" rel="noopener">CouchDB 架构</a></li>
<li><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up" target="_blank" rel="noopener">Elasticsearch 架构</a></li>
</ul>
<h4 id="列型存储"><a href="#列型存储" class="headerlink" title="列型存储"></a>列型存储</h4><p align="center"><br>  <img src="http://i.imgur.com/n16iOGk.png"><br>  <br><br>  <strong><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" target="_blank" rel="noopener">资料来源: SQL 和 NoSQL，一个简短的历史</a></strong><br></p>

<blockquote>
<p>抽象模型：嵌套的 <code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</p>
</blockquote>
<p>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p>
<p>Google 发布了第一个列型存储数据库 <a href="http://www.read.seas.harvard.edu/\~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener">Bigtable</a>，它影响了 Hadoop 生态系统中活跃的开源数据库 <a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener">HBase</a> 和 Facebook 的 <a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html" target="_blank" rel="noopener">Cassandra</a>。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p>
<p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p>
<h5 id="来源及延伸阅读：列型存储"><a href="#来源及延伸阅读：列型存储" class="headerlink" title="来源及延伸阅读：列型存储"></a>来源及延伸阅读：列型存储</h5><ul>
<li><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" target="_blank" rel="noopener">SQL 与 NoSQL 简史</a></li>
<li><a href="http://www.read.seas.harvard.edu/\~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener">BigTable 架构</a></li>
<li><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener">Hbase 架构</a></li>
<li><a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html" target="_blank" rel="noopener">Cassandra 架构</a></li>
</ul>
<h4 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h4><p align="center"><br>  <img src="http://i.imgur.com/fNcl65g.png"><br>  <br><br>  <strong><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png" target="_blank" rel="noopener">资料来源：图数据库</a></strong><br></p>

<blockquote>
<p>抽象模型： 图</p>
</blockquote>
<p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p>
<p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 <a href="#表述性状态转移rest">REST API</a> 访问。</p>
<h5 id="相关资源和延伸阅读：图"><a href="#相关资源和延伸阅读：图" class="headerlink" title="相关资源和延伸阅读：图"></a>相关资源和延伸阅读：图</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_database" target="_blank" rel="noopener">图数据库</a></li>
<li><a href="https://neo4j.com/" target="_blank" rel="noopener">Neo4j</a></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb" target="_blank" rel="noopener">FlockDB</a></li>
</ul>
<h4 id="来源及延伸阅读：NoSQL"><a href="#来源及延伸阅读：NoSQL" class="headerlink" title="来源及延伸阅读：NoSQL"></a>来源及延伸阅读：NoSQL</h4><ul>
<li><a href="http://stackoverflow.com/questions/3342497/explanation-of-base-terminology" target="_blank" rel="noopener">数据库术语解释</a></li>
<li><a href="https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq" target="_blank" rel="noopener">NoSQL 数据库 - 调查及决策指南</a></li>
<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener">可扩展性</a></li>
<li><a href="https://www.youtube.com/watch?v=qI_g07C_Q5I" target="_blank" rel="noopener">NoSQL 介绍</a></li>
<li><a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html" target="_blank" rel="noopener">NoSQL 模式</a></li>
</ul>
<h3 id="SQL-还是-NoSQL"><a href="#SQL-还是-NoSQL" class="headerlink" title="SQL 还是 NoSQL"></a>SQL 还是 NoSQL</h3><p align="center"><br>  <img src="http://i.imgur.com/wXGqG5f.png"><br>  <br><br>  <strong><a href="https://www.infoq.com/articles/Transition-RDBMS-NoSQL/" target="_blank" rel="noopener">资料来源：从 RDBMS 转换到 NoSQL</a></strong><br></p>

<p>选取 <strong>SQL</strong> 的原因:</p>
<ul>
<li>结构化数据</li>
<li>严格的模式</li>
<li>关系型数据</li>
<li>需要复杂的联结操作</li>
<li>事务</li>
<li>清晰的扩展模式</li>
<li>既有资源更丰富：开发者、社区、代码库、工具等</li>
<li>通过索引进行查询非常快</li>
</ul>
<p>选取 <strong>NoSQL</strong> 的原因：</p>
<ul>
<li>半结构化数据</li>
<li>动态或灵活的模式</li>
<li>非关系型数据</li>
<li>不需要复杂的联结操作</li>
<li>存储 TB （甚至 PB）级别的数据</li>
<li>高数据密集的工作负载</li>
<li>IOPS 高吞吐量</li>
</ul>
<p>适合 NoSQL 的示例数据：</p>
<ul>
<li>埋点数据和日志数据</li>
<li>排行榜或者得分数据</li>
<li>临时数据，如购物车</li>
<li>频繁访问的（“热”）表</li>
<li>元数据／查找表</li>
</ul>
<h5 id="来源及延伸阅读：SQL-或-NoSQL"><a href="#来源及延伸阅读：SQL-或-NoSQL" class="headerlink" title="来源及延伸阅读：SQL 或 NoSQL"></a>来源及延伸阅读：SQL 或 NoSQL</h5><ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener">扩展你的用户数到第一个千万</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/" target="_blank" rel="noopener">SQL 和 NoSQL 的不同</a></li>
</ul>
<h2 id="12-缓存"><a href="#12-缓存" class="headerlink" title="12. 缓存"></a>12. 缓存</h2><p align="center"><br>  <img src="http://i.imgur.com/Q6z24La.png"><br>  <br><br>  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener">资料来源：可扩展的系统设计模式</a></strong><br></p>

<p>缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。</p>
<p>数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。</p>
<h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><p>缓存可以位于客户端（操作系统或者浏览器），<a href="#反向代理web-服务器">服务端</a>或者不同的缓存层。</p>
<h3 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h3><p><a href="#内容分发网络cdn">CDN</a> 也被视为一种缓存。</p>
<h3 id="Web-服务器缓存"><a href="#Web-服务器缓存" class="headerlink" title="Web 服务器缓存"></a>Web 服务器缓存</h3><p><a href="#反向代理web-服务器">反向代理</a>和缓存（比如 <a href="https://www.varnish-cache.org/" target="_blank" rel="noopener">Varnish</a>）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。</p>
<h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>数据库的默认配置中通常包含缓存级别，针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p>
<h3 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h3><p>基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used" target="_blank" rel="noopener">least recently used (LRU)</a> 的<a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank" rel="noopener">缓存无效算法</a>可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p>
<p>Redis 有下列附加功能：</p>
<ul>
<li>持久性选项</li>
<li>内置数据结构比如有序集合和列表</li>
</ul>
<p>有多个缓存级别，分为两大类：<strong>数据库查询</strong>和<strong>对象</strong>：</p>
<ul>
<li>行级别</li>
<li>查询级别</li>
<li>完整的可序列化对象</li>
<li>完全渲染的 HTML</li>
</ul>
<p>一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。</p>
<h3 id="数据库查询级别的缓存"><a href="#数据库查询级别的缓存" class="headerlink" title="数据库查询级别的缓存"></a>数据库查询级别的缓存</h3><p>当你查询数据库的时候，将查询语句的哈希值与查询结果存储到缓存中。这种方法会遇到以下问题：</p>
<ul>
<li>很难用复杂的查询删除已缓存结果。</li>
<li>如果一条数据比如表中某条数据的一项被改变，则需要删除所有可能包含已更改项的缓存结果。</li>
</ul>
<h3 id="对象级别的缓存"><a href="#对象级别的缓存" class="headerlink" title="对象级别的缓存"></a>对象级别的缓存</h3><p>将您的数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：</p>
<ul>
<li>如果对象的基础数据已经更改了，那么从缓存中删掉这个对象。</li>
<li>允许异步处理：workers 通过使用最新的缓存对象来组装对象。</li>
</ul>
<p>建议缓存的内容：</p>
<ul>
<li>用户会话</li>
<li>完全渲染的 Web 页面</li>
<li>活动流</li>
<li>用户图数据</li>
</ul>
<h3 id="何时更新缓存"><a href="#何时更新缓存" class="headerlink" title="何时更新缓存"></a>何时更新缓存</h3><p>由于你只能在缓存中存储有限的数据，所以你需要选择一个适用于你用例的缓存更新策略。</p>
<h4 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h4><p align="center"><br>  <img src="http://i.imgur.com/ONjORqk.png"><br>  <br><br>  <strong><a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast" target="_blank" rel="noopener">资料来源：从缓存到内存数据网格</a></strong><br></p>

<p>应用从存储器读写。缓存不和存储器直接交互，应用执行以下操作：</p>
<ul>
<li>在缓存中查找记录，如果所需数据不在缓存中</li>
<li>从数据库中加载所需内容</li>
<li>将查找到的结果存储到缓存中</li>
<li>返回所需内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def get_user(self, user_id):</span><br><span class="line">    user = cache.get(&quot;user.&#123;0&#125;&quot;, user_id)</span><br><span class="line">    if user is None:</span><br><span class="line">        user = db.query(&quot;SELECT * FROM users WHERE user_id = &#123;0&#125;&quot;, user_id)</span><br><span class="line">        if user is not None:</span><br><span class="line">            key = &quot;user.&#123;0&#125;&quot;.format(user_id)</span><br><span class="line">            cache.set(key, json.dumps(user))</span><br><span class="line">    return user</span><br></pre></td></tr></table></figure>
<p><a href="https://memcached.org/" target="_blank" rel="noopener">Memcached</a> 通常用这种方式使用。</p>
<p>添加到缓存中的数据读取速度很快。缓存模式也称为延迟加载。只缓存所请求的数据，这避免了没有被请求的数据占满了缓存空间。</p>
<h5 id="缓存的缺点："><a href="#缓存的缺点：" class="headerlink" title="缓存的缺点："></a>缓存的缺点：</h5><ul>
<li>请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。</li>
<li>如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置  TTL 强制更新缓存或者直写模式来缓解这种情况。</li>
<li>当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。</li>
</ul>
<h4 id="直写模式"><a href="#直写模式" class="headerlink" title="直写模式"></a>直写模式</h4><p align="center"><br>  <img src="http://i.imgur.com/0vBc0hN.png"><br>  <br><br>  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">资料来源：可扩展性、可用性、稳定性、模式</a></strong><br></p>

<p>应用使用缓存作为主要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。</p>
<ul>
<li>应用向缓存中添加/更新数据</li>
<li>缓存同步地写入数据存储</li>
<li>返回所需内容</li>
</ul>
<p>应用代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_user(12345, &#123;&quot;foo&quot;:&quot;bar&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>缓存代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def set_user(user_id, values):</span><br><span class="line">    user = db.query(&quot;UPDATE Users WHERE id = &#123;0&#125;&quot;, user_id, values)</span><br><span class="line">    cache.set(user_id, user)</span><br></pre></td></tr></table></figure>
<p>由于存写操作所以直写模式整体是一种很慢的操作，但是读取刚写入的数据很快。相比读取数据，用户通常比较能接受更新数据时速度较慢。缓存中的数据不会过时。</p>
<h5 id="直写模式的缺点："><a href="#直写模式的缺点：" class="headerlink" title="直写模式的缺点："></a>直写模式的缺点：</h5><ul>
<li>由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。</li>
<li>写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。</li>
</ul>
<h4 id="回写模式"><a href="#回写模式" class="headerlink" title="回写模式"></a>回写模式</h4><p align="center"><br>  <img src="http://i.imgur.com/rgSrvjG.png"><br>  <br><br>  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">资料来源：可扩展性、可用性、稳定性、模式</a></strong><br></p>

<p>在回写模式中，应用执行以下操作：</p>
<ul>
<li>在缓存中增加或者更新条目</li>
<li>异步写入数据，提高写入性能。</li>
</ul>
<h5 id="回写模式的缺点："><a href="#回写模式的缺点：" class="headerlink" title="回写模式的缺点："></a>回写模式的缺点：</h5><ul>
<li>缓存可能在其内容成功存储之前丢失数据。</li>
<li>执行直写模式比缓存或者回写模式更复杂。</li>
</ul>
<h4 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h4><p align="center"><br>  <img src="http://i.imgur.com/kxtjqgE.png"><br>  <br><br>  <strong>&lt;a href=<a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast&gt;资料来源：从缓存到内存数据网格" target="_blank" rel="noopener">http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast&gt;资料来源：从缓存到内存数据网格</a></strong><br></p>

<p>你可以将缓存配置成在到期之前自动刷新最近访问过的内容。</p>
<p>如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低。</p>
<h5 id="刷新的缺点："><a href="#刷新的缺点：" class="headerlink" title="刷新的缺点："></a>刷新的缺点：</h5><ul>
<li>不能准确预测到未来需要用到的数据可能会导致性能不如不使用刷新。</li>
</ul>
<h3 id="缓存的缺点：-1"><a href="#缓存的缺点：-1" class="headerlink" title="缓存的缺点："></a>缓存的缺点：</h3><ul>
<li>需要保持缓存和真实数据源之间的一致性，比如数据库根据<a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank" rel="noopener">缓存无效</a>。</li>
<li>需要改变应用程序比如增加 Redis 或者 memcached。</li>
<li>无效缓存是个难题，什么时候更新缓存是与之相关的复杂问题。</li>
</ul>
<h3 id="相关资源和延伸阅读"><a href="#相关资源和延伸阅读" class="headerlink" title="相关资源和延伸阅读"></a>相关资源和延伸阅读</h3><ul>
<li><a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast" target="_blank" rel="noopener">从缓存到内存数据</a></li>
<li><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener">可扩展系统设计模式</a></li>
<li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener">可缩放系统构架介绍</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener">可扩展性，可用性，稳定性和模式</a></li>
<li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener">可扩展性</a></li>
<li><a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html" target="_blank" rel="noopener">AWS ElastiCache 策略</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="noopener">维基百科</a>&gt;)</li>
</ul>
<h2 id="13-异步"><a href="#13-异步" class="headerlink" title="13. 异步"></a>13. 异步</h2><p align="center"><br>  <img src="http://i.imgur.com/54GYsSx.png"><br>  <br><br>  <strong>&lt;a href=<a href="http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer&gt;资料来源：可缩放系统构架介绍" target="_blank" rel="noopener">http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer&gt;资料来源：可缩放系统构架介绍</a></strong><br></p>

<p>异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：</p>
<ul>
<li>应用程序将作业发布到队列，然后通知用户作业状态</li>
<li>一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成</li>
</ul>
<p>不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。</p>
<p><strong>Redis</strong> 是一个令人满意的简单的消息代理，但是消息有可能会丢失。</p>
<p><strong>RabbitMQ</strong> 很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。</p>
<p><strong>Amazon SQS</strong> 是被托管的，但可能具有高延迟，并且消息可能会被传送两次。</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>任务队列接收任务及其相关数据，运行它们，然后传递其结果。 它们可以支持调度，并可用于在后台运行计算密集型作业。</p>
<p><strong>Celery</strong> 支持调度，主要是用 Python 开发的。</p>
<h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p>如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。<a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html" target="_blank" rel="noopener">背压</a>可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener">指数退避</a>。</p>
<h3 id="异步的缺点："><a href="#异步的缺点：" class="headerlink" title="异步的缺点："></a>异步的缺点：</h3><ul>
<li>简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。</li>
</ul>
<h3 id="相关资源和延伸阅读-1"><a href="#相关资源和延伸阅读-1" class="headerlink" title="相关资源和延伸阅读"></a>相关资源和延伸阅读</h3><ul>
<li><a href="https://www.youtube.com/watch?v=1KRYH75wgy4" target="_blank" rel="noopener">这是一个数字游戏</a></li>
<li><a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html" target="_blank" rel="noopener">超载时应用背压</a></li>
<li><a href="https://en.wikipedia.org/wiki/Little%27s_law" target="_blank" rel="noopener">利特尔法则</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function" target="_blank" rel="noopener">消息队列与任务队列有什么区别？</a></li>
</ul>
<h2 id="14-通讯"><a href="#14-通讯" class="headerlink" title="14. 通讯"></a>14. 通讯</h2><p align="center"><br>  <img src="http://i.imgur.com/5KeocQs.jpg"><br>  <br><br>  <strong>&lt;a href=<a href="http://www.escotal.com/osilayer.html&gt;资料来源：OSI" target="_blank" rel="noopener">http://www.escotal.com/osilayer.html&gt;资料来源：OSI</a> 7层模型</strong><br></p>

<h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><p>HTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。</p>
<p>一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。 以下是常见的 HTTP 动词：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>描述</th>
<th>*幂等</th>
<th>安全性</th>
<th>可缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>读取资源</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>POST</td>
<td>创建资源或触发处理数据的进程</td>
<td>No</td>
<td>No</td>
<td>Yes，如果回应包含刷新信息</td>
</tr>
<tr>
<td>PUT</td>
<td>创建或替换资源</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>PATCH</td>
<td>部分更新资源</td>
<td>No</td>
<td>No</td>
<td>Yes，如果回应包含刷新信息</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<p><strong>多次执行不会产生不同的结果</strong>。</p>
<p>HTTP 是依赖于较低级协议（如 <strong>TCP</strong> 和 <strong>UDP</strong>）的应用层协议。</p>
<h4 id="来源及延伸阅读：HTTP"><a href="#来源及延伸阅读：HTTP" class="headerlink" title="来源及延伸阅读：HTTP"></a>来源及延伸阅读：HTTP</h4><ul>
<li><a href="https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol" target="_blank" rel="noopener">README</a> +</li>
<li><a href="https://www.nginx.com/resources/glossary/http/" target="_blank" rel="noopener">HTTP 是什么？</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol" target="_blank" rel="noopener">HTTP 和 TCP 的区别</a></li>
<li><a href="https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1" target="_blank" rel="noopener">PUT 和 PATCH 的区别</a></li>
</ul>
<h3 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h3><p align="center"><br>  <img src="http://i.imgur.com/JdAsdvG.jpg"><br>  <br><br>  <strong><a href="http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/" target="_blank" rel="noopener">资料来源：如何制作多人游戏</a></strong><br></p>

<p>TCP 是通过 <a href="https://en.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener">IP 网络</a>的面向连接的协议。 使用<a href="https://en.wikipedia.org/wiki/Handshaking" target="_blank" rel="noopener">握手</a>建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：</p>
<ul>
<li>每个数据包的序列号和<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation" target="_blank" rel="noopener">校验码</a>。</li>
<li><a href="https://en.wikipedia.org/wiki/Acknowledgement_(data_networks" target="_blank" rel="noopener">确认包</a>&gt;)和自动重传</li>
</ul>
<p>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行<a href="https://en.wikipedia.org/wiki/Flow_control_(data" target="_blank" rel="noopener">流量控制</a>&gt;)和<a href="https://en.wikipedia.org/wiki/Network_congestion#Congestion_control" target="_blank" rel="noopener">拥塞控制</a>。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</p>
<p>为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，也就是说，一个 <a href="#memcached">memcached</a> 服务器。<a href="https://en.wikipedia.org/wiki/Connection_pool" target="_blank" rel="noopener">连接池</a> 可以帮助除了在适用的情况下切换到 UDP。</p>
<p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>
<p>以下情况使用 TCP 代替 UDP：</p>
<ul>
<li>你需要数据完好无损。</li>
<li>你想对网络吞吐量自动进行最佳评估。</li>
</ul>
<h3 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h3><p align="center"><br>  <img src="http://i.imgur.com/yzDrJtA.jpg"><br>  <br><br>  <strong><a href="http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1" target="_blank" rel="noopener">资料来源：如何制作多人游戏</a></strong><br></p>

<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>
<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>
<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>
<p>以下情况使用 UDP 代替 TCP：</p>
<ul>
<li>你需要低延迟</li>
<li>相对于数据丢失更糟的是数据延迟</li>
<li>你想实现自己的错误校正方法</li>
</ul>
<h4 id="来源及延伸阅读：TCP-与-UDP"><a href="#来源及延伸阅读：TCP-与-UDP" class="headerlink" title="来源及延伸阅读：TCP 与 UDP"></a>来源及延伸阅读：TCP 与 UDP</h4><ul>
<li><a href="http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/" target="_blank" rel="noopener">游戏编程的网络</a></li>
<li><a href="http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/" target="_blank" rel="noopener">TCP 与 UDP 的关键区别</a></li>
<li><a href="http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp" target="_blank" rel="noopener">TCP 与 UDP 的不同</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">传输控制协议</a></li>
<li><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener">用户数据报协议</a></li>
<li><a href="http://www.cs.bu.edu/\~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf" target="_blank" rel="noopener">Memcache 在 Facebook 的扩展</a></li>
</ul>
<h3 id="远程过程调用协议（RPC）"><a href="#远程过程调用协议（RPC）" class="headerlink" title="远程过程调用协议（RPC）"></a>远程过程调用协议（RPC）</h3><p align="center"><br>  <img src="http://i.imgur.com/iF4Mkb5.png"><br>  <br><br>  <strong><a href="http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview" target="_blank" rel="noopener">Source: Crack the system design interview</a></strong><br></p>

<p>在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括 <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protobuf</a>、<a href="https://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a> 和 <a href="https://avro.apache.org/docs/current/" target="_blank" rel="noopener">Avro</a>。</p>
<p>RPC 是一个“请求-响应”协议：</p>
<ul>
<li><strong>客户端程序</strong> ── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。</li>
<li><strong>客户端 stub 程序</strong> ── 将请求过程的 id 和参数打包进请求信息中。</li>
<li><strong>客户端通信模块</strong> ── 将信息从客户端发送至服务端。</li>
<li><strong>服务端通信模块</strong> ── 将接受的包传给服务端存根程序。</li>
<li><strong>服务端 stub 程序</strong> ── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。</li>
</ul>
<p>RPC 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /someoperation?data=anId</span><br><span class="line"></span><br><span class="line">POST /anotheroperation</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;:&quot;anId&quot;;</span><br><span class="line">  &quot;anotherdata&quot;: &quot;another value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RPC 专注于暴露方法。RPC 通常用于处理内部通讯的性能问题，这样你可以手动处理本地调用以更好的适应你的情况。</p>
<p>当以下情况时选择本地库（也就是 SDK）：</p>
<ul>
<li>你知道你的目标平台。</li>
<li>你想控制如何访问你的“逻辑”。</li>
<li>你想对发生在你的库中的错误进行控制。</li>
<li>性能和终端用户体验是你最关心的事。</li>
</ul>
<p>遵循 <strong>REST</strong> 的 HTTP API 往往更适用于公共 API。</p>
<h4 id="缺点：RPC"><a href="#缺点：RPC" class="headerlink" title="缺点：RPC"></a>缺点：RPC</h4><ul>
<li>RPC 客户端与服务实现捆绑地很紧密。</li>
<li>一个新的 API 必须在每一个操作或者用例中定义。</li>
<li>RPC 很难调试。</li>
<li>你可能没办法很方便的去修改现有的技术。举个例子，如果你希望在 <a href="http://www.squid-cache.org/" target="_blank" rel="noopener">Squid</a> 这样的缓存服务器上确保 <a href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/" target="_blank" rel="noopener">RPC 被正确缓存</a>的话可能需要一些额外的努力了。</li>
</ul>
<h3 id="表述性状态转移（REST）"><a href="#表述性状态转移（REST）" class="headerlink" title="表述性状态转移（REST）"></a>表述性状态转移（REST）</h3><p>REST 是一种强制的客户端/服务端架构设计模型，客户端基于服务端管理的一系列资源操作。服务端提供修改或获取资源的接口。所有的通信必须是无状态和可缓存的。</p>
<p>RESTful 接口有四条规则：</p>
<ul>
<li><strong>标志资源（HTTP 里的 URI）</strong> ── 无论什么操作都使用同一个 URI。</li>
<li><strong>表示的改变（HTTP 的动作）</strong> ── 使用动作, headers 和 body。</li>
<li><strong>可自我描述的错误信息（HTTP 中的 status code）</strong> ── 使用状态码，不要重新造轮子。</li>
<li><strong><a href="http://restcookbook.com/Basics/hateoas/" target="_blank" rel="noopener">HATEOAS</a>（HTTP 中的 HTML 接口）</strong> ── 你的 web 服务器应该能够通过浏览器访问。</li>
</ul>
<p>REST 请求的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /someresources/anId</span><br><span class="line"></span><br><span class="line">PUT /someresources/anId</span><br><span class="line">&#123;&quot;anotherdata&quot;: &quot;another value&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>REST 关注于暴露数据。它减少了客户端／服务端的耦合程度，经常用于公共 HTTP API 接口设计。REST 使用更通常与规范化的方法来通过 URI 暴露资源，<a href="https://github.com/for-GET/know-your-http-well/blob/master/headers.md" target="_blank" rel="noopener">通过 header 来表述</a>并通过 GET、POST、PUT、DELETE 和 PATCH 这些动作来进行操作。因为无状态的特性，REST 易于横向扩展和隔离。</p>
<h4 id="缺点：REST"><a href="#缺点：REST" class="headerlink" title="缺点：REST"></a>缺点：REST</h4><ul>
<li>由于 REST 将重点放在暴露数据，所以当资源不是自然组织的或者结构复杂的时候它可能无法很好的适应。举个例子，返回过去一小时中与特定事件集匹配的更新记录这种操作就很难表示为路径。使用 REST，可能会使用 URI 路径，查询参数和可能的请求体来实现。</li>
<li>REST 一般依赖几个动作（GET、POST、PUT、DELETE 和 PATCH），但有时候仅仅这些没法满足你的需要。举个例子，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单的用上面这几个 verbs 表达。</li>
<li>为了渲染单个页面，获取被嵌套在层级结构中的复杂资源需要客户端，服务器之间多次往返通信。例如，获取博客内容及其关联评论。对于使用不确定网络环境的移动应用来说，这些多次往返通信是非常麻烦的。</li>
<li>随着时间的推移，更多的字段可能会被添加到 API 响应中，较旧的客户端将会接收到所有新的数据字段，即使是那些它们不需要的字段，结果它会增加负载大小并引起更大的延迟。</li>
</ul>
<h3 id="RPC-与-REST-比较"><a href="#RPC-与-REST-比较" class="headerlink" title="RPC 与 REST 比较"></a>RPC 与 REST 比较</h3><table>
<thead>
<tr>
<th>操作</th>
<th>RPC</th>
<th>REST</th>
</tr>
</thead>
<tbody>
<tr>
<td>注册</td>
<td><strong>POST</strong> /signup</td>
<td><strong>POST</strong> /persons</td>
</tr>
<tr>
<td>注销</td>
<td><strong>POST</strong> /resign<br>{<br>“personid”: “1234”<br>}</td>
<td><strong>DELETE</strong> /persons/1234</td>
</tr>
<tr>
<td>读取用户信息</td>
<td><strong>GET</strong> /readPerson?personid=1234</td>
<td><strong>GET</strong> /persons/1234</td>
</tr>
<tr>
<td>读取用户物品列表</td>
<td><strong>GET</strong> /readUsersItemsList?personid=1234</td>
<td><strong>GET</strong> /persons/1234/items</td>
</tr>
<tr>
<td>向用户物品列表添加一项</td>
<td><strong>POST</strong> /addItemToUsersItemsList<br>{<br>“personid”: “1234”;<br>“itemid”: “456”<br>}</td>
<td><strong>POST</strong> /persons/1234/items<br>{<br>“itemid”: “456”<br>}</td>
</tr>
<tr>
<td>更新一个物品</td>
<td><strong>POST</strong> /modifyItem<br>{<br>“itemid”: “456”;<br>“key”: “value”<br>}</td>
<td><strong>PUT</strong> /items/456<br>{<br>“key”: “value”<br>}</td>
</tr>
<tr>
<td>删除一个物品</td>
<td><strong>POST</strong> /removeItem<br>{<br>“itemid”: “456”<br>}</td>
<td><strong>DELETE</strong> /items/456</td>
</tr>
</tbody>
</table>
<p align="center"><br>  <strong><a href="https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc" target="_blank" rel="noopener">资料来源：你真的知道你为什么更喜欢 REST 而不是 RPC 吗</a></strong><br></p>

<h4 id="来源及延伸阅读：REST-与-RPC"><a href="#来源及延伸阅读：REST-与-RPC" class="headerlink" title="来源及延伸阅读：REST 与 RPC"></a>来源及延伸阅读：REST 与 RPC</h4><ul>
<li><a href="https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/" target="_blank" rel="noopener">你真的知道你为什么更喜欢 REST 而不是 RPC 吗</a></li>
<li><a href="http://programmers.stackexchange.com/a/181186" target="_blank" rel="noopener">什么时候 RPC 比 REST 更合适？</a></li>
<li><a href="http://stackoverflow.com/questions/15056878/rest-vs-json-rpc" target="_blank" rel="noopener">REST vs JSON-RPC</a></li>
<li><a href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/" target="_blank" rel="noopener">揭开 RPC 和 REST 的神秘面纱</a></li>
<li><a href="https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs" target="_blank" rel="noopener">使用 REST 的缺点是什么</a></li>
<li><a href="http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview/" target="_blank" rel="noopener">破解系统设计面试</a></li>
<li><a href="https://code.facebook.com/posts/1468950976659943/" target="_blank" rel="noopener">Thrift</a></li>
<li><a href="http://arstechnica.com/civis/viewtopic.php?t=1190508" target="_blank" rel="noopener">为什么在内部使用 REST 而不是 RPC</a></li>
</ul>
<h2 id="15-安全"><a href="#15-安全" class="headerlink" title="15. 安全"></a>15. 安全</h2><p>这一部分需要更多内容。<a href="#贡献">一起来吧</a>！</p>
<p>安全是一个宽泛的话题。除非你有相当的经验、安全方面背景或者正在申请的职位要求安全知识，你不需要了解安全基础知识以外的内容：</p>
<ul>
<li>在运输和等待过程中加密</li>
<li>对所有的用户输入和从用户那里发来的参数进行处理以防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS</a> 和 <a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener">SQL 注入</a>。</li>
<li>使用参数化的查询来防止 SQL 注入。</li>
<li>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener">最小权限原则</a>。</li>
</ul>
<h3 id="来源及延伸阅读-12"><a href="#来源及延伸阅读-12" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="https://github.com/FallibleInc/security-guide-for-developers" target="_blank" rel="noopener">为开发者准备的安全引导</a></li>
<li><a href="https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet" target="_blank" rel="noopener">OWASP top ten</a></li>
</ul>
<h2 id="16-附录"><a href="#16-附录" class="headerlink" title="16. 附录"></a>16. 附录</h2><p>一些时候你会被要求做出保守估计。比如，你可能需要估计从磁盘中生成 100 张图片的缩略图需要的时间或者一个数据结构需要多少的内存。<strong>2 的次方表</strong>和<strong>每个开发者都需要知道的一些时间数据</strong>（译注：OSChina 上有这篇文章的<a href="https://www.oschina.net/news/30009/every-programmer-should-know" target="_blank" rel="noopener">译文</a>）都是一些很方便的参考资料。</p>
<h3 id="2-的次方表"><a href="#2-的次方表" class="headerlink" title="2 的次方表"></a>2 的次方表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Power           Exact Value         Approx Value        Bytes</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">7                             128</span><br><span class="line">8                             256</span><br><span class="line">10                           1024   1 thousand           1 KB</span><br><span class="line">16                         65,536                       64 KB</span><br><span class="line">20                      1,048,576   1 million            1 MB</span><br><span class="line">30                  1,073,741,824   1 billion            1 GB</span><br><span class="line">32                  4,294,967,296                        4 GB</span><br><span class="line">40              1,099,511,627,776   1 trillion           1 TB</span><br></pre></td></tr></table></figure>
<h4 id="来源及延伸阅读-13"><a href="#来源及延伸阅读-13" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Power_of_two" target="_blank" rel="noopener">2 的次方</a></li>
</ul>
<h3 id="每个程序员都应该知道的延迟数"><a href="#每个程序员都应该知道的延迟数" class="headerlink" title="每个程序员都应该知道的延迟数"></a>每个程序员都应该知道的延迟数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Latency Comparison Numbers</span><br><span class="line">--------------------------</span><br><span class="line">L1 cache reference                           0.5 ns</span><br><span class="line">Branch mispredict                            5   ns</span><br><span class="line">L2 cache reference                           7   ns                      14x L1 cache</span><br><span class="line">Mutex lock/unlock                          100   ns</span><br><span class="line">Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache</span><br><span class="line">Compress 1K bytes with Zippy            10,000   ns       10 us</span><br><span class="line">Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us</span><br><span class="line">Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD</span><br><span class="line">Read 1 MB sequentially from memory     250,000   ns      250 us</span><br><span class="line">Round trip within same datacenter      500,000   ns      500 us</span><br><span class="line">Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory</span><br><span class="line">Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip</span><br><span class="line">Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD</span><br><span class="line">Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">1 ns = 10^-9 seconds</span><br><span class="line">1 us = 10^-6 seconds = 1,000 ns</span><br><span class="line">1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</span><br></pre></td></tr></table></figure>
<p>基于上述数字的指标：</p>
<ul>
<li>从磁盘以 30 MB/s 的速度顺序读取</li>
<li>以 100 MB/s 从 1 Gbps 的以太网顺序读取</li>
<li>从 SSD 以 1 GB/s 的速度读取</li>
<li>以 4 GB/s 的速度从主存读取</li>
<li>每秒能绕地球 6-7 圈</li>
<li>数据中心内每秒有 2,000 次往返</li>
</ul>
<h4 id="延迟数可视化"><a href="#延迟数可视化" class="headerlink" title="延迟数可视化"></a>延迟数可视化</h4><p><br><div align="center"><img src="https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67"></div><br></p>
<h4 id="来源及延伸阅读-14"><a href="#来源及延伸阅读-14" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h4><ul>
<li><a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener">每个程序员都应该知道的延迟数 — 1</a></li>
<li><a href="https://gist.github.com/hellerbarde/2843375" target="_blank" rel="noopener">每个程序员都应该知道的延迟数 — 2</a></li>
<li><a href="http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf" target="_blank" rel="noopener">关于建设大型分布式系统的的设计方案、课程和建议</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf" target="_blank" rel="noopener">关于建设大型可拓展分布式系统的软件工程咨询</a></li>
</ul>
<h2 id="17-资料"><a href="#17-资料" class="headerlink" title="17. 资料"></a>17. 资料</h2><ul>
<li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#域名系统" target="_blank" rel="noopener">系统设计入门</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/07/12/programming/java/javaweb/distributed/rpc/zookeeper-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/12/programming/java/javaweb/distributed/rpc/zookeeper-basics/" itemprop="url">ZooKeeper 基础篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T00:00:00+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ZooKeeper-基础篇"><a href="#ZooKeeper-基础篇" class="headerlink" title="ZooKeeper 基础篇"></a>ZooKeeper 基础篇</h1><blockquote>
<p>ZooKeeper 是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。</p>
<p>ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>本文旨在快速入门 ZooKeeper，侧重于介绍如何使用。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-安装">1. 安装</a><ul>
<li><a href="#11-下载解压-zookeeper">1.1. 下载解压 ZooKeeper</a></li>
<li><a href="#12-创建配置文件">1.2. 创建配置文件</a></li>
<li><a href="#13-启动-zookeeper-服务器">1.3. 启动 ZooKeeper 服务器</a></li>
<li><a href="#14-启动-cli">1.4. 启动 CLI</a></li>
<li><a href="#15-停止-zookeeper-服务器">1.5. 停止 ZooKeeper 服务器</a></li>
</ul>
</li>
<li><a href="#2-cli">2. CLI</a><ul>
<li><a href="#21-创建-znodes">2.1. 创建 Znodes</a></li>
<li><a href="#22-获取数据">2.2. 获取数据</a></li>
<li><a href="#23-watch监视">2.3. Watch（监视）</a></li>
<li><a href="#24-设置数据">2.4. 设置数据</a></li>
<li><a href="#25-创建子项子节点">2.5. 创建子项/子节点</a></li>
<li><a href="#26-列出子项">2.6. 列出子项</a></li>
<li><a href="#27-检查状态">2.7. 检查状态</a></li>
<li><a href="#28-移除-znode">2.8. 移除 Znode</a></li>
</ul>
</li>
<li><a href="#3-api">3. API</a><ul>
<li><a href="#31-zookeeper-api-的基础知识">3.1. ZooKeeper API 的基础知识</a></li>
<li><a href="#32-java-绑定">3.2. Java 绑定</a></li>
<li><a href="#33-连接到-zookeeper-集合">3.3. 连接到 ZooKeeper 集合</a></li>
<li><a href="#34-创建-znode">3.4. 创建 Znode</a></li>
<li><a href="#35-exists---检查-znode-的存在">3.5. Exists - 检查 Znode 的存在</a></li>
<li><a href="#36-getdata-方法">3.6. getData 方法</a></li>
<li><a href="#37-setdata-方法">3.7. setData 方法</a></li>
<li><a href="#38-getchildren-方法">3.8. getChildren 方法</a></li>
<li><a href="#39-删除-znode">3.9. 删除 Znode</a></li>
</ul>
</li>
<li><a href="#4-资源">4. 资源</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>在安装 ZooKeeper 之前，请确保你的系统是在以下任一操作系统上运行：</p>
<ul>
<li><strong>任意 Linux OS</strong> - 支持开发和部署。适合演示应用程序。</li>
<li><strong>Windows OS</strong> - 仅支持开发。</li>
<li><strong>Mac OS</strong> - 仅支持开发。</li>
</ul>
<p>环境要求：JDK6+</p>
<p>安装步骤如下：</p>
<h3 id="1-1-下载解压-ZooKeeper"><a href="#1-1-下载解压-ZooKeeper" class="headerlink" title="1.1. 下载解压 ZooKeeper"></a>1.1. 下载解压 ZooKeeper</h3><p>进入官方下载地址：<a href="http://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">http://zookeeper.apache.org/releases.html#download</a> ，选择合适版本。</p>
<p>解压到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxf zookeeper-3.4.6.tar.gz</span><br><span class="line">$ cd zookeeper-3.4.6</span><br></pre></td></tr></table></figure>
<h3 id="1-2-创建配置文件"><a href="#1-2-创建配置文件" class="headerlink" title="1.2. 创建配置文件"></a>1.2. 创建配置文件</h3><p>你必须创建 <code>conf/zoo.cfg</code> 文件，否则启动时会提示你没有此文件。</p>
<p>初次尝试，不妨直接使用 Kafka 提供的模板配置文件 <code>conf/zoo_sample.cfg</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp conf/zoo_sample.cfg conf/zoo.cfg</span><br></pre></td></tr></table></figure>
<h3 id="1-3-启动-ZooKeeper-服务器"><a href="#1-3-启动-ZooKeeper-服务器" class="headerlink" title="1.3. 启动 ZooKeeper 服务器"></a>1.3. 启动 ZooKeeper 服务器</h3><p>执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>执行此命令后，你将收到以下响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ JMX enabled by default</span><br><span class="line">$ Using config: /Users/../zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">$ Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>
<h3 id="1-4-启动-CLI"><a href="#1-4-启动-CLI" class="headerlink" title="1.4. 启动 CLI"></a>1.4. 启动 CLI</h3><p>键入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/zkCli.sh</span><br></pre></td></tr></table></figure>
<p>键入上述命令后，将连接到 ZooKeeper 服务器，你应该得到以下响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connecting to localhost:2181</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type: None path:null</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure>
<h3 id="1-5-停止-ZooKeeper-服务器"><a href="#1-5-停止-ZooKeeper-服务器" class="headerlink" title="1.5. 停止 ZooKeeper 服务器"></a>1.5. 停止 ZooKeeper 服务器</h3><p>连接服务器并执行所有操作后，可以使用以下命令停止 zookeeper 服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本节安装内容参考：<a href="https://www.w3cschool.cn/zookeeper/zookeeper_installation.html" target="_blank" rel="noopener">Zookeeper 安装</a></p>
</blockquote>
<h2 id="2-CLI"><a href="#2-CLI" class="headerlink" title="2. CLI"></a>2. CLI</h2><p>ZooKeeper 命令行界面（CLI）用于与 ZooKeeper 集合进行交互以进行开发。它有助于调试和解决不同的选项。</p>
<p>要执行 ZooKeeper CLI 操作，首先打开 ZooKeeper 服务器（“bin/zkServer.sh start”），然后打开 ZooKeeper 客户端（“bin/zkCli.sh”）。一旦客户端启动，你可以执行以下操作：</p>
<ul>
<li>创建 znode</li>
<li>获取数据</li>
<li>监视 znode 的变化</li>
<li>设置数据</li>
<li>创建 znode 的子节点</li>
<li>列出 znode 的子节点</li>
<li>检查状态</li>
<li>移除/删除 znode</li>
</ul>
<p>现在让我们用一个例子逐个了解上面的命令。</p>
<h3 id="2-1-创建-Znodes"><a href="#2-1-创建-Znodes" class="headerlink" title="2.1. 创建 Znodes"></a>2.1. 创建 Znodes</h3><p>用给定的路径创建一个 znode。flag 参数指定创建的 znode 是临时的，持久的还是顺序的。默认情况下，所有 znode 都是持久的。</p>
<p>当会话过期或客户端断开连接时，临时节点（flag：-e）将被自动删除。</p>
<p>顺序节点保证 znode 路径将是唯一的。</p>
<p>ZooKeeper 集合将向 znode 路径填充 10 位序列号。例如，znode 路径 /myapp 将转换为 /myapp0000000001，下一个序列号将为 /myapp0000000002。如果没有指定 flag，则 znode 被认为是持久的。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /path /data</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /FirstZnode “Myfirstzookeeper-app&quot;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] create /FirstZnode “Myfirstzookeeper-app&quot;</span><br><span class="line">Created /FirstZnode</span><br></pre></td></tr></table></figure>
<p>要创建<strong>顺序节点</strong>，请添加 flag：<strong>-s</strong>，如下所示。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /path /data</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /FirstZnode second-data</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -s /FirstZnode “second-data&quot;</span><br><span class="line">Created /FirstZnode0000000023</span><br></pre></td></tr></table></figure>
<p>要创建<strong>临时节点</strong>，请添加 flag：<strong>-e</strong> ，如下所示。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /path /data</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /SecondZnode “Ephemeral-data&quot;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /SecondZnode “Ephemeral-data&quot;</span><br><span class="line">Created /SecondZnode</span><br></pre></td></tr></table></figure>
<p>记住当客户端断开连接时，临时节点将被删除。你可以通过退出 ZooKeeper CLI，然后重新打开 CLI 来尝试。</p>
<h3 id="2-2-获取数据"><a href="#2-2-获取数据" class="headerlink" title="2.2. 获取数据"></a>2.2. 获取数据</h3><p>它返回 znode 的关联数据和指定 znode 的元数据。你将获得信息，例如上次修改数据的时间，修改的位置以及数据的相关信息。此 CLI 还用于分配监视器以显示数据相关的通知。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /path</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /FirstZnode</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode</span><br><span class="line">“Myfirstzookeeper-app&quot;</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x7f</span><br><span class="line">mtime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 22</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p>要访问顺序节点，必须输入 znode 的完整路径。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /FirstZnode0000000023</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode0000000023</span><br><span class="line">“Second-data&quot;</span><br><span class="line">cZxid = 0x80</span><br><span class="line">ctime = Tue Sep 29 16:25:47 IST 2015</span><br><span class="line">mZxid = 0x80</span><br><span class="line">mtime = Tue Sep 29 16:25:47 IST 2015</span><br><span class="line">pZxid = 0x80</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 13</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Watch（监视）"><a href="#2-3-Watch（监视）" class="headerlink" title="2.3. Watch（监视）"></a>2.3. Watch（监视）</h3><p>当指定的 znode 或 znode 的子数据更改时，监视器会显示通知。你只能在 <strong>get</strong> 命令中设置<strong>watch</strong>。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /path [watch] 1</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /FirstZnode 1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode 1</span><br><span class="line">“Myfirstzookeeper-app&quot;</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x7f</span><br><span class="line">mtime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 22</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p>输出类似于普通的 <strong>get</strong> 命令，但它会等待后台等待 znode 更改。&lt;从这里开始&gt;</p>
<h3 id="2-4-设置数据"><a href="#2-4-设置数据" class="headerlink" title="2.4. 设置数据"></a>2.4. 设置数据</h3><p>设置指定 znode 的数据。完成此设置操作后，你可以使用 <strong>get</strong> CLI 命令检查数据。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /path /data</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /SecondZnode Data-updated</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /SecondZnode “Data-updated&quot;</span><br><span class="line">cZxid = 0x82</span><br><span class="line">ctime = Tue Sep 29 16:29:50 IST 2015</span><br><span class="line">mZxid = 0x83</span><br><span class="line">mtime = Tue Sep 29 16:29:50 IST 2015</span><br><span class="line">pZxid = 0x82</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x15018b47db00000</span><br><span class="line">dataLength = 14</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p>如果你在 <strong>get</strong> 命令中分配了<strong>watch</strong>选项（如上一个命令），则输出将类似如下所示。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode “Mysecondzookeeper-app&quot;</span><br><span class="line"></span><br><span class="line">WATCHER: :</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/FirstZnode</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x84</span><br><span class="line">mtime = Tue Sep 29 17:14:47 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 23</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<h3 id="2-5-创建子项-子节点"><a href="#2-5-创建子项-子节点" class="headerlink" title="2.5. 创建子项/子节点"></a>2.5. 创建子项/子节点</h3><p>创建子节点类似于创建新的 znode。唯一的区别是，子 znode 的路径也将具有父路径。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /parent/path/subnode/path /data</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /FirstZnode/Child1 firstchildren</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 16] create /FirstZnode/Child1 “firstchildren&quot;</span><br><span class="line">created /FirstZnode/Child1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 17] create /FirstZnode/Child2 “secondchildren&quot;</span><br><span class="line">created /FirstZnode/Child2</span><br></pre></td></tr></table></figure>
<h3 id="2-6-列出子项"><a href="#2-6-列出子项" class="headerlink" title="2.6. 列出子项"></a>2.6. 列出子项</h3><p>此命令用于列出和显示 znode 的子项。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /path</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /MyFirstZnode</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /MyFirstZnode</span><br><span class="line">[mysecondsubnode, myfirstsubnode]</span><br></pre></td></tr></table></figure>
<h3 id="2-7-检查状态"><a href="#2-7-检查状态" class="headerlink" title="2.7. 检查状态"></a>2.7. 检查状态</h3><p>状态描述指定的 znode 的元数据。它包含时间戳，版本号，ACL，数据长度和子 znode 等细项。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat /path</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat /FirstZnode</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] stat /FirstZnode</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x7f</span><br><span class="line">mtime = Tue Sep 29 17:14:24 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 23</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<h3 id="2-8-移除-Znode"><a href="#2-8-移除-Znode" class="headerlink" title="2.8. 移除 Znode"></a>2.8. 移除 Znode</h3><p>移除指定的 znode 并递归其所有子节点。只有在这样的 znode 可用的情况下才会发生。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmr /path</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmr /FirstZnode</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] rmr /FirstZnode</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] get /FirstZnode</span><br><span class="line">Node does not exist: /FirstZnode</span><br></pre></td></tr></table></figure>
<p>删除（delete/path）命令类似于 remove 命令，除了它只适用于没有子节点的 znode。</p>
<h2 id="3-API"><a href="#3-API" class="headerlink" title="3. API"></a>3. API</h2><p>ZooKeeper 有一个绑定 Java 和 C 的官方 API。Zookeeper 社区为大多数语言（.NET，python 等）提供非官方 API。</p>
<p>使用 ZooKeeper API，应用程序可以连接，交互，操作数据，协调，最后断开与 ZooKeeper 集合的连接。</p>
<p>ZooKeeper API 具有丰富的功能，以简单和安全的方式获得 ZooKeeper 集合的所有功能。ZooKeeper API 提供同步和异步方法。</p>
<p>ZooKeeper 集合和 ZooKeeper API 在各个方面都完全相辅相成，对开发人员有很大的帮助。让我们在本章讨论 Java 绑定。</p>
<h3 id="3-1-ZooKeeper-API-的基础知识"><a href="#3-1-ZooKeeper-API-的基础知识" class="headerlink" title="3.1. ZooKeeper API 的基础知识"></a>3.1. ZooKeeper API 的基础知识</h3><p>与 ZooKeeper 集合进行交互的应用程序称为 <strong>ZooKeeper 客户端</strong>。</p>
<p>Znode 是 ZooKeeper 集合的核心组件，ZooKeeper API 提供了一小组方法使用 ZooKeeper 集合来操纵 znode 的所有细节。</p>
<p>客户端应该遵循以步骤，与 ZooKeeper 集合进行清晰和干净的交互。</p>
<ul>
<li>连接到 ZooKeeper 集合。ZooKeeper 集合为客户端分配会话 ID。</li>
<li>定期向服务器发送心跳。否则，ZooKeeper 集合将过期会话 ID，客户端需要重新连接。</li>
<li>只要会话 ID 处于活动状态，就可以获取/设置 znode。</li>
<li>所有任务完成后，断开与 ZooKeeper 集合的连接。如果客户端长时间不活动，则 ZooKeeper 集合将自动断开客户端。</li>
</ul>
<h3 id="3-2-Java-绑定"><a href="#3-2-Java-绑定" class="headerlink" title="3.2. Java 绑定"></a>3.2. Java 绑定</h3><p>让我们来了解本章中最重要的一组 ZooKeeper API。ZooKeeper API 的核心部分是<strong>ZooKeeper 类</strong>。它提供了在其构造函数中连接 ZooKeeper 集合的选项，并具有以下方法：</p>
<ul>
<li><strong>connect</strong> - 连接到 ZooKeeper 集合</li>
<li><strong>create</strong>- 创建 znode</li>
<li><strong>exists</strong>- 检查 znode 是否存在及其信息</li>
<li><strong>getData</strong> - 从特定的 znode 获取数据</li>
<li><strong>setData</strong> - 在特定的 znode 中设置数据</li>
<li><strong>getChildren</strong> - 获取特定 znode 中的所有子节点</li>
<li><strong>delete</strong> - 删除特定的 znode 及其所有子项</li>
<li><strong>close</strong> - 关闭连接</li>
</ul>
<h3 id="3-3-连接到-ZooKeeper-集合"><a href="#3-3-连接到-ZooKeeper-集合" class="headerlink" title="3.3. 连接到 ZooKeeper 集合"></a>3.3. 连接到 ZooKeeper 集合</h3><p>ZooKeeper 类通过其构造函数提供 connect 功能。构造函数的签名如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper(String connectionString, int sessionTimeout, Watcher watcher)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>connectionString</strong> - ZooKeeper 集合主机。</li>
<li><strong>sessionTimeout</strong> - 会话超时（以毫秒为单位）。</li>
<li><strong>watcher</strong> - 实现“监视器”界面的对象。ZooKeeper 集合通过监视器对象返回连接状态。</li>
</ul>
<p>让我们创建一个新的帮助类 <strong>ZooKeeperConnection</strong> ，并添加一个方法 <strong>connect</strong> 。 <strong>connect</strong> 方法创建一个 ZooKeeper 对象，连接到 ZooKeeper 集合，然后返回对象。</p>
<p>这里 <strong>CountDownLatch</strong> 用于停止（等待）主进程，直到客户端与 ZooKeeper 集合连接。</p>
<p>ZooKeeper 集合通过监视器回调来回复连接状态。一旦客户端与 ZooKeeper 集合连接，监视器回调就会被调用，并且监视器回调函数调用<strong>CountDownLatch</strong>的<strong>countDown</strong>方法来释放锁，在主进程中<strong>await</strong>。</p>
<p>以下是与 ZooKeeper 集合连接的完整代码。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import java classes</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import zookeeper classes</span></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.AsyncCallback.StatCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException.Code;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperConnection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// declare zookeeper instance to access ZooKeeper ensemble</span></span><br><span class="line">   <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line">   <span class="keyword">final</span> CountDownLatch connectedSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to connect zookeeper ensemble.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">connect</span><span class="params">(String host)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">      zoo = <span class="keyword">new</span> ZooKeeper(host,<span class="number">5000</span>,<span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent we)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (we.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">               connectedSignal.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      connectedSignal.await();</span><br><span class="line">      <span class="keyword">return</span> zoo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to disconnect from zookeeper server</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      zoo.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存上面的代码，它将在下一节中用于连接 ZooKeeper 集合。</p>
<h3 id="3-4-创建-Znode"><a href="#3-4-创建-Znode" class="headerlink" title="3.4. 创建 Znode"></a>3.4. 创建 Znode</h3><p>ZooKeeper 类提供了在 ZooKeeper 集合中创建一个新的 znode 的<strong>create</strong>方法。 <strong>create</strong> 方法的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create(String path, byte[] data, List&lt;ACL&gt; acl, CreateMode createMode)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - Znode 路径。例如，/myapp1，/myapp2，/myapp1/mydata1，myapp2/mydata1/myanothersubdata</li>
<li><strong>data</strong> - 要存储在指定 znode 路径中的数据</li>
<li><strong>acl</strong> - 要创建的节点的访问控制列表。ZooKeeper API 提供了一个静态接口 <strong>ZooDefs.Ids</strong> 来获取一些基本的 acl 列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE 返回打开 znode 的 acl 列表。</li>
<li><strong>createMode</strong> - 节点的类型，即临时，顺序或两者。这是一个<strong>枚举</strong>。</li>
</ul>
<p>让我们创建一个新的 Java 应用程序来检查 ZooKeeper API 的 <strong>create</strong> 功能。创建文件 <strong>ZKCreate.java</strong> 。在 main 方法中，创建一个类型为 <strong>ZooKeeperConnection</strong> 的对象，并调用 <strong>connect</strong> 方法连接到 ZooKeeper 集合。</p>
<p>connect 方法将返回 ZooKeeper 对象 <strong>zk</strong> 。现在，请使用自定义<strong>path</strong>和<strong>data</strong>调用 <strong>zk</strong> 对象的 <strong>create</strong> 方法。</p>
<p>创建 znode 的完整程序代码如下：</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCreate</span> </span>&#123;</span><br><span class="line">   <span class="comment">// create static instance for zookeeper class.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// create static instance for ZooKeeperConnection class.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to create znode in zookeeper ensemble</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">      KeeperException,InterruptedException </span>&#123;</span><br><span class="line">      zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">      CreateMode.PERSISTENT);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// znode path</span></span><br><span class="line">      String path = <span class="string">"/MyFirstZnode"</span>; <span class="comment">// Assign path to znode</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// data in byte array</span></span><br><span class="line">      <span class="keyword">byte</span>[] data = <span class="string">"My first zookeeper app"</span>.getBytes(); <span class="comment">// Declare data</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> ZooKeeperConnection();</span><br><span class="line">         zk = conn.connect(<span class="string">"localhost"</span>);</span><br><span class="line">         create(path, data); <span class="comment">// Create the data to the specified path</span></span><br><span class="line">         conn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage()); <span class="comment">//Catch error message</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦编译和执行应用程序，将在 ZooKeeper 集合中创建具有指定数据的 znode。你可以使用 ZooKeeper CLI <strong>zkCli.sh</strong> 进行检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; get /MyFirstZnode</span><br></pre></td></tr></table></figure>
<h3 id="3-5-Exists-检查-Znode-的存在"><a href="#3-5-Exists-检查-Znode-的存在" class="headerlink" title="3.5. Exists - 检查 Znode 的存在"></a>3.5. Exists - 检查 Znode 的存在</h3><p>ZooKeeper 类提供了 <strong>exists</strong> 方法来检查 znode 的存在。如果指定的 znode 存在，则返回一个 znode 的元数据。<strong>exists</strong>方法的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists(String path, boolean watcher)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong>- Znode 路径</li>
<li><strong>watcher</strong> - 布尔值，用于指定是否监视指定的 znode</li>
</ul>
<p>让我们创建一个新的 Java 应用程序来检查 ZooKeeper API 的“exists”功能。创建文件“ZKExists.java”。在 main 方法中，使用“ZooKeeperConnection”对象创建 ZooKeeper 对象“zk”。然后，使用自定义“path”调用“zk”对象的“exists”方法。完整的列表如下：</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKExists</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to check existence of znode and its status, if znode is available.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stat <span class="title">znode_exists</span><span class="params">(String path)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">      KeeperException,InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> zk.exists(path, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException </span>&#123;</span><br><span class="line">      String path = <span class="string">"/MyFirstZnode"</span>; <span class="comment">// Assign znode to the specified path</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> ZooKeeperConnection();</span><br><span class="line">         zk = conn.connect(<span class="string">"localhost"</span>);</span><br><span class="line">         Stat stat = znode_exists(path); <span class="comment">// Stat checks the path of the znode</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Node exists and the node version is "</span> +</span><br><span class="line">            stat.getVersion());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Node does not exists"</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage()); <span class="comment">// Catches error messages</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦编译和执行应用程序，你将获得以下输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node exists and the node version is 1.</span><br></pre></td></tr></table></figure>
<h3 id="3-6-getData-方法"><a href="#3-6-getData-方法" class="headerlink" title="3.6. getData 方法"></a>3.6. getData 方法</h3><p>ZooKeeper 类提供 <strong>getData</strong> 方法来获取附加在指定 znode 中的数据及其状态。 <strong>getData</strong> 方法的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getData(String path, Watcher watcher, Stat stat)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - Znode 路径。</li>
<li><strong>watcher</strong> - 监视器类型的回调函数。当指定的 znode 的数据改变时，ZooKeeper 集合将通过监视器回调进行通知。这是一次性通知。</li>
<li><strong>stat</strong> - 返回 znode 的元数据。</li>
</ul>
<p>让我们创建一个新的 Java 应用程序来了解 ZooKeeper API 的 <strong>getData</strong> 功能。创建文件 <strong>ZKGetData.java</strong> 。在 main 方法中，使用 <strong>ZooKeeperConnection</strong> 对象创建一个 ZooKeeper 对象 <strong>zk</strong> 。然后，使用自定义路径调用 zk 对象的 <strong>getData</strong> 方法。</p>
<p>下面是从指定节点获取数据的完整程序代码：</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKGetData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stat <span class="title">znode_exists</span><span class="params">(String path)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">      KeeperException,InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> zk.exists(path,<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">      String path = <span class="string">"/MyFirstZnode"</span>;</span><br><span class="line">      <span class="keyword">final</span> CountDownLatch connectedSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> ZooKeeperConnection();</span><br><span class="line">         zk = conn.connect(<span class="string">"localhost"</span>);</span><br><span class="line">         Stat stat = znode_exists(path);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = zk.getData(path, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent we)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (we.getType() == Event.EventType.None) &#123;</span><br><span class="line">                     <span class="keyword">switch</span>(we.getState()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> Expired:</span><br><span class="line">                        connectedSignal.countDown();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     String path = <span class="string">"/MyFirstZnode"</span>;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] bn = zk.getData(path,</span><br><span class="line">                        <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                        String data = <span class="keyword">new</span> String(bn,</span><br><span class="line">                        <span class="string">"UTF-8"</span>);</span><br><span class="line">                        System.out.println(data);</span><br><span class="line">                        connectedSignal.countDown();</span><br><span class="line"></span><br><span class="line">                     &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">                        System.out.println(ex.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            String data = <span class="keyword">new</span> String(b, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            connectedSignal.await();</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Node does not exists"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦编译和执行应用程序，你将获得以下输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My first zookeeper app</span><br></pre></td></tr></table></figure>
<p>应用程序将等待 ZooKeeper 集合的进一步通知。使用 ZooKeeper CLI <strong>zkCli.sh</strong> 更改指定 znode 的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; set /MyFirstZnode Hello</span><br></pre></td></tr></table></figure>
<p>现在，应用程序将打印以下输出并退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>
<h3 id="3-7-setData-方法"><a href="#3-7-setData-方法" class="headerlink" title="3.7. setData 方法"></a>3.7. setData 方法</h3><p>ZooKeeper 类提供 <strong>setData</strong> 方法来修改指定 znode 中附加的数据。 <strong>setData</strong> 方法的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setData(String path, byte[] data, int version)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong>- Znode 路径</li>
<li><strong>data</strong> - 要存储在指定 znode 路径中的数据。</li>
<li><strong>version</strong>- znode 的当前版本。每当数据更改时，ZooKeeper 会更新 znode 的版本号。</li>
</ul>
<p>现在让我们创建一个新的 Java 应用程序来了解 ZooKeeper API 的 <strong>setData</strong> 功能。创建文件 <strong>ZKSetData.java</strong> 。在 main 方法中，使用 <strong>ZooKeeperConnection</strong> 对象创建一个 ZooKeeper 对象 <strong>zk</strong> 。然后，使用指定的路径，新数据和节点版本调用 <strong>zk</strong> 对象的 <strong>setData</strong> 方法。</p>
<p>以下是修改附加在指定 znode 中的数据的完整程序代码。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKSetData</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to update the data in a znode. Similar to getData but without watcher.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">      KeeperException,InterruptedException </span>&#123;</span><br><span class="line">      zk.setData(path, data, zk.exists(path,<span class="keyword">true</span>).getVersion());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException </span>&#123;</span><br><span class="line">      String path= <span class="string">"/MyFirstZnode"</span>;</span><br><span class="line">      <span class="keyword">byte</span>[] data = <span class="string">"Success"</span>.getBytes(); <span class="comment">//Assign data which is to be updated.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> ZooKeeperConnection();</span><br><span class="line">         zk = conn.connect(<span class="string">"localhost"</span>);</span><br><span class="line">         update(path, data); <span class="comment">// Update znode data to the specified path</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并执行应用程序后，指定的 znode 的数据将被改变，并且可以使用 ZooKeeper CLI <strong>zkCli.sh</strong> 进行检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; get /MyFirstZnode</span><br></pre></td></tr></table></figure>
<h3 id="3-8-getChildren-方法"><a href="#3-8-getChildren-方法" class="headerlink" title="3.8. getChildren 方法"></a>3.8. getChildren 方法</h3><p>ZooKeeper 类提供 <strong>getChildren</strong> 方法来获取特定 znode 的所有子节点。 <strong>getChildren</strong> 方法的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getChildren(String path, Watcher watcher)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - Znode 路径。</li>
<li><strong>watcher</strong> - 监视器类型的回调函数。当指定的 znode 被删除或 znode 下的子节点被创建/删除时，ZooKeeper 集合将进行通知。这是一次性通知。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKGetChildren</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to check existence of znode and its status, if znode is available.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stat <span class="title">znode_exists</span><span class="params">(String path)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">      KeeperException,InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> zk.exists(path,<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException </span>&#123;</span><br><span class="line">      String path = <span class="string">"/MyFirstZnode"</span>; <span class="comment">// Assign path to the znode</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> ZooKeeperConnection();</span><br><span class="line">         zk = conn.connect(<span class="string">"localhost"</span>);</span><br><span class="line">         Stat stat = znode_exists(path); <span class="comment">// Stat checks the path</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(stat!= <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// getChildren method - get all the children of znode.It has two args, path and watch</span></span><br><span class="line">            List &lt;String&gt; children = zk.getChildren(path, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.size(); i++)</span><br><span class="line">            System.out.println(children.get(i)); <span class="comment">//Print children's</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Node does not exists"</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行程序之前，让我们使用 ZooKeeper CLI <strong>zkCli.sh</strong> 为 <strong>/MyFirstZnode</strong> 创建两个子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; create /MyFirstZnode/myfirstsubnode Hi</span><br><span class="line">&gt;&gt;&gt; create /MyFirstZnode/mysecondsubmode Hi</span><br></pre></td></tr></table></figure>
<p>现在，编译和运行程序将输出上面创建的 znode。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myfirstsubnode</span><br><span class="line">mysecondsubnode</span><br></pre></td></tr></table></figure>
<h3 id="3-9-删除-Znode"><a href="#3-9-删除-Znode" class="headerlink" title="3.9. 删除 Znode"></a>3.9. 删除 Znode</h3><p>ZooKeeper 类提供了 <strong>delete</strong> 方法来删除指定的 znode。 <strong>delete</strong> 方法的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(String path, int version)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - Znode 路径。</li>
<li><strong>version</strong> - znode 的当前版本。</li>
</ul>
<p>让我们创建一个新的 Java 应用程序来了解 ZooKeeper API 的 <strong>delete</strong> 功能。创建文件 <strong>ZKDelete.java</strong> 。在 main 方法中，使用 <strong>ZooKeeperConnection</strong> 对象创建一个 ZooKeeper 对象 <strong>zk</strong> 。然后，使用指定的路径和版本号调用 <strong>zk</strong> 对象的 <strong>delete</strong> 方法。</p>
<p>删除 znode 的完整程序代码如下：</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDelete</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to check existence of znode and its status, if znode is available.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span> <span class="keyword">throws</span> KeeperException,InterruptedException </span>&#123;</span><br><span class="line">      zk.delete(path,zk.exists(path,<span class="keyword">true</span>).getVersion());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException </span>&#123;</span><br><span class="line">      String path = <span class="string">"/MyFirstZnode"</span>; <span class="comment">//Assign path to the znode</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> ZooKeeperConnection();</span><br><span class="line">         zk = conn.connect(<span class="string">"localhost"</span>);</span><br><span class="line">         delete(path); <span class="comment">//delete the node with the specified path</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage()); <span class="comment">// catches error messages</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-资源"><a href="#4-资源" class="headerlink" title="4. 资源"></a>4. 资源</h2><p>| <a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">官网</a> | <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER" target="_blank" rel="noopener">官网文档</a> | <a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">Github</a> |</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/07/12/programming/java/javaweb/distributed/mq/kafka-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/12/programming/java/javaweb/distributed/mq/kafka-basics/" itemprop="url">Kafka 实战篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T00:00:00+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kafka-实战篇"><a href="#Kafka-实战篇" class="headerlink" title="Kafka 实战篇"></a>Kafka 实战篇</h1><blockquote>
<p>Kafka 是一个分布式的、可水平扩展的、基于发布/订阅模式的、支持容错的消息系统。</p>
<p>| <a href="http://kafka.apache.org/" target="_blank" rel="noopener"><strong>官网</strong></a> | <a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener"><strong>官方文档</strong></a> | <a href="https://github.com/apache/kafka" target="_blank" rel="noopener"><strong>Github</strong></a> |</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-概述">1. 概述</a><ul>
<li><a href="#11-简介">1.1. 简介</a></li>
<li><a href="#12-系统结构和存储结构">1.2. 系统结构和存储结构</a></li>
<li><a href="#13-小结">1.3. 小结</a></li>
</ul>
</li>
<li><a href="#2-安装部署">2. 安装部署</a><ul>
<li><a href="#21-下载解压">2.1. 下载解压</a></li>
<li><a href="#22-启动服务器">2.2. 启动服务器</a></li>
<li><a href="#23-停止服务器">2.3. 停止服务器</a></li>
<li><a href="#24-创建主题">2.4. 创建主题</a></li>
<li><a href="#25-生产者生产消息">2.5. 生产者生产消息</a></li>
<li><a href="#26-消费者消费消息">2.6. 消费者消费消息</a></li>
<li><a href="#27-集群部署">2.7. 集群部署</a></li>
</ul>
</li>
<li><a href="#3-api">3. API</a></li>
<li><a href="#4-生产者producer">4. 生产者（Producer）</a><ul>
<li><a href="#41-发送消息流程">4.1. 发送消息流程</a></li>
<li><a href="#42-发送消息方式">4.2. 发送消息方式</a></li>
</ul>
</li>
<li><a href="#5-消费者consumer">5. 消费者（Consumer）</a><ul>
<li><a href="#51-消费者和消费者群组">5.1. 消费者和消费者群组</a></li>
<li><a href="#52-消费消息流程">5.2. 消费消息流程</a></li>
<li><a href="#53-提交偏移量">5.3. 提交偏移量</a></li>
<li><a href="#54-从指定偏移量获取数据">5.4. 从指定偏移量获取数据</a></li>
</ul>
</li>
<li><a href="#6-broker">6. Broker</a><ul>
<li><a href="#61-集群控制器">6.1. 集群控制器</a></li>
<li><a href="#62-分区-leader-和-follower">6.2. 分区 leader 和 follower</a></li>
<li><a href="#63-群组协调器">6.3. 群组协调器</a></li>
</ul>
</li>
<li><a href="#7-zookeeper-集群">7. Zookeeper 集群</a><ul>
<li><a href="#71-节点信息">7.1. 节点信息</a></li>
<li><a href="#72-zookeeper-一些总结">7.2. zookeeper 一些总结</a></li>
</ul>
</li>
<li><a href="#8-资料">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h3><p>Kafka 是一个分布式的、可水平扩展的、基于发布/订阅模式的、支持容错的 MQ 中间件。具有如下特点：</p>
<ul>
<li>伸缩性。随着数据量增长，可以通过对 broker 集群水平扩展来提高系统性能。</li>
<li>高性能。通过横向扩展生产者、消费者(通过消费者群组实现)和 broker（通过扩展实现系统伸缩性）可以轻松处理巨大的消息流。</li>
<li>消息持久化。基于磁盘的数据存储，消息不会丢失。</li>
</ul>
<p>通过 Partition 来实现多个生产者（同一个 topic 消息根据 key 放置到一个 Partition 中）和多个消费者（一个 Partition 由消费者群组中每一个消费者来负责）。</p>
<h3 id="1-2-系统结构和存储结构"><a href="#1-2-系统结构和存储结构" class="headerlink" title="1.2. 系统结构和存储结构"></a>1.2. 系统结构和存储结构</h3><h4 id="1-2-1-系统结构"><a href="#1-2-1-系统结构" class="headerlink" title="1.2.1. 系统结构"></a>1.2.1. 系统结构</h4><p>producer 采用 push 方式向 broker 发送消息；customer 采用 pull 方式从 broker 接受消息。</p>
<ul>
<li><strong>Producer</strong> - 消息生产者，负责发布消息到 Kafka Broker。</li>
<li><strong>Consumer</strong> - 消息消费者，从 Kafka Broker 读取消息的客户端。</li>
<li><strong>Consumer Group</strong> - 每个 Consumer 属于一个特定的 Consumer Group，若不指定 group name 则属于默认的 group。<strong>在同一个 Group 中，每一个 customer 可以消费多个 Partition，但是一个 Partition 只能指定给一个这个 Group 中一个 Customer</strong>。</li>
<li><strong>Broker</strong> - Kafka 集群包含一个或多个服务器，这种服务器被称为 broker</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka系统结构.png"><br></div>

<h4 id="1-2-2-Topic-的存储结构"><a href="#1-2-2-Topic-的存储结构" class="headerlink" title="1.2.2. Topic 的存储结构"></a>1.2.2. Topic 的存储结构</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/topic存储结构.png"><br></div>

<ul>
<li><strong>Topic</strong> - 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。</li>
<li><strong>Partition</strong> - Partition 是物理上的概念，每个 Topic 包含一个或多个 Partition。为了使得 Kafka 的吞吐率可以线性提高，物理上把 Topic 分成一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。</li>
<li><strong>Segment</strong> - 是 Partition 目录下的文件，保存存储消息。</li>
<li><strong>索引</strong> - 方便查询 segment</li>
</ul>
<h4 id="1-2-3-Segment-文件格式"><a href="#1-2-3-Segment-文件格式" class="headerlink" title="1.2.3. Segment 文件格式"></a>1.2.3. Segment 文件格式</h4><p>可以把 topic 当做一个数据表，表中每一个记录都是 key,value 形式，如下图。</p>
<p>注意： 必须要有一个 key，如果没有，则默认会生成一个 key，可以把 key 当做一个消息的标识，同一个 key 可能有多条数据。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-segment结构.png"><br></div>

<h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3. 小结"></a>1.3. 小结</h3><p><strong>（1）一个主题存在多个分区，每一分区属于哪个 leader broker?</strong></p>
<p>在任意一个 broker 机器都有每一个分区所属 leader 的信息，所以可以通过访问任意一个 broker 获取这些信息。</p>
<p><strong>（2）每个消费者群组对应的分区偏移量的元数据存储在哪里。</strong></p>
<p>最新版本保存在 kafka 中，对应的主题是_consumer_offsets。老版本是在 zookeeper 中。</p>
<p><strong>（3）假设某一个消息处理业务逻辑失败了。是否还可以继续向下执行？如果可以的话，那么此时怎么保证这个消息还会继续被处理呢？</strong></p>
<p>答案是：正常情况下无法再处理有问题的消息。</p>
<p>这里举一个例子，如 M1-&gt;M2-&gt;M3-&gt;M4，假设第一次 poll 时，得到 M1 和 M2，M1 处理成功，M2 处理失败，我们采用提交方式为处理一个消息就提交一次，此时我们提交偏移量是 offset1，但是当我们第二次执行 poll 时，此时只会获取到 M3 和 M4，因为 poll 的时候是根据本地偏移量来获取的，不是 kafka 中保存的初始偏移量。解决这个问题方法是通过 seek 操作定位到 M2 的位置，此时再执行 poll 时就会获取到 M2 和 M3。</p>
<p><strong>（4）当一个消费者执行了 close 之后，此时会执行再均衡，那么再均衡是在哪里发生的呢？其他同组的消费者如何感知到？</strong></p>
<p>是通过群组中成为群主的消费者执行再均衡，执行完毕之后,通过群组协调器把每一个消费者负责分区信息发送给消费者，每一个消费者只能知道它负责的分区信息。</p>
<p><strong>（5）如何保证时序性</strong></p>
<p>因为 kafkaf 只保证一个分区内的消息才有时序性，所以只要消息属于同一个 topic 且在同一个分区内，就可以保证 kafka 消费消息是有顺序的了。</p>
<h2 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2. 安装部署"></a>2. 安装部署</h2><p>环境要求：JDK8、ZooKeeper</p>
<h3 id="2-1-下载解压"><a href="#2-1-下载解压" class="headerlink" title="2.1. 下载解压"></a>2.1. 下载解压</h3><p>进入官方下载地址：<a href="http://kafka.apache.org/downloads，选择合适版本。" target="_blank" rel="noopener">http://kafka.apache.org/downloads，选择合适版本。</a></p>
<p>解压到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tar -xzf kafka_2.11-1.1.0.tgz</span><br><span class="line">&gt; cd kafka_2.11-1.1.0</span><br></pre></td></tr></table></figure>
<p>现在您已经在您的机器上下载了最新版本的 Kafka。</p>
<h3 id="2-2-启动服务器"><a href="#2-2-启动服务器" class="headerlink" title="2.2. 启动服务器"></a>2.2. 启动服务器</h3><p>由于 Kafka 依赖于 ZooKeeper，所以运行前需要先启动 ZooKeeper</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line">[2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后，启动 Kafka</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-server-start.sh config/server.properties</span><br><span class="line">[2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)</span><br><span class="line">[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="2-3-停止服务器"><a href="#2-3-停止服务器" class="headerlink" title="2.3. 停止服务器"></a>2.3. 停止服务器</h3><p>执行所有操作后，可以使用以下命令停止服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-server-stop.sh config/server.properties</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建主题"><a href="#2-4-创建主题" class="headerlink" title="2.4. 创建主题"></a>2.4. 创建主题</h3><p>创建一个名为 test 的 Topic，这个 Topic 只有一个分区以及一个备份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure>
<h3 id="2-5-生产者生产消息"><a href="#2-5-生产者生产消息" class="headerlink" title="2.5. 生产者生产消息"></a>2.5. 生产者生产消息</h3><p>运行生产者，然后可以在控制台中输入一些消息，这些消息会发送到服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure>
<h3 id="2-6-消费者消费消息"><a href="#2-6-消费者消费消息" class="headerlink" title="2.6. 消费者消费消息"></a>2.6. 消费者消费消息</h3><p>启动消费者，然后获得服务器中 Topic 下的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure>
<h3 id="2-7-集群部署"><a href="#2-7-集群部署" class="headerlink" title="2.7. 集群部署"></a>2.7. 集群部署</h3><p>复制配置为多份（Windows 使用 copy 命令代理）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cp config/server.properties config/server-1.properties</span><br><span class="line">&gt; cp config/server.properties config/server-2.properties</span><br></pre></td></tr></table></figure>
<p>修改配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config/server-1.properties:</span><br><span class="line">    broker.id=1</span><br><span class="line">    listeners=PLAINTEXT://:9093</span><br><span class="line">    log.dir=/tmp/kafka-logs-1</span><br><span class="line"></span><br><span class="line">config/server-2.properties:</span><br><span class="line">    broker.id=2</span><br><span class="line">    listeners=PLAINTEXT://:9094</span><br><span class="line">    log.dir=/tmp/kafka-logs-2</span><br></pre></td></tr></table></figure>
<p>其中，broker.id 这个参数必须是唯一的。</p>
<p>端口故意配置的不一致，是为了可以在一台机器启动多个应用节点。</p>
<p>根据这两份配置启动三个服务器节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line">...</span><br><span class="line">&gt; bin/kafka-server-start.sh config/server-1.properties &amp;</span><br><span class="line">...</span><br><span class="line">&gt; bin/kafka-server-start.sh config/server-2.properties &amp;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>创建一个新的 Topic 使用 三个备份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<p>查看主题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topic   PartitionCount:1    ReplicationFactor:3 Configs:</span><br><span class="line">    Topic: my-replicated-topic  Partition: 0    Leader: 1   Replicas: 1,2,0 Isr: 1,2,0</span><br></pre></td></tr></table></figure>
<ul>
<li>leader - 负责指定分区的所有读取和写入的节点。每个节点将成为随机选择的分区部分的领导者。</li>
<li>replicas - 是复制此分区日志的节点列表，无论它们是否为领导者，或者即使它们当前处于活动状态。</li>
<li>isr - 是“同步”复制品的集合。这是副本列表的子集，该列表当前处于活跃状态并且已经被领导者捕获。</li>
</ul>
<h2 id="3-API"><a href="#3-API" class="headerlink" title="3. API"></a>3. API</h2><p>Stream API 的 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其他 API 的 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-生产者（Producer）"><a href="#4-生产者（Producer）" class="headerlink" title="4. 生产者（Producer）"></a>4. 生产者（Producer）</h2><h3 id="4-1-发送消息流程"><a href="#4-1-发送消息流程" class="headerlink" title="4.1. 发送消息流程"></a>4.1. 发送消息流程</h3><p>发送消息流程如下图，需要注意的有：</p>
<ul>
<li>分区器 Partitioner，分区器决定了一个消息被分配到哪个分区。在我们创建消息时，我们可以选择性指定一个键值 key 或者分区 Partition，如果传入的是 key，则通过图中的分区器 Partitioner 选择一个分区来保存这个消息；如果 key 和 Partition 都没有指定，则会默认生成一个 key。</li>
<li>批次传输。<strong>批次，就是一组消息，这些消息属于同一个主题和分区</strong>。发送时，会把消息分成批次 Batch 传输，如果每一个消息发送一次，会导致大量的网路开销，</li>
<li>如果消息成功写入 kafka，就返回一个 RecoredMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。</li>
<li>如果消息发送失败，可以进行重试，重试次数可以在配置中指定。</li>
</ul>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-3cfae88715795068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>生产者在向 broker 发送消息时是怎么确定向哪一个 broker 发送消息？</p>
<ul>
<li>生产者客户端会向任一个 broker 发送一个元数据请求（MetadataRequest），获取到每一个分区对应的 leader 信息，并缓存到本地。</li>
<li>step2:生产者在发送消息时，会指定 Partition 或者通过 key 得到到一个 Partition，然后根据 Partition 从缓存中获取相应的 leader 信息。</li>
</ul>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-3d7aab3ba2ba13f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h3 id="4-2-发送消息方式"><a href="#4-2-发送消息方式" class="headerlink" title="4.2. 发送消息方式"></a>4.2. 发送消息方式</h3><h4 id="4-2-1-发送并忘记（fire-and-forget）"><a href="#4-2-1-发送并忘记（fire-and-forget）" class="headerlink" title="4.2.1. 发送并忘记（fire-and-forget）"></a>4.2.1. 发送并忘记（fire-and-forget）</h4><p>代码如下，直接通过 send 方法来发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.send(record);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-同步发送"><a href="#4-2-2-同步发送" class="headerlink" title="4.2.2. 同步发送"></a>4.2.2. 同步发送</h4><p>代码如下，与“发送并忘记”的方式区别在于多了一个 get()方法，会一直阻塞等待 broker 返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.send(record).get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-异步发送"><a href="#4-2-3-异步发送" class="headerlink" title="4.2.3. 异步发送"></a>4.2.3. 异步发送</h4><p>代码如下，异步方式相对于“发送并忘记”的方式的不同在于，在异步返回时可以执行一些操作，如记录错误或者成功日志。</p>
<p>首先，定义一个 callback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProducerCallback</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，使用这个 callback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Biomedical Materials"</span>, <span class="string">"USA"</span>);</span><br><span class="line">producer.send(record, <span class="keyword">new</span> DemoProducerCallback());</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-发送消息示例"><a href="#4-2-4-发送消息示例" class="headerlink" title="4.2.4. 发送消息示例"></a>4.2.4. 发送消息示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kafka 生产者生产消息示例 生产者配置参考：https://kafka.apache.org/documentation/#producerconfigs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"localhost:9092"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 指定生产者的配置</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, HOST);</span><br><span class="line">        properties.put(ProducerConfig.ACKS_CONFIG, <span class="string">"all"</span>);</span><br><span class="line">        properties.put(ProducerConfig.RETRIES_CONFIG, <span class="number">0</span>);</span><br><span class="line">        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line">        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">1</span>);</span><br><span class="line">        properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br><span class="line">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用配置初始化 Kafka 生产者</span></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 使用 send 方法发送异步消息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                String msg = <span class="string">"Message "</span> + i;</span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"HelloWorld"</span>, msg));</span><br><span class="line">                System.out.println(<span class="string">"Sent:"</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 关闭生产者</span></span><br><span class="line">            producer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-消费者（Consumer）"><a href="#5-消费者（Consumer）" class="headerlink" title="5. 消费者（Consumer）"></a>5. 消费者（Consumer）</h2><h3 id="5-1-消费者和消费者群组"><a href="#5-1-消费者和消费者群组" class="headerlink" title="5.1. 消费者和消费者群组"></a>5.1. 消费者和消费者群组</h3><h4 id="5-1-1-消费者介绍"><a href="#5-1-1-消费者介绍" class="headerlink" title="5.1.1. 消费者介绍"></a>5.1.1. 消费者介绍</h4><p>消费者以<strong>pull 方式</strong>从 broker 拉取消息，消费者可以订阅一个或多个主题，然后按照消息生成顺序（<strong>kafka 只能保证分区中消息的顺序</strong>）读取消息。</p>
<p><strong>一个消息消息只有在所有跟随者节点都进行了同步，才会被消费者获取到</strong>。如下图，只能消费 Message0、Message1、Message2：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-360a63cf628c7b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h4 id="5-1-2-消费者分区组"><a href="#5-1-2-消费者分区组" class="headerlink" title="5.1.2. 消费者分区组"></a>5.1.2. 消费者分区组</h4><p>消费者群组可以实现并发的处理消息。一个消费者群组作为消费一个 topic 消息的单元，每一个 Partition 只能隶属于一个消费者群组中一个 customer，如下图</p>
<div align="center"><br><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/6-1-259x300.png"><br></div>

<h4 id="5-1-3-消费者区组的再均衡"><a href="#5-1-3-消费者区组的再均衡" class="headerlink" title="5.1.3. 消费者区组的再均衡"></a>5.1.3. 消费者区组的再均衡</h4><p>当在群组里面 新增/移除消费者 或者 新增/移除 kafka 集群 broker 节点 时，群组协调器 Broker 会触发再均衡，重新为每一个 Partition 分配消费者。<strong>再均衡期间，消费者无法读取消息，造成整个消费者群组一小段时间的不可用。</strong></p>
<ul>
<li>新增消费者。customer 订阅主题之后，第一次执行 poll 方法</li>
<li>移除消费者。执行 customer.close()操作或者消费客户端宕机，就不再通过 poll 向群组协调器发送心跳了，当群组协调器检测次消费者没有心跳，就会触发再均衡。</li>
<li>新增 broker。如重启 broker 节点</li>
<li>移除 broker。如 kill 掉 broker 节点。</li>
</ul>
<p><strong>再均衡是是通过消费者群组中的称为“群主”消费者客户端进行的</strong>。什么是群主呢？“群主”就是第一个加入群组的消费者。消费者第一次加入群组时，它会向群组协调器发送一个 JoinGroup 的请求，如果是第一个，则此消费者被指定为“群主”（群主是不是和 qq 群很想啊，就是那个第一个进群的人）。</p>
<p>群主分配分区的过程如下：</p>
<ol>
<li>群主从群组协调器获取群组成员列表，然后给每一个消费者进行分配分区 Partition。</li>
<li>两个分配策略：Range 和 RoundRobin。<ul>
<li>Range 策略，就是把若干个连续的分区分配给消费者，如存在分区 1-5，假设有 3 个消费者，则消费者 1 负责分区 1-2,消费者 2 负责分区 3-4，消费者 3 负责分区 5。</li>
<li>RoundRoin 策略，就是把所有分区逐个分给消费者，如存在分区 1-5，假设有 3 个消费者，则分区 1-&gt;消费 1，分区 2-&gt;消费者 2，分区 3&gt;消费者 3，分区 4&gt;消费者 1，分区 5-&gt;消费者 2。</li>
</ul>
</li>
<li>群主分配完成之后，把分配情况发送给群组协调器。</li>
<li>群组协调器再把这些信息发送给消费者。<strong>每一个消费者只能看到自己的分配信息，只有群主知道所有消费者的分配信息</strong>。</li>
</ol>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-fd4ab296c5dbeb24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h3 id="5-2-消费消息流程"><a href="#5-2-消费消息流程" class="headerlink" title="5.2. 消费消息流程"></a>5.2. 消费消息流程</h3><h4 id="5-2-1-消费流程-demo"><a href="#5-2-1-消费流程-demo" class="headerlink" title="5.2.1. 消费流程 demo"></a>5.2.1. 消费流程 demo</h4><p>具体步骤如下</p>
<ul>
<li>step1 创建消费者。</li>
<li>step2 订阅主题。除了订阅主题方式外还有使用指定分组的模式，但是常用方式都是订阅主题方式</li>
<li>stpe3 轮询消息。通过 poll 方法轮询。</li>
<li>stpe4 关闭消费者。在不用消费者之后，会执行 close 操作。close 操作会关闭 socket，并触发当前消费者群组的再均衡。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构建KafkaCustomer</span></span><br><span class="line">Consumer consumer = buildCustomer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置主题</span></span><br><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.接受消息</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">"customer Message---"</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print the offset,key and value for the consumer records.</span></span><br><span class="line">            System.out.printf(<span class="string">"offset = %d, key = %s, value = %s\n"</span>,</span><br><span class="line">                    record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.关闭消息</span></span><br><span class="line">        consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建消费者的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Consumer <span class="title">buildCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// bootstrap.servers是Kafka集群的IP地址。多个时,使用逗号隔开</span></span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    <span class="comment">// 消费者群组</span></span><br><span class="line">    props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line">    props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">    props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">    props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">    props.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    props.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer</span><br><span class="line">            &lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-消费消息方式"><a href="#5-2-2-消费消息方式" class="headerlink" title="5.2.2. 消费消息方式"></a>5.2.2. 消费消息方式</h4><p>分为订阅主题和指定分组两种方式：</p>
<ul>
<li>消费者分组模式。通过订阅主题方式时，消费者必须加入到消费者群组中，即消费者必须有一个自己的分组；</li>
<li>独立消费者模式。这种模式就是消费者是独立的不属于任何消费者分组，自己指定消费那些 Partition。</li>
</ul>
<p>1、订阅主题方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br></pre></td></tr></table></figure>
<p>2、独立消费者模式</p>
<p>通过 consumer 的 assign(Collection<topicpartition> partitions)方法来为消费者指定分区。</topicpartition></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessageForIndependentConsumer</span><span class="params">(String topic)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建KafkaCustomer</span></span><br><span class="line">    Consumer consumer = buildCustomer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.指定分区</span></span><br><span class="line">    <span class="comment">// 2.1获取可用分区</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitionInfoList = buildCustomer().partitionsFor(topic);</span><br><span class="line">    <span class="comment">// 2.2指定分区,这里是指定了所有分区,也可以指定个别的分区</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != partitionInfoList)&#123;</span><br><span class="line">        List&lt;TopicPartition&gt; partitions = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span>(PartitionInfo partitionInfo : partitionInfoList)&#123;</span><br><span class="line">            partitions.add(<span class="keyword">new</span> TopicPartition(partitionInfo.topic(),partitionInfo.partition()));</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.assign(partitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.接受消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">"consume Message---"</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print the offset,key and value for the consumer records.</span></span><br><span class="line">            System.out.printf(<span class="string">"offset = %d, key = %s, value = %s\n"</span>,</span><br><span class="line">                    record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步提交</span></span><br><span class="line">            consumer.commitAsync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3-轮询获取消息"><a href="#5-2-3-轮询获取消息" class="headerlink" title="5.2.3. 轮询获取消息"></a>5.2.3. 轮询获取消息</h4><p>通过 poll 来获取消息，但是获取消息时并不是立刻返回结果，需要考虑两个因素：</p>
<ul>
<li>消费者通过 customer.poll(time)中设置的等待时间</li>
<li>broker 会等待累计一定量数据，然后发送给消费者。这样可以减少网络开销。</li>
</ul>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-d7d111e7c7e7f504.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>poll 处了获取消息外，还有其他作用，如下：</p>
<ul>
<li>发送心跳信息。消费者通过向被指派为群组协调器的 broker 发送心跳来维护他和群组的从属关系，当机器宕掉后，群组协调器触发再分配</li>
</ul>
<h3 id="5-3-提交偏移量"><a href="#5-3-提交偏移量" class="headerlink" title="5.3. 提交偏移量"></a>5.3. 提交偏移量</h3><h4 id="5-3-1-偏移量和提交"><a href="#5-3-1-偏移量和提交" class="headerlink" title="5.3.1. 偏移量和提交"></a>5.3.1. 偏移量和提交</h4><p>（1）偏移量</p>
<p>偏移量 offeset，是指一个消息在分区中位置。在通过生产者向 kafka 推送消息返回的结果中包含了这个偏移量值，或者在消费者拉取信息时，也会包含消息的偏移量信息。</p>
<p>（2）提交的解释</p>
<p>我们把消息的偏移量提交到 kafka 的操作叫做<strong>提交或提交偏移量。</strong></p>
<p>（3）偏移量的应用</p>
<p>目前会有两个位置记录这个偏移量：</p>
<p>a. Kafka Broker 保存。消费者通过提交操作，把读取分区中最新消息的偏移量更新到 kafka 服务器端（老版本的 kafka 是保存在 zookeeper 中），即消费者往一个叫做_consumer_offset 的特殊主题发送消息，消息里面包消息的偏移量信息,<strong>并且该主题配置清理策略是 compact，即对于每一个 key 只保存最新的值（key 由 groupId、topic 和 partition 组成）</strong>。关于提交操作在本节进行讨论。</p>
<p>如果消费者一直处于运行状态，这个偏移量是没有起到作用，只有当加入或者删除一个群组里消费者，然后进行再均衡操作只有，此时为了可以继续之前工作，新的消费者需要知道上一个消费者处理这个分区的位置信息。</p>
<p>b. 消费者客户端保存。消费者客户端会保存 poll()每一次执行后的最后一个消息的偏移量，这样每次执行轮询操作 poll 时，都从这个位置获取信息。这个信息修改可以通过后续小节中三个 seek 方法来修改。</p>
<p>（4）提交时会遇到两个问题</p>
<p>a. 重复处理</p>
<p>当提交的偏移量小于客户端处理的最后一个消息的偏移量时，会出现重复处理消息的问题，如下图</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-75abe308f9cf21f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>b. 消息丢失</p>
<p>当提交的偏移量大于客户端处理的最后端最后一个消息的偏移量，会出现消息丢失的问题，如下图：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-68b1e5fdc020d0f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>（5）提交方式</p>
<p>主要分为：自动提交和手动提交。</p>
<p>a. 自动提交</p>
<p>auto.commit.commit ,默认为 true 自动提交，自动提交时通过轮询方式来做，时间间通过 auto.commit.interval.ms 属性来进行设置。</p>
<p>b. 手动提交</p>
<p>除了自动提交，还可以进行手动提交，手动提交就是通过代码调用函数的方式提交，在使用手动提交时首先需要将 auto.commit.commit 设置为 false，目前有三种方式：同步提交、异步提交、同步和异步结合。</p>
<h4 id="5-3-2-同步提交"><a href="#5-3-2-同步提交" class="headerlink" title="5.3.2. 同步提交"></a>5.3.2. 同步提交</h4><p>可以通过 commitSync 来进行提交，<strong>同步提交会一直提交直到成功</strong>。如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customerMessageWithSyncCommit</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建KafkaCustomer</span></span><br><span class="line">    Consumer consumer = buildCustomer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置主题</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.接受消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">"customer Message---"</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print the offset,key and value for the consumer records.</span></span><br><span class="line">            System.out.printf(<span class="string">"offset = %d, key = %s, value = %s\n"</span>,</span><br><span class="line">                    record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步提交</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                consumer.commitSync();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"commit error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-异步提交"><a href="#5-3-3-异步提交" class="headerlink" title="5.3.3. 异步提交"></a>5.3.3. 异步提交</h4><p>同步提交一个缺点是，在进行提交 commitAysnc()会阻塞整个下面流程。所以引入了异步提交 commitAsync()，如下代码，这里定义了 OffsetCommitCallback，也可以只进行 commitAsync()，不设置任何参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customerMessageWithAsyncCommit</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建KafkaCustomer</span></span><br><span class="line">    Consumer consumer = buildCustomer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置主题</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.接受消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">"customer Message---"</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print the offset,key and value for the consumer records.</span></span><br><span class="line">            System.out.printf(<span class="string">"offset = %d, key = %s, value = %s\n"</span>,</span><br><span class="line">                    record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步提交</span></span><br><span class="line">            consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception e)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Commit failed for offsets&#123;&#125;"</span>, offsets, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-4-同步和异步提交"><a href="#5-3-4-同步和异步提交" class="headerlink" title="5.3.4. 同步和异步提交"></a>5.3.4. 同步和异步提交</h4><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customerMessageWithSyncAndAsyncCommit</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建KafkaCustomer</span></span><br><span class="line">    Consumer consumer = buildCustomer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置主题</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.接受消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">            System.out.println(<span class="string">"customer Message---"</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// print the offset,key and value for the consumer records.</span></span><br><span class="line">                System.out.printf(<span class="string">"offset = %d, key = %s, value = %s\n"</span>,</span><br><span class="line">                        record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异步提交</span></span><br><span class="line">                consumer.commitAsync();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 同步提交</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.commitSync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-从指定偏移量获取数据"><a href="#5-4-从指定偏移量获取数据" class="headerlink" title="5.4. 从指定偏移量获取数据"></a>5.4. 从指定偏移量获取数据</h3><p>我们读取消息是通过 poll 方法。它根据消费者客户端本地保存的当前偏移量来获取消息。如果我们需要从指定偏移量位置获取数据，此时就需要修改这个值为我们想要读取消息开始的地方，目前有如下三个方法：</p>
<ul>
<li>seekToBeginning(Collection<topicpartition> partitions)。可以修改分区当前偏移量为分区的起始位置、</topicpartition></li>
<li>seekToEnd(Collection<topicpartition> partitions)。可以修改分区当前偏移量为分区的末尾位置</topicpartition></li>
<li>seek(TopicPartition partition, long offset); 可以修改分区当前偏移量为分区的起始位置</li>
</ul>
<p>通过 seek(TopicPartition partition, long offset)可以实现处理消息和提交偏移量在一个事务中完成。思路就是需要在可短建立一个数据表，保证处理消息和和消息偏移量位置写入到这个数据表在一个事务中，此时就可以保证处理消息和记录偏移量要么同时成功，要么同时失败。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(topic);</span><br><span class="line"><span class="comment">// 1.第一次调用pool,加入消费者群组</span></span><br><span class="line">consumer.poll(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.获取负责的分区，并从本地数据库读取改分区最新偏移量，并通过seek方法修改poll获取消息的位置</span></span><br><span class="line"><span class="keyword">for</span> (TopicPartition partition: consumer.assignment())</span><br><span class="line">    consumer.seek(partition, getOffsetFromDB(partition));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">    consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">    &#123;</span><br><span class="line">        processRecord(record);</span><br><span class="line">        storeRecordInDB(record);</span><br><span class="line">        storeOffsetInDB(record.topic(), record.partition(),</span><br><span class="line">        record.offset());</span><br><span class="line">    &#125;</span><br><span class="line">    commitDBTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Broker"><a href="#6-Broker" class="headerlink" title="6. Broker"></a>6. Broker</h2><h3 id="6-1-集群控制器"><a href="#6-1-集群控制器" class="headerlink" title="6.1. 集群控制器"></a>6.1. 集群控制器</h3><p>控制器除了具有一般 broker 的功能，还负责分区 leader 的选举。</p>
<h3 id="6-2-分区-leader-和-follower"><a href="#6-2-分区-leader-和-follower" class="headerlink" title="6.2. 分区 leader 和 follower"></a>6.2. 分区 leader 和 follower</h3><p>Kafka 在 0.8 以前的版本中，如果一个 broker 机器宕机了，其上面的 Partition 都不能用了。为了实现 High Availablity，引入了复制功能，即一个 Partition 还会在其他的 broker 上面进行备份。为了实现复制功能，引入了分区 leader 和 follower：</p>
<p>（1）Leader 作用</p>
<p>生产者和消费者请求都会经过这个 leader。Producer 和 Concumer 往一个 Partition 写入和读取消息时，都会首先查找这个 Partition 的 leader</p>
<p>保存那些 follower 节点的状态与自己是一致的。</p>
<p>（2）follower 作用：</p>
<p>定时通过类似消费者的 poll 方法从 leader 中获取消息，进行备份</p>
<p>同一个 topic 的不同 Partition 会分布在多个 broker 上，而且一个 Partition 还会在其他的 broker 上面进行备份，Producer 在发布消息到某个 Partition 时，先找到该 Partition 的 Leader，然后向这个 leader 推送消息；每个 Follower 都从 Leader 拉取消息，拉取消息成功之后，向 leader 发送一个 ack 确认。如下一个流程图：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-371ef1888b65edc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h3 id="6-3-群组协调器"><a href="#6-3-群组协调器" class="headerlink" title="6.3. 群组协调器"></a>6.3. 群组协调器</h3><p>群组协调器，顾名思义就是维护消费者群组 ，消费者通过向被指派为群组协调器的 broker（不同的群组可以有不同的协调器）发送心跳来维护它们和群组的从属关系，以及它们对分区的所有权。</p>
<p>1、触发再均衡</p>
<p>只要消费者以正常的时间间隔发送心跳，就会被认为是活跃的。消费者是通过 poll 获取消息时，发送的心跳的，当消费者客户端宕机之后，群组协调器在一段内没有收到心跳，则此时会认为消费者已死亡，然后触发一次再均衡。具体再均衡流程，可以参考上面的“再均衡”小节。</p>
<h2 id="7-Zookeeper-集群"><a href="#7-Zookeeper-集群" class="headerlink" title="7. Zookeeper 集群"></a>7. Zookeeper 集群</h2><h3 id="7-1-节点信息"><a href="#7-1-节点信息" class="headerlink" title="7.1. 节点信息"></a>7.1. 节点信息</h3><p>参考：<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+data+structures+in+Zookeeper" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/KAFKA/Kafka+data+structures+in+Zookeeper</a></p>
<p>Zookeeper 保存的就是节点信息和节点状态，不会保存 kafka 的消息信息，节点信息包括：</p>
<ul>
<li>broker。broer 启动时在 zookeeper 注册、并通过 watcher 监听 broker 节点变化；并且还记录 topic 和 Partition 的信息。</li>
<li>consumers,消费者节点信息</li>
<li>admin</li>
<li>config</li>
<li>controller 和 controloer_epoch</li>
</ul>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3101171-8074b42933b41d33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h4 id="7-1-1-broker"><a href="#7-1-1-broker" class="headerlink" title="7.1.1. broker"></a>7.1.1. broker</h4><p>（1）Topic 的注册信息</p>
<p>作用：在创建 zookeeper 时，注册 topic 的 Partition 信息，包括每一个分区的复制节点 id。</p>
<p>路径：/brokers/topics/[topic]</p>
<p>数据格式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123; <span class="attr">"fields"</span> :</span><br><span class="line">    [ &#123;<span class="attr">"name"</span>: <span class="string">"version"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"version id"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"partitions"</span>,</span><br><span class="line">       <span class="attr">"type"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"map"</span>,</span><br><span class="line">                <span class="attr">"values"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"array"</span>, <span class="attr">"items"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"a list of replica ids"</span>&#125;,</span><br><span class="line">                <span class="attr">"doc"</span>: <span class="string">"a map from partition id to replica list"</span>&#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  "partitions": &#123;"0": [0, 1, 3] &#125; &#125;   # 分区0的对应的复制节点是0、1、3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）分区信息</p>
<p>作用：记录分区信息，如分区的 leader 信息</p>
<p>路径信息：/brokers/topics/[topic]/partitions/[partitionId]/state</p>
<p>格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123; <span class="attr">"fields"</span>:</span><br><span class="line">    [ &#123;<span class="attr">"name"</span>: <span class="string">"version"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"version id"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"isr"</span>,</span><br><span class="line">       <span class="attr">"type"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"array"</span>,</span><br><span class="line">                <span class="attr">"items"</span>: <span class="string">"int"</span>,</span><br><span class="line">                <span class="attr">"doc"</span>: <span class="string">"an array of the id of replicas in isr"</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"leader"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"id of the leader replica"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"controller_epoch"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"epoch of the controller that last updated the leader and isr info"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"leader_epoch"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"epoch of the leader"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"isr"</span>: [<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  <span class="attr">"leader"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"controller_epoch"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"leader_epoch"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）broker 信息</p>
<p>作用：在 borker 启动时，向 zookeeper 注册节点信息</p>
<p>路径：/brokers/ids/[brokerId]</p>
<p>数据格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123; <span class="attr">"fields"</span>:</span><br><span class="line">    [ &#123;<span class="attr">"name"</span>: <span class="string">"version"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"version id"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"host"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"doc"</span>: <span class="string">"ip address or host name of the broker"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"port"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"port of the broker"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"jmx_port"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"port for jmx"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"host"</span>: <span class="string">"192.168.1.148"</span>,</span><br><span class="line">  <span class="attr">"port"</span>: <span class="number">9092</span>,</span><br><span class="line">  <span class="attr">"jmx_port"</span>: <span class="number">9999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-2-controller-和-controller-epoch"><a href="#7-1-2-controller-和-controller-epoch" class="headerlink" title="7.1.2. controller 和 controller_epoch"></a>7.1.2. controller 和 controller_epoch</h4><p>（1）控制器的 epoch:</p>
<p>/controller_epoch -&gt; int (epoch)</p>
<p>（2）控制器的注册信息:</p>
<p>/controller -&gt; int (broker id of the controller)</p>
<h4 id="7-1-3-consumer"><a href="#7-1-3-consumer" class="headerlink" title="7.1.3. consumer"></a>7.1.3. consumer</h4><p>（1）消费者注册信息:</p>
<p>路径：/consumers/[groupId]/ids/[consumerId]</p>
<p>数据格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123; <span class="attr">"fields"</span>:</span><br><span class="line">    [ &#123;<span class="attr">"name"</span>: <span class="string">"version"</span>, <span class="attr">"type"</span>: <span class="string">"int"</span>, <span class="attr">"doc"</span>: <span class="string">"version id"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"pattern"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"doc"</span>: <span class="string">"can be of static, white_list or black_list"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">"name"</span>: <span class="string">"subscription"</span>, <span class="attr">"type"</span> : &#123;<span class="attr">"type"</span>: <span class="string">"map"</span>, <span class="attr">"values"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"int"</span>&#125;,</span><br><span class="line">                                         <span class="attr">"doc"</span>: <span class="string">"a map from a topic or a wildcard pattern to the number of streams"</span>&#125;      &#125;    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">A static subscription:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"pattern"</span>: <span class="string">"static"</span>,</span><br><span class="line">  <span class="attr">"subscription"</span>: &#123;<span class="attr">"topic1"</span>: <span class="number">1</span>, <span class="attr">"topic2"</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A whitelist subscription:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"pattern"</span>: <span class="string">"white_list"</span>,</span><br><span class="line">  <span class="attr">"subscription"</span>: &#123;<span class="attr">"abc"</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A blacklist subscription:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"pattern"</span>: <span class="string">"black_list"</span>,</span><br><span class="line">  <span class="attr">"subscription"</span>: &#123;<span class="attr">"abc"</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-4-admin"><a href="#7-1-4-admin" class="headerlink" title="7.1.4. admin"></a>7.1.4. admin</h4><p>（1）Re-assign partitions</p>
<p>路径：/admin/reassign_partitions</p>
<p>数据格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"fields"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"name"</span>:<span class="string">"version"</span>,</span><br><span class="line">         <span class="attr">"type"</span>:<span class="string">"int"</span>,</span><br><span class="line">         <span class="attr">"doc"</span>:<span class="string">"version id"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"name"</span>:<span class="string">"partitions"</span>,</span><br><span class="line">         <span class="attr">"type"</span>:&#123;</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"array"</span>,</span><br><span class="line">            <span class="attr">"items"</span>:&#123;</span><br><span class="line">               <span class="attr">"fields"</span>:[</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="attr">"name"</span>:<span class="string">"topic"</span>,</span><br><span class="line">                     <span class="attr">"type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                     <span class="attr">"doc"</span>:<span class="string">"topic of the partition to be reassigned"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="attr">"name"</span>:<span class="string">"partition"</span>,</span><br><span class="line">                     <span class="attr">"type"</span>:<span class="string">"int"</span>,</span><br><span class="line">                     <span class="attr">"doc"</span>:<span class="string">"the partition to be reassigned"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="attr">"name"</span>:<span class="string">"replicas"</span>,</span><br><span class="line">                     <span class="attr">"type"</span>:<span class="string">"array"</span>,</span><br><span class="line">                     <span class="attr">"items"</span>:<span class="string">"int"</span>,</span><br><span class="line">                     <span class="attr">"doc"</span>:<span class="string">"a list of replica ids"</span></span><br><span class="line">                  &#125;</span><br><span class="line">               ],</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">"doc"</span>:<span class="string">"an array of partitions to be reassigned to new replicas"</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"partitions"</span>:</span><br><span class="line">     [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"Foo"</span>,</span><br><span class="line">            <span class="attr">"partition"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"replicas"</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）Preferred replication election</p>
<p>路径：/admin/preferred_replica_election</p>
<p>数据格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"fields"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"name"</span>:<span class="string">"version"</span>,</span><br><span class="line">         <span class="attr">"type"</span>:<span class="string">"int"</span>,</span><br><span class="line">         <span class="attr">"doc"</span>:<span class="string">"version id"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"name"</span>:<span class="string">"partitions"</span>,</span><br><span class="line">         <span class="attr">"type"</span>:&#123;</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"array"</span>,</span><br><span class="line">            <span class="attr">"items"</span>:&#123;</span><br><span class="line">               <span class="attr">"fields"</span>:[</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="attr">"name"</span>:<span class="string">"topic"</span>,</span><br><span class="line">                     <span class="attr">"type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                     <span class="attr">"doc"</span>:<span class="string">"topic of the partition for which preferred replica election should be triggered"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="attr">"name"</span>:<span class="string">"partition"</span>,</span><br><span class="line">                     <span class="attr">"type"</span>:<span class="string">"int"</span>,</span><br><span class="line">                     <span class="attr">"doc"</span>:<span class="string">"the partition for which preferred replica election should be triggered"</span></span><br><span class="line">                  &#125;</span><br><span class="line">               ],</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">"doc"</span>:<span class="string">"an array of partitions for which preferred replica election should be triggered"</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"partitions"</span>:</span><br><span class="line">     [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"Foo"</span>,</span><br><span class="line">            <span class="attr">"partition"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"Bar"</span>,</span><br><span class="line">            <span class="attr">"partition"</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）Delete topics</p>
<p>/admin/delete_topics/[topic_to_be_deleted] (the value of the path in empty)</p>
<h4 id="7-1-5-config"><a href="#7-1-5-config" class="headerlink" title="7.1.5. config"></a>7.1.5. config</h4><p>Topic Configuration</p>
<p>/config/topics/[topic_name]</p>
<p>数据格式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"config.a"</span>: <span class="string">"x"</span>,</span><br><span class="line">    <span class="attr">"config.b"</span>: <span class="string">"y"</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-zookeeper-一些总结"><a href="#7-2-zookeeper-一些总结" class="headerlink" title="7.2. zookeeper 一些总结"></a>7.2. zookeeper 一些总结</h3><p>离开了 Zookeeper, Kafka 不能对 Topic 进行新增操作, 但是仍然可以 produce 和 consume 消息.</p>
<h2 id="8-资料"><a href="#8-资料" class="headerlink" title="8. 资料"></a>8. 资料</h2><ul>
<li><a href="http://www.heartthinkdo.com/?p=2006#233" target="_blank" rel="noopener">Kafka(03) Kafka 介绍</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/07/10/programming/java/javaweb/distributed/rpc/zookeeper-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/10/programming/java/javaweb/distributed/rpc/zookeeper-advanced/" itemprop="url">ZooKeeper 高级篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T00:00:00+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ZooKeeper-高级篇"><a href="#ZooKeeper-高级篇" class="headerlink" title="ZooKeeper 高级篇"></a>ZooKeeper 高级篇</h1><blockquote>
<p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p>
<p>本文侧重于总结 ZooKeeper 工作原理。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-概述">1. 概述</a><ul>
<li><a href="#11-zookeeper-是什么">1.1. ZooKeeper 是什么？</a></li>
<li><a href="#12-zookeeper-提供了什么">1.2. ZooKeeper 提供了什么？</a></li>
<li><a href="#13-zookeeper-的特性">1.3. Zookeeper 的特性</a></li>
<li><a href="#14-工作原理">1.4. 工作原理</a></li>
<li><a href="#15-server-工作状态">1.5. Server 工作状态</a></li>
</ul>
</li>
<li><a href="#2-文件系统">2. 文件系统</a><ul>
<li><a href="#21-znode-类型">2.1. znode 类型</a></li>
</ul>
</li>
<li><a href="#3-通知机制">3. 通知机制</a></li>
<li><a href="#4-应用场景">4. 应用场景</a><ul>
<li><a href="#41-统一命名服务name-service">4.1. 统一命名服务（Name Service）</a></li>
<li><a href="#42-配置管理configuration-management">4.2. 配置管理（Configuration Management）</a></li>
<li><a href="#43-集群管理group-membership">4.3. 集群管理（Group Membership）</a></li>
<li><a href="#44-分布式锁">4.4. 分布式锁</a></li>
<li><a href="#45-队列管理">4.5. 队列管理</a></li>
</ul>
</li>
<li><a href="#5-复制">5. 复制</a></li>
<li><a href="#6-选举流程">6. 选举流程</a></li>
<li><a href="#7-同步流程">7. 同步流程</a></li>
<li><a href="#8-资源">8. 资源</a><ul>
<li><a href="#81-官方资源">8.1. 官方资源</a></li>
<li><a href="#82-文章">8.2. 文章</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-ZooKeeper-是什么？"><a href="#1-1-ZooKeeper-是什么？" class="headerlink" title="1.1. ZooKeeper 是什么？"></a>1.1. ZooKeeper 是什么？</h3><p>ZooKeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储，但是 ZooKeeper 并不是用来专门存储数据的，它的作用主要是用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/zookeeper/zookeeper-service.png"><br></div>

<h3 id="1-2-ZooKeeper-提供了什么？"><a href="#1-2-ZooKeeper-提供了什么？" class="headerlink" title="1.2. ZooKeeper 提供了什么？"></a>1.2. ZooKeeper 提供了什么？</h3><ol>
<li>文件系统</li>
<li>通知机制</li>
</ol>
<h3 id="1-3-Zookeeper-的特性"><a href="#1-3-Zookeeper-的特性" class="headerlink" title="1.3. Zookeeper 的特性"></a>1.3. Zookeeper 的特性</h3><ul>
<li>最终一致性：client 不论连接到哪个 Server，展示给它都是同一个视图，这是 zookeeper 最重要的性能。</li>
<li>可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。</li>
<li>实时性：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper 不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用 sync()接口。</li>
<li>等待无关（wait-free）：慢的或者失效的 client 不得干预快速的 client 的请求，使得每个 client 都能有效的等待。</li>
<li>原子性：更新只能成功或者失败，没有中间状态。</li>
<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息 a 在消息 b 前发布，则在所有 Server 上消息 a 都将在消息 b 前被发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</li>
</ul>
<h3 id="1-4-工作原理"><a href="#1-4-工作原理" class="headerlink" title="1.4. 工作原理"></a>1.4. 工作原理</h3><p>ZooKeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p>
<p>为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 id 号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了 zxid。实现中 zxid 是一个 64 位的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数。</p>
<h3 id="1-5-Server-工作状态"><a href="#1-5-Server-工作状态" class="headerlink" title="1.5. Server 工作状态"></a>1.5. Server 工作状态</h3><p>每个 Server 在工作过程中有三种状态：</p>
<ul>
<li>LOOKING - 当前 Server 不知道 leader 是谁，正在搜寻</li>
<li>LEADING - 当前 Server 即为选举出来的 leader</li>
<li>FOLLOWING - leader 已经选举出来，当前 Server 与之同步</li>
</ul>
<h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h2><p>ZooKeeper 会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统，如下图所示：</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/zookeeper/Zookeeper数据结构.gif"><br></div>

<p>ZooKeeper 这种数据结构有如下这些特点：</p>
<ul>
<li>每个子目录项如 NameService 都被称作为 znode，这个 znode 是被它所在的路径唯一标识，如 Server1 这个 znode 的标识为 /NameService/Server1</li>
<li>znode 可以有子节点目录，并且每个 znode 可以存储数据，注意 EPHEMERAL 类型的目录节点不能有子节点目录</li>
<li>znode 是有版本的，每个 znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据</li>
<li>znode 可以是临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除，ZooKeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了</li>
<li>znode 的目录名可以自动编号，如 App1 已经存在，再创建的话，将会自动命名为 App2</li>
<li>znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 ZooKeeper 的核心特性，ZooKeeper 的很多功能都是基于这个特性实现的，后面在典型的应用场景中会有实例介绍</li>
</ul>
<h3 id="2-1-znode-类型"><a href="#2-1-znode-类型" class="headerlink" title="2.1. znode 类型"></a>2.1. znode 类型</h3><ol>
<li>PERSISTENT(持久化目录节点) - 客户端与 zookeeper 断开连接后，该节点依旧存在</li>
<li>PERSISTENT_SEQUENTIAL(持久化顺序编号目录节点) - 客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号</li>
<li>EPHEMERAL(临时目录节点) - 客户端与 zookeeper 断开连接后，该节点被删除</li>
<li>EPHEMERAL_SEQUENTIAL(临时顺序编号目录节点) - 客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号</li>
</ol>
<h2 id="3-通知机制"><a href="#3-通知机制" class="headerlink" title="3. 通知机制"></a>3. 通知机制</h2><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper 会通知客户端。</p>
<h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><h3 id="4-1-统一命名服务（Name-Service）"><a href="#4-1-统一命名服务（Name-Service）" class="headerlink" title="4.1. 统一命名服务（Name Service）"></a>4.1. 统一命名服务（Name Service）</h3><p>分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。说到这里你可能想到了 JNDI，没错 ZooKeeper 的 Name Service 与 JNDI 能够完成的功能是差不多的，它们都是将有层次的目录结构关联到一定资源上，但是 ZooKeeper 的 Name Service 更加是广泛意义上的关联，也许你并不需要将名称关联到特定资源上，你可能只需要一个不会重复名称，就像数据库中产生一个唯一的数字主键一样。</p>
<p>Name Service 已经是 ZooKeeper 内置的功能，你只要调用 ZooKeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。</p>
<h3 id="4-2-配置管理（Configuration-Management）"><a href="#4-2-配置管理（Configuration-Management）" class="headerlink" title="4.2. 配置管理（Configuration Management）"></a>4.2. 配置管理（Configuration Management）</h3><p>配置的管理在分布式应用环境中很常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。</p>
<p>像这样的配置信息完全可以交给 ZooKeeper 来管理，将配置信息保存在 ZooKeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 ZooKeeper 的通知，然后从 ZooKeeper 获取新的配置信息应用到系统中。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/zookeeper/Zookeeper配置管理.gif"><br></div>

<h3 id="4-3-集群管理（Group-Membership）"><a href="#4-3-集群管理（Group-Membership）" class="headerlink" title="4.3. 集群管理（Group Membership）"></a>4.3. 集群管理（Group Membership）</h3><p>ZooKeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。</p>
<p>ZooKeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 ZooKeeper 的另一个功能 Leader Election。</p>
<p>它们的实现方式都是在 ZooKeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren 上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。</p>
<p>ZooKeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/zookeeper/Zookeeper集群管理结构.gif"><br></div>

<h3 id="4-4-分布式锁"><a href="#4-4-分布式锁" class="headerlink" title="4.4. 分布式锁"></a>4.4. 分布式锁</h3><p>ZooKeeper 实现分布式锁的步骤：</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h3 id="4-5-队列管理"><a href="#4-5-队列管理" class="headerlink" title="4.5. 队列管理"></a>4.5. 队列管理</h3><p>ZooKeeper 可以处理两种类型的队列：</p>
<ol>
<li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。</li>
<li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。</li>
</ol>
<p>同步队列用 ZooKeeper 实现的实现思路如下：</p>
<p>创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。</p>
<h2 id="5-复制"><a href="#5-复制" class="headerlink" title="5. 复制"></a>5. 复制</h2><p>ZooKeeper 作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。</p>
<p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p>
<ul>
<li>写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</li>
<li>写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</li>
</ul>
<p>对 ZooKeeper 来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立 observer 的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<h2 id="6-选举流程"><a href="#6-选举流程" class="headerlink" title="6. 选举流程"></a>6. 选举流程</h2><p>选举状态：</p>
<ul>
<li>LOOKING，竞选状态。</li>
<li>FOLLOWING，随从状态，同步 leader 状态，参与投票。</li>
<li>OBSERVING，观察状态,同步 leader 状态，不参与投票。</li>
<li>LEADING，领导者状态。</li>
</ul>
<p>ZooKeeper 选举流程基于 Paxos 算法。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/zookeeper/ZooKeeper选举流程图.jpg" width="640"><br></div>

<ol>
<li>选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的 Server；</li>
<li>选举线程首先向所有 Server 发起一次询问(包括自己)；</li>
<li>选举线程收到回复后，验证是否是自己发起的询问(验证 zxid 是否一致)，然后获取对方的 id(myid)，并存储到当前询问对象列表中，最后获取对方提议的 leader 相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>
<li>收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次要投票的 Server；</li>
<li>线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server 获得 n/2 + 1 的 Server 票数，设置当前推荐的 leader 为获胜的 Server，将根据获胜的 Server 相关信息设置自己的状态，否则，继续这个过程，直到 leader 被选举出来。 通过流程分析我们可以得出：要使 Leader 获得多数 Server 的支持，则 Server 总数必须是奇数 2n+1，且存活的 Server 的数目不得少于 n+1. 每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</li>
</ol>
<p>述 Leader 选择过程中的状态变化，这是假设全部实例中均没有数据，假设服务器启动顺序分别为：A,B,C。</p>
<h2 id="7-同步流程"><a href="#7-同步流程" class="headerlink" title="7. 同步流程"></a>7. 同步流程</h2><p>选完 Leader 以后，zk 就进入状态同步过程。</p>
<ol>
<li>Leader 等待 server 连接；</li>
<li>Follower 连接 leader，将最大的 zxid 发送给 leader；</li>
<li>Leader 根据 follower 的 zxid 确定同步点；</li>
<li>完成同步后通知 follower 已经成为 uptodate 状态；</li>
<li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</li>
</ol>
<h2 id="8-资源"><a href="#8-资源" class="headerlink" title="8. 资源"></a>8. 资源</h2><h3 id="8-1-官方资源"><a href="#8-1-官方资源" class="headerlink" title="8.1. 官方资源"></a>8.1. 官方资源</h3><p>| <a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">官网</a> | <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER" target="_blank" rel="noopener">官网文档</a> | <a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">Github</a> |</p>
<h3 id="8-2-文章"><a href="#8-2-文章" class="headerlink" title="8.2. 文章"></a>8.2. 文章</h3><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html" target="_blank" rel="noopener">分布式服务框架 ZooKeeper – 管理分布式环境中的数据</a><br><a href="https://www.cnblogs.com/felixzh/p/5869212.html" target="_blank" rel="noopener">ZooKeeper 的功能以及工作原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/25/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/blog/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/27/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">381</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">76</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dunwu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:forbreak@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
