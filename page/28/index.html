<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="张鹏的博客">
<meta property="og:url" content="https://dunwu.github.io/page/28/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张鹏的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dunwu.github.io/page/28/">





  <title>张鹏的博客 - 大道至简，知易行难</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/28/programming/java/javacore/container/List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/28/programming/java/javacore/container/List/" itemprop="url">List</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T00:00:00+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javacore/" itemprop="url" rel="index">
                    <span itemprop="name">javacore</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><blockquote>
<p><code>List</code> 是 <code>Collection</code> 的子接口，其中可以保存各个重复的内容。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#list-概述">List 概述</a></li>
<li><a href="#arraylist">ArrayList</a></li>
<li><a href="#linkedlist">LinkedList</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="List-概述"><a href="#List-概述" class="headerlink" title="List 概述"></a>List 概述</h2><p><code>List</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>List</code> 主要方法：</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/container/list-api.png" width="400"><br></div>

<p><code>List</code> 常见子类：</p>
<ul>
<li><code>ArrayList</code> - 动态数组。</li>
<li><code>LinkedList</code> - 双链表。</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="ArrayList-要点"><a href="#ArrayList-要点" class="headerlink" title="ArrayList 要点"></a>ArrayList 要点</h3><p><code>ArrayList</code> 是一个数组队列，相当于动态数组。与 Java 中的数组相比，<code>ArrayList</code> 的容量可以动态增长。</p>
<p><code>ArrayList</code> 定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>从 ArrayList 的定义，不难看出 ArrayList 的一些基本特性：</p>
<ul>
<li>ArrayList 实现 List 接口，能对它进行队列操作。</li>
<li>ArrayList 实现了 RandmoAccess 接口，即提供了随机访问功能。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</li>
<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。</li>
<li>ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。</li>
<li>ArrayList 是非线程安全的。</li>
</ul>
<h3 id="ArrayList-原理"><a href="#ArrayList-原理" class="headerlink" title="ArrayList 原理"></a>ArrayList 原理</h3><h4 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h4><p>ArrayList 包含了两个重要的元素：elementData 和 size。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<ol>
<li>elementData 它保存了添加到 ArrayList 中的元素。这个数组的默认大小为 10。</li>
<li>size 则是动态数组的实际大小。</li>
</ol>
<p>ArrayList 实现了 RandomAccess 接口，因此支持随机访问。这是理所当然的，因为 ArrayList 是基于数组实现的。</p>
<h4 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2. 序列化"></a>2. 序列化</h4><p>ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制只序列化数组中有元素填充那部分内容。</p>
<h4 id="3-扩容"><a href="#3-扩容" class="headerlink" title="3. 扩容"></a>3. 扩容</h4><p>添加元素时使用 <code>ensureCapacityInternal()</code> 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4. 删除元素"></a>4. 删除元素</h4><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，复制的代价很高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-Fail-Fast"><a href="#5-Fail-Fast" class="headerlink" title="5. Fail-Fast"></a>5. Fail-Fast</h4><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="LinkedList-要点"><a href="#LinkedList-要点" class="headerlink" title="LinkedList 要点"></a>LinkedList 要点</h3><p>LinkedList 基于双向链表实现。由于是双向链表，那么它的<strong>顺序访问会非常高效，而随机访问效率比较低。</strong></p>
<p>LinkedList 定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>从 LinkedList 的定义，可以得出 LinkedList 的一些基本特性：</p>
<ul>
<li>LinkedList 是一个继承于 AbstractSequentialList 的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</li>
<li>LinkedList 实现 List 接口，能对它进行队列操作。</li>
<li>LinkedList 实现 Deque 接口，即能将 LinkedList 当作双端队列使用。</li>
<li>LinkedList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。</li>
<li>LinkedList 实现 java.io.Serializable 接口，这意味着 LinkedList 支持序列化。</li>
<li>LinkedList 是非线程安全的。</li>
</ul>
<h3 id="LinkedList-原理"><a href="#LinkedList-原理" class="headerlink" title="LinkedList 原理"></a>LinkedList 原理</h3><h4 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h4><p>LinkedList 包含两个重要的成员：first 和 last。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<ul>
<li>size 表示双链表中节点的个数，初始为 0。</li>
<li>first 和 last 分别是双链表的头节点和尾节点。</li>
</ul>
<p>Node 则表示链表中的实例。Node 中包含三个元素：prev, next, item。其中，prev 是该节点的上一个节点，next 是该节点的下一个节点，item 是该节点所包含的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li>
<li>ArrayList 支持随机访问，所以访问速度更快；LinkedList 在任意位置添加删除元素更快；</li>
<li>ArrayList 基于数组实现，存在容量限制，当元素数超过最大容量时，会自动扩容；LinkedList 基于双链表实现，不存在容量限制；</li>
<li>ArrayList 和 LinkedList 都不是线程安全的。</li>
</ul>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://item.jd.com/10058164.html" target="_blank" rel="noopener">Java 编程思想（第 4 版）</a></li>
<li><a href="https://www.cnblogs.com/skywang12345/p/3308556.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3308556.html</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3308807.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3308807.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/28/programming/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/28/programming/python/" itemprop="url">Python</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T00:00:00+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#解释器">解释器</a></li>
<li><a href="#注释">注释</a></li>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#操作符">操作符</a><ul>
<li><a href="#算术运算符">算术运算符</a></li>
<li><a href="#比较运算符">比较运算符</a></li>
<li><a href="#赋值运算符">赋值运算符</a></li>
<li><a href="#位运算符">位运算符</a></li>
<li><a href="#逻辑运算符">逻辑运算符</a></li>
<li><a href="#成员运算符">成员运算符</a></li>
<li><a href="#身份运算符">身份运算符</a></li>
<li><a href="#运算符优先级">运算符优先级</a></li>
</ul>
</li>
<li><a href="#控制语句">控制语句</a><ul>
<li><a href="#条件语句">条件语句</a></li>
<li><a href="#循环语句">循环语句</a></li>
</ul>
</li>
<li><a href="#函数">函数</a><ul>
<li><a href="#函数变量作用域">函数变量作用域</a></li>
<li><a href="#关键字参数">关键字参数</a></li>
<li><a href="#可变参数列表">可变参数列表</a></li>
<li><a href="#返回值">返回值</a></li>
</ul>
</li>
<li><a href="#异常">异常</a><ul>
<li><a href="#异常处理">异常处理</a></li>
<li><a href="#抛出异常">抛出异常</a></li>
<li><a href="#自定义异常">自定义异常</a></li>
</ul>
</li>
<li><a href="#面向对象">面向对象</a><ul>
<li><a href="#面向对象技术简介">面向对象技术简介</a></li>
<li><a href="#类定义">类定义</a></li>
<li><a href="#类对象">类对象</a></li>
<li><a href="#类的方法">类的方法</a></li>
<li><a href="#继承">继承</a></li>
<li><a href="#多继承">多继承</a></li>
<li><a href="#方法重写">方法重写</a></li>
<li><a href="#类属性与方法">类属性与方法</a></li>
</ul>
</li>
<li><a href="#标准库概览">标准库概览</a><ul>
<li><a href="#操作系统接口">操作系统接口</a></li>
<li><a href="#文件通配符">文件通配符</a></li>
<li><a href="#命令行参数">命令行参数</a></li>
<li><a href="#错误输出重定向和程序终止">错误输出重定向和程序终止</a></li>
<li><a href="#字符串正则匹配">字符串正则匹配</a></li>
<li><a href="#数学">数学</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="Python-编程"><a href="#Python-编程" class="headerlink" title="Python 编程"></a>Python 编程</h1><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>Linux/Unix 的系统上，Python 解释器通常被安装在 <code>/usr/local/bin/python3.4</code> 这样的有效路径（目录）里。</p>
<p>我们可以将路径 <code>/usr/local/bin</code> 添加到您的 Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell 终端输入下面的命令来启动 Python 。</p>
<p>在 Linux/Unix 系统中，你可以在脚本顶部添加以下命令让 Python 脚本可以像 SHELL 脚本一样可直接执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3.4</span></span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python 中的注释有三种形式：</p>
<ul>
<li>以 <code>#</code> 开头</li>
<li>以 <code>&#39;&#39;&#39;</code> 开始，以 <code>&#39;&#39;&#39;</code> 结尾</li>
<li>以 <code>&quot;&quot;&quot;</code> 开始，以 <code>&quot;&quot;&quot;</code> 结尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Python 语言支持以下类型的运算符:</p>
<ul>
<li><p>算术运算符</p>
</li>
<li><p>比较（关系）运算符</p>
</li>
<li><p>赋值运算符</p>
</li>
<li><p>逻辑运算符</p>
</li>
<li><p>位运算符</p>
</li>
<li><p>成员运算符</p>
</li>
<li><p>身份运算符</p>
</li>
<li><p>运算符优先级</p>
</li>
</ul>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加 - 两个对象相加</td>
<td>a + b 输出结果 31</td>
</tr>
<tr>
<td>-</td>
<td>减 - 得到负数或是一个数减去另一个数</td>
<td>a - b 输出结果 -11</td>
</tr>
<tr>
<td>*</td>
<td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td>a * b 输出结果 210</td>
</tr>
<tr>
<td>/</td>
<td>除 - x 除以 y</td>
<td>b / a 输出结果 2.1</td>
</tr>
<tr>
<td>%</td>
<td>取模 - 返回除法的余数</td>
<td>b % a 输出结果 1</td>
</tr>
<tr>
<td>**</td>
<td>幂 - 返回 x 的 y 次幂</td>
<td>a**b 为 10 的 21 次方</td>
</tr>
<tr>
<td>//</td>
<td>取整除 - 返回商的整数部分</td>
<td>9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
</tbody>
</table>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于 - 比较对象是否相等</td>
<td>(a == b) 返回 False。</td>
</tr>
<tr>
<td>!=</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>(a != b) 返回 True.</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 - 返回 x 是否大于 y</td>
<td>(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 - 返回 x 是否小于 y。所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。注意，这些变量名的大写。</td>
<td>(a &lt; b) 返回 True。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 - 返回 x 是否大于等于 y。</td>
<td>(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 - 返回 x 是否小于等于 y。</td>
<td>(a &lt;= b) 返回 True。</td>
</tr>
</tbody>
</table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符</td>
<td>c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c _= a 等效于 c = c _ a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c <strong>= a 等效于 c = c </strong> a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
</tbody>
</table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与运算符：参与运算的两个值,如果两个相应位都为 1,则该位的结果为 1,否则为 0</td>
<td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>按位或运算符：只要对应的二个二进位有一个为 1 时，结果位就为 1。</td>
<td>(a \</td>
<td>b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符：当两对应的二进位相异时，结果为 1</td>
<td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符：对数据的每个二进制位取反,即把 1 变为 0,把 0 变为 1</td>
<td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补 0。</td>
<td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>逻辑表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>x and y</td>
<td>布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td>(a and b) 返回 20。</td>
</tr>
<tr>
<td>or</td>
<td>x or y</td>
<td>布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td>
<td>(a or b) 返回 10。</td>
</tr>
<tr>
<td>not</td>
<td>not x</td>
<td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td>not(a and b) 返回 False</td>
</tr>
</tbody>
</table>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象</td>
<td>x is y, 如果 id(x) 等于 id(y) , <strong>is</strong> 返回结果 1</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
<td>x is not y, 如果 id(x) 不等于 id(y). <strong>is not</strong> 返回结果 1</td>
</tr>
</tbody>
</table>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td>指数 (最高优先级)</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘，除，取模和取整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加法减法</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移，左移运算符</td>
</tr>
<tr>
<td>&amp;</td>
<td>位 ‘AND’</td>
</tr>
<tr>
<td>^ \</td>
<td></td>
<td>位运算符</td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>比较运算符</td>
</tr>
<tr>
<td>&lt;&gt; == !=</td>
<td>等于运算符</td>
</tr>
<tr>
<td>= %= /= //= -= += *= **=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成员运算符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
</tbody>
</table>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件：</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">  &lt;statements&gt;</span><br></pre></td></tr></table></figure>
<h4 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><ul>
<li>break 语句可以跳出 for 和 while 的循环体。</li>
<li>continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</li>
</ul>
<h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><p>pass 语句什么都不做。它只在语法上需要一条语句但程序不需要任何操作时使用.例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  函数名（参数列表）：</span></span><br><span class="line"><span class="function">    函数体</span></span><br></pre></td></tr></table></figure>
<h3 id="函数变量作用域"><a href="#函数变量作用域" class="headerlink" title="函数变量作用域"></a>函数变量作用域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line">a = <span class="number">4</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">17</span> <span class="comment"># 局部变量</span></span><br><span class="line">    print(<span class="string">"in print_func a = "</span>, a)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in print_func a = "</span>, a)</span><br><span class="line">print_func1()</span><br><span class="line">print_func2()</span><br><span class="line">print(<span class="string">"a = "</span>, a)</span><br></pre></td></tr></table></figure>
<p>以上实例运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> print_func a =  <span class="number">17</span></span><br><span class="line"><span class="keyword">in</span> print_func a =  <span class="number">4</span></span><br><span class="line">a =  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>函数也可以使用 kwarg=value 的关键字参数形式被调用.例如,以下函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>, type=<span class="string">'Norwegian Blue'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>)</span><br><span class="line">    print(<span class="string">"-- Lovely plumage, the"</span>, type)</span><br><span class="line">    print(<span class="string">"-- It's"</span>, state, <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure>
<p>可以以下几种方式被调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parrot(<span class="number">1000</span>)                                          <span class="comment"># 1 positional argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000</span>)                                  <span class="comment"># 1 keyword argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000000</span>, action=<span class="string">'VOOOOOM'</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(action=<span class="string">'VOOOOOM'</span>, voltage=<span class="number">1000000</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(<span class="string">'a million'</span>, <span class="string">'bereft of life'</span>, <span class="string">'jump'</span>)         <span class="comment"># 3 positional arguments</span></span><br><span class="line">parrot(<span class="string">'a thousand'</span>, state=<span class="string">'pushing up the daisies'</span>)  <span class="comment"># 1 positional, 1 keyword</span></span><br></pre></td></tr></table></figure>
<p>以下为错误调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parrot()                     # required argument missing</span><br><span class="line">parrot(voltage=5.0, &apos;dead&apos;)  # non-keyword argument after a keyword argument</span><br><span class="line">parrot(110, voltage=220)     # duplicate value for the same argument</span><br><span class="line">parrot(actor=&apos;John Cleese&apos;)  # unknown keyword argument</span><br></pre></td></tr></table></figure>
<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>最后,一个最不常用的选择是可以让函数调用可变个数的参数.这些参数被包装进一个元组(查看元组和序列).在这些可变个数的参数之前,可以有零到多个普通的参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arithmetic_mean</span><span class="params">(*args)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> args:</span><br><span class="line">        sum += x</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Python 的函数的返回值使用 return 语句，可以将函数作为一个值赋值给指定变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_sum</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    c = x + y</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>try 语句按照如下方式工作；</p>
<ul>
<li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）</li>
<li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li>
<li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。最后执行 try 语句之后的代码。</li>
<li>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</li>
<li>不管 try 子句里面有没有发生异常，finally 子句都会执行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'myfile.txt'</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = int(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">"OS error: &#123;0&#125;"</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"Could not convert data to an integer."</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"Unexpected error:"</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 清理行为</span></span><br></pre></td></tr></table></figure>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>Python 使用 raise 语句抛出一个指定的异常。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>可以通过创建一个新的 exception 类来拥有自己的异常。异常应该继承自 Exception 类，或者直接继承，或者间接继承。</p>
<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Base class for exceptions in this module."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Exception raised for errors in the input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        expression -- input expression in which the error occurred</span></span><br><span class="line"><span class="string">        message -- explanation of the error</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, expression, message)</span>:</span></span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Raised when an operation attempts a state transition that's not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, previous, next, message)</span>:</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure>
<p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象技术简介"><a href="#面向对象技术简介" class="headerlink" title="面向对象技术简介"></a>面向对象技术简介</h3><ul>
<li><p><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li><p><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li><p><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</p>
</li>
<li><p><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li><p><strong>实例变量：</strong>定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li><p><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟”是一个（is-a）”关系（例图，Dog 是一个 Animal）。</p>
</li>
<li><p><strong>实例化：</strong>创建一个类的实例，类的具体对象。</p>
</li>
<li><p><strong>方法：</strong>类中定义的函数。</p>
</li>
<li><p><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p>
<h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类对象支持两种操作：属性引用和实例化。</p>
<p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p>
<p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""一个简单的类实例"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br><span class="line">print(<span class="string">"MyClass 类的属性 i 为："</span>, x.i)</span><br><span class="line">print(<span class="string">"MyClass 类的方法 f 输出为："</span>, x.f())</span><br></pre></td></tr></table></figure>
<p>实例化类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br></pre></td></tr></table></figure>
<p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass 类的属性 i 为： 12345</span><br><span class="line">MyClass 类的方法 f 输出为： hello world</span><br></pre></td></tr></table></figure>
<p>很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 <strong>init</strong>() 的特殊方法（构造方法），像下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure>
<p>类定义了 <strong>init</strong>() 方法的话，类的实例化操作会自动调用 <strong>init</strong>() 方法。所以在下例中，可以这样创建一个新的实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>
<p>当然， <strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, realpart, imagpart)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.r = realpart</span><br><span class="line"><span class="meta">... </span>        self.i = imagpart</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Complex(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.r, x.i</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">p = people(<span class="string">'W3Cschool'</span>,<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">p.speak()</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W3Cschool 说: 我 10 岁。</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Python 同样支持类的继承，如果一种语言不支持继承就，类就没有什么意义。派生类的定义如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName1)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python 从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。</p>
<p>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(modname.BaseClassName):</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span>%(self.name,self.age,self.grade))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = student(<span class="string">'ken'</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ken 说: 我 10 岁了，我在读 3 年级</span><br></pre></td></tr></table></figure>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>Python 同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python 从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span>%(self.name,self.age,self.grade))</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span><span class="params">()</span>:</span></span><br><span class="line">    topic = <span class="string">''</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,t)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我叫 %s，我是一个演说家，我演讲的主题是 %s"</span>%(self.name,self.topic))</span><br><span class="line"></span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span><span class="params">(speaker,student)</span>:</span></span><br><span class="line">    a =<span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g,t)</span>:</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"></span><br><span class="line">test = sample(<span class="string">"Tim"</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">"Python"</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫 Tim，我是一个演说家，我演讲的主题是 Python</span><br></pre></td></tr></table></figure>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用父类方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用子类方法'</span>)</span><br><span class="line"></span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用子类方法</span><br></pre></td></tr></table></figure>
<h3 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h3><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h4><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时<strong>self.__private_attrs</strong>。</p>
<h4 id="类的方法-1"><a href="#类的方法-1" class="headerlink" title="类的方法"></a>类的方法</h4><p>在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p>
<h4 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h4><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 <strong>slef.__private_methods</strong>。</p>
<p>实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> (self.__secretCount)</span><br><span class="line"></span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="keyword">print</span> (counter.publicCount)</span><br><span class="line"><span class="keyword">print</span> (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 16, in &lt;module&gt;</span><br><span class="line">    print (counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: &apos;JustCounter&apos; object has no attribute &apos;__secretCount&apos;</span><br></pre></td></tr></table></figure>
<h4 id="类的专有方法："><a href="#类的专有方法：" class="headerlink" title="类的专有方法："></a>类的专有方法：</h4><ul>
<li>*<strong>*init</strong> :** 构造函数，在生成对象时调用</li>
<li>*<strong>*del</strong> :** 析构函数，释放对象时使用</li>
<li>*<strong>*repr</strong> :** 打印，转换</li>
<li>*<strong>*setitem</strong> :** 按照索引赋值</li>
<li>*<strong>*getitem</strong>:** 按照索引获取值</li>
<li>*<strong>*len</strong>:** 获得长度</li>
<li>*<strong>*cmp</strong>:** 比较运算</li>
<li>*<strong>*call</strong>:** 函数调用</li>
<li>*<strong>*add</strong>:** 加运算</li>
<li>*<strong>*sub</strong>:** 减运算</li>
<li>*<strong>*mul</strong>:** 乘运算</li>
<li>*<strong>*div</strong>:** 除运算</li>
<li>*<strong>*mod</strong>:** 求余运算</li>
<li>*<strong>*pow</strong>:** 乘方</li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>Python 同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'Vector (%d, %d)'</span> % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self,other)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,<span class="number">-2</span>)</span><br><span class="line"><span class="keyword">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(7,8)</span><br></pre></td></tr></table></figure>
<h2 id="标准库概览"><a href="#标准库概览" class="headerlink" title="标准库概览"></a>标准库概览</h2><h3 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h3><p>os 模块提供了不少与操作系统相关联的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()      <span class="comment"># 返回当前的工作目录</span></span><br><span class="line"><span class="string">'C:\\Python34'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">'/server/accesslogs'</span>)   <span class="comment"># 修改当前的工作目录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">'mkdir today'</span>)   <span class="comment"># 执行系统命令 mkdir</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="文件通配符"><a href="#文件通配符" class="headerlink" title="文件通配符"></a>文件通配符</h3><p>glob 模块提供了一个函数用于从目录通配符搜索中生成文件列表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.py'</span>)</span><br><span class="line">[<span class="string">'primes.py'</span>, <span class="string">'random.py'</span>, <span class="string">'quote.py'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 <code>python demo.py one two three</code> 后可以得到以下输出结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.argv)</span><br><span class="line">[<span class="string">'demo.py'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="错误输出重定向和程序终止"><a href="#错误输出重定向和程序终止" class="headerlink" title="错误输出重定向和程序终止"></a>错误输出重定向和程序终止</h3><p>sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">'Warning, log file not found starting a new one\n'</span>)</span><br><span class="line">Warning, log file <span class="keyword">not</span> found starting a new one</span><br></pre></td></tr></table></figure>
<h3 id="字符串正则匹配"><a href="#字符串正则匹配" class="headerlink" title="字符串正则匹配"></a>字符串正则匹配</h3><p>re 模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'\bf[a-z]*'</span>, <span class="string">'which foot or hand fell fastest'</span>)</span><br><span class="line">[<span class="string">'foot'</span>, <span class="string">'fell'</span>, <span class="string">'fastest'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\b[a-z]+) \1'</span>, <span class="string">r'\1'</span>, <span class="string">'cat in the the hat'</span>)</span><br><span class="line"><span class="string">'cat in the hat'</span></span><br></pre></td></tr></table></figure>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>math 模块为浮点运算提供了对底层 C 函数库的访问:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.cos(math.pi / <span class="number">4</span>)</span><br><span class="line"><span class="number">0.70710678118654757</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.log(<span class="number">1024</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">https://github.com/vinta/awesome-python</a> - 资源大全</li>
<li><a href="https://github.com/jobbole/awesome-python-cn" target="_blank" rel="noopener">https://github.com/jobbole/awesome-python-cn</a> - 资源大全</li>
<li><a href="https://github.com/scrapy/scrapy" target="_blank" rel="noopener">https://github.com/scrapy/scrapy</a> - python 爬虫框架</li>
<li><a href="https://github.com/faif/python-patterns" target="_blank" rel="noopener">https://github.com/faif/python-patterns</a> - python 设计模式</li>
<li><a href="https://github.com/kennethreitz/python-guide" target="_blank" rel="noopener">https://github.com/kennethreitz/python-guide</a> - python 最佳实践</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/28/programming/java/javacore/container/Set/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/28/programming/java/javacore/container/Set/" itemprop="url">Java 容器之 Set</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T00:00:00+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javacore/" itemprop="url" rel="index">
                    <span itemprop="name">javacore</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-容器之-Set"><a href="#Java-容器之-Set" class="headerlink" title="Java 容器之 Set"></a>Java 容器之 Set</h1><!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#set-架构">Set 架构</a></li>
<li><a href="#set-接口">Set 接口</a></li>
<li><a href="#sortedset-接口">SortedSet 接口</a></li>
<li><a href="#navigableset-接口">NavigableSet 接口</a></li>
<li><a href="#abstractset-抽象类">AbstractSet 抽象类</a></li>
<li><a href="#hashset-类">HashSet 类</a></li>
<li><a href="#treeset-类">TreeSet 类</a></li>
<li><a href="#linkedhashset-类">LinkedHashSet 类</a></li>
<li><a href="#enumset-类">EnumSet 类</a></li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="Set-架构"><a href="#Set-架构" class="headerlink" title="Set 架构"></a>Set 架构</h2><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/container/Set-diagrams.png" width="400"><br></div>

<ul>
<li>Set 继承了 Collection 的接口。实际上 Set 就是 Collection，只是行为略有不同：Set 集合不允许有重复元素。</li>
<li>SortedSet 继承了 Set 的接口。SortedSet 中的内容是排序的唯一值，排序的方法是通过比较器(Comparator)。</li>
<li>NavigableSet 继承了 SortedSet 的接口。相比于 NavigableSet 有一系列的导航方法；如”获取大于/等于某值的元素”、“获取小于/等于某值的元素”等等。</li>
<li>AbstractSet 是一个抽象类，它继承于 AbstractCollection，AbstractCollection 实现了 Set 中的绝大部分函数，为 Set 的实现类提供了便利。</li>
<li>HashSet 类依赖于 HashMap，它实际上是通过 HashMap 实现的。HashSet 中的元素是无序的。</li>
<li>TreeSet 类依赖于 TreeMap，它实际上是通过 TreeMap 实现的。TreeSet 中的元素是有序的。</li>
<li>LinkedHashSet 类具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。</li>
<li>EnumSet 中所有元素都必须是指定枚举类型的枚举值。</li>
</ul>
<h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h2><p>Set 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Set 继承了 Collection 的接口。实际上，Set 就是 Collection，二者提供的方法完全相同。</p>
<h2 id="SortedSet-接口"><a href="#SortedSet-接口" class="headerlink" title="SortedSet 接口"></a>SortedSet 接口</h2><p>SortedSet 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>SortedSet 接口新扩展的方法：</p>
<ul>
<li>comparator - 返回 Comparator</li>
<li>subSet - 返回指定区间的子集</li>
<li>headSet - 返回小于指定元素的子集</li>
<li>tailSet - 返回大于指定元素的子集</li>
<li>first - 返回第一个元素</li>
<li>last - 返回最后一个元素</li>
<li>spliterator</li>
</ul>
<h2 id="NavigableSet-接口"><a href="#NavigableSet-接口" class="headerlink" title="NavigableSet 接口"></a>NavigableSet 接口</h2><p>NavigableSet 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>NavigableSet 接口新扩展的方法：</p>
<ul>
<li>lower - 返回小于指定值的元素中最接近的元素</li>
<li>higher - 返回大于指定值的元素中最接近的元素</li>
<li>floor - 返回小于或等于指定值的元素中最接近的元素</li>
<li>ceiling - 返回大于或等于指定值的元素中最接近的元素</li>
<li>pollFirst - 检索并移除第一个（最小的）元素</li>
<li>pollLast - 检索并移除最后一个（最大的）元素</li>
<li>descendingSet - 返回反序排列的 Set</li>
<li>descendingIterator - 返回反序排列的 Set 的迭代器</li>
<li>subSet - 返回指定区间的子集</li>
<li>headSet - 返回小于指定元素的子集</li>
<li>tailSet - 返回大于指定元素的子集</li>
</ul>
<h2 id="AbstractSet-抽象类"><a href="#AbstractSet-抽象类" class="headerlink" title="AbstractSet 抽象类"></a>AbstractSet 抽象类</h2><p>AbstractSet 抽象类定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractSet 类提供 Set 接口的骨干实现，以最大限度地减少实现 Set 接口所需的工作。</p>
<p>事实上，主要的实现已经在 AbstractCollection 中完成。</p>
<h2 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h2><p>HashSet 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashSet-要点"><a href="#HashSet-要点" class="headerlink" title="HashSet 要点"></a>HashSet 要点</h3><ol>
<li>HashSet 类通过继承 AbstractSet 实现了 Set 接口中的骨干方法。</li>
<li>HashSet 实现了 Cloneable，所以支持克隆。</li>
<li>HashSet 实现了 Serializable，所以支持序列化。</li>
<li>HashSet 中存储的元素是无序的。</li>
<li>HashSet 允许 null 值的元素。</li>
<li>HashSet 不是线程安全的。</li>
</ol>
<h3 id="HashSet-原理"><a href="#HashSet-原理" class="headerlink" title="HashSet 原理"></a>HashSet 原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet 的核心，通过维护一个 HashMap 实体来实现 HashSet 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PRESENT 是用于关联 map 中当前操作元素的一个虚拟值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashSet 是基于 HashMap 实现的。</strong></p>
<p>HashSet 中维护了一个 HashMap 对象 map，HashSet 的重要方法，如 add、remove、iterator、clear、size 等都是围绕 map 实现的。</p>
<p>PRESENT 是用于关联 map 中当前操作元素的一个虚拟值。</p>
<p>HashSet 类中通过定义 <code>writeObject()</code> 和 <code>readObject()</code> 方法确定了其序列化和反序列化的机制。</p>
<h2 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h2><p>TreeSet 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeSet-要点"><a href="#TreeSet-要点" class="headerlink" title="TreeSet 要点"></a>TreeSet 要点</h3><ol>
<li>TreeSet 类通过继承 AbstractSet 实现了 NavigableSet 接口中的骨干方法。</li>
<li>TreeSet 实现了 Cloneable，所以支持克隆。</li>
<li>TreeSet 实现了 Serializable，所以支持序列化。</li>
<li>TreeSet 中存储的元素是有序的。排序规则是自然顺序或比较器（Comparator）中提供的顺序规则。</li>
<li>TreeSet 不是线程安全的。</li>
</ol>
<h3 id="TreeSet-源码"><a href="#TreeSet-源码" class="headerlink" title="TreeSet 源码"></a>TreeSet 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet 的核心，通过维护一个 NavigableMap 实体来实现 TreeSet 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PRESENT 是用于关联 map 中当前操作元素的一个虚拟值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p><strong>TreeSet 是基于 TreeMap 实现的。</strong></p>
<p>TreeSet 中维护了一个 NavigableMap 对象 map（实际上是一个 TreeMap 实例），TreeSet 的重要方法，如 add、remove、iterator、clear、size 等都是围绕 map 实现的。</p>
<p>PRESENT 是用于关联 map 中当前操作元素的一个虚拟值。TreeSet 中的元素都被当成 TreeMap 的 key 存储，而 value 都填的是 PRESENT。</p>
<h2 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h2><p>LinkedHashSet 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LinkedHashSet-要点"><a href="#LinkedHashSet-要点" class="headerlink" title="LinkedHashSet 要点"></a>LinkedHashSet 要点</h3><ol>
<li>LinkedHashSet 类通过继承 HashSet 实现了 Set 接口中的骨干方法。</li>
<li>LinkedHashSet 实现了 Cloneable，所以支持克隆。</li>
<li>LinkedHashSet 实现了 Serializable，所以支持序列化。</li>
<li>LinkedHashSet 中存储的元素是按照插入顺序保存的。</li>
<li>LinkedHashSet 不是线程安全的。</li>
</ol>
<h3 id="LinkedHashSet-原理"><a href="#LinkedHashSet-原理" class="headerlink" title="LinkedHashSet 原理"></a>LinkedHashSet 原理</h3><p>LinkedHashSet 有三个构造方法，无一例外，都是调用父类 HashSet 的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要强调的是：<strong>LinkedHashSet 构造方法实际上调用的是父类 HashSet 的非 public 构造方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同于 HashSet public 构造方法中初始化的 HashMap 实例，这个构造方法中，初始化了 LinkedHashMap 实例。</p>
<p>也就是说，实际上，LinkedHashSet 维护了一个双链表。由双链表的特性可以知道，它是按照元素的插入顺序保存的。所以，这就是 LinkedHashSet 中存储的元素是按照插入顺序保存的原理。</p>
<h2 id="EnumSet-类"><a href="#EnumSet-类" class="headerlink" title="EnumSet 类"></a>EnumSet 类</h2><p>EnumSet 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EnumSet-要点"><a href="#EnumSet-要点" class="headerlink" title="EnumSet 要点"></a>EnumSet 要点</h3><ol>
<li>EnumSet 类继承了 AbstractSet，所以有 Set 接口中的骨干方法。</li>
<li>EnumSet 实现了 Cloneable，所以支持克隆。</li>
<li>EnumSet 实现了 Serializable，所以支持序列化。</li>
<li>EnumSet 通过 <code>&lt;E extends Enum&lt;E&gt;&gt;</code> 限定了存储元素必须是枚举值。</li>
<li>EnumSet 没有构造方法，只能通过类中的 static 方法来创建 EnumSet 对象。</li>
<li>EnumSet 是有序的。以枚举值在 EnumSet 类中的定义顺序来决定集合元素的顺序。</li>
<li>EnumSet 不是线程安全的。</li>
</ol>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://item.jd.com/10058164.html" target="_blank" rel="noopener">Java 编程思想（Thinking in java）</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/19/database/nosql/redis/Redis哨兵/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/19/database/nosql/redis/Redis哨兵/" itemprop="url">Redis 哨兵</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T00:00:00+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#quickstart">QuickStart</a><ul>
<li><a href="#获取-sentinel">获取 Sentinel</a></li>
<li><a href="#运行-sentinel">运行 Sentinel</a></li>
<li><a href="#部署之前了解关于-sentinel-的基本东西">部署之前了解关于 Sentinel 的基本东西</a></li>
<li><a href="#sentinel-配置">Sentinel 配置</a></li>
<li><a href="#其他的-sentinels-选项">其他的 Sentinels 选项</a></li>
<li><a href="#sentinel-部署示例">Sentinel 部署示例</a></li>
</ul>
</li>
<li><a href="#快速教程">快速教程</a><ul>
<li><a href="#询问-sentinel-关于主节点的状态">询问 Sentinel 关于主节点的状态</a></li>
<li><a href="#获取当前主节点的地址">获取当前主节点的地址</a></li>
<li><a href="#故障转移测试">故障转移测试</a></li>
</ul>
</li>
<li><a href="#sentinel-api">Sentinel API</a><ul>
<li><a href="#sentinel-命令">Sentinel 命令</a></li>
<li><a href="#运行时重新配置-sentinel">运行时重新配置 Sentinel</a></li>
<li><a href="#添加和移除-sentinels">添加和移除 sentinels</a></li>
<li><a href="#移除旧的主节点或不可达的从节点">移除旧的主节点或不可达的从节点</a></li>
<li><a href="#发布订阅消息">发布/订阅消息</a></li>
<li><a href="#busy-状态的处理">BUSY 状态的处理</a></li>
</ul>
</li>
<li><a href="#更高级的概念">更高级的概念</a><ul>
<li><a href="#sdown-和-odown-失败状态">SDOWN 和 ODOWN 失败状态</a></li>
<li><a href="#sentinels-和从节点自动发现">Sentinels 和从节点自动发现</a></li>
<li><a href="#故障转移之外重新配置">故障转移之外重新配置</a></li>
<li><a href="#从节点选举和优先级">从节点选举和优先级</a></li>
</ul>
</li>
<li><a href="#算法和内部结构">算法和内部结构</a><ul>
<li><a href="#quorum">Quorum</a></li>
<li><a href="#配置-epochs">配置 epochs</a></li>
<li><a href="#配置传播">配置传播</a></li>
<li><a href="#sentinel-持久化状态">Sentinel 持久化状态</a></li>
<li><a href="#tilt-模式">TILT 模式</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>Redis Sentinel 为 Redis 提供了高可用解决方案。实际上这意味着使用 Sentinel 可以部署一套 Redis，在没有人为干预的情况下去应付各种各样的失败事件。</p>
<p>Redis Sentinel 同时提供了一些其他的功能，例如：监控、通知、并为 client 提供配置。</p>
<p>下面是 Sentinel 的功能列表：</p>
<ul>
<li>监控（Monitoring）：Sentinel 不断的去检查你的主从实例是否按照预期在工作。</li>
<li>通知（Notification）：Sentinel 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li>
<li>自动故障转移（Automatic failover）：如果一个主节点没有按照预期工作，Sentinel 会开始故障转移过程，把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li>
<li>配置提供者（Configuration provider）：Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinels 将报告新的地址。</li>
</ul>
<p><strong>Sentinel 的分布式特性</strong></p>
<p>Redis Sentinel 是一个分布式系统，Sentinel 运行在有许多 Sentinel 进程互相合作的环境下，它本身就是这样被设计的。有许多 Sentinel 进程互相合作的优点如下：</p>
<ul>
<li>当多个 Sentinel 同意一个 master 不再可用的时候，就执行故障检测。这明显降低了错误概率。</li>
<li>即使并非全部的 Sentinel 都在工作，Sentinel 也可以正常工作，这种特性，让系统非常的健康。</li>
</ul>
<p>所有的 Sentinels，Redis 实例，连接到 Sentinel 和 Redis 的客户端，本身就是一个有着特殊性质的大型分布式系统。在这篇文章中，我将逐步地介绍这些概念，最开始是一些基本的信息来理解 Sentinel 的基本属性，后面是更复杂的信息来理解 Sentinel 是怎么工作的。</p>
<h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><h3 id="获取-Sentinel"><a href="#获取-Sentinel" class="headerlink" title="获取 Sentinel"></a>获取 Sentinel</h3><p>当前版本的 Sentinel 的被称为 Sentinel 2 。它使用更强更简单的预测算法重写了 Sentinel 的初始化实现（文章的后面将会解释）。</p>
<p>Redis Sentinel 的一个稳定版本是随着 Redis2.8 和 3.0 一起的。这两个是 Redis 最新的稳定版。</p>
<p>新的进展在 unstable 分支下进行，一旦新的特性是稳定的，就会被合并到 2.8 和 3.0 分支。</p>
<p>和 Redis 2.6 一起的 Redis Sentinel 版本 1，是过时的。我们不该使用它。</p>
<h3 id="运行-Sentinel"><a href="#运行-Sentinel" class="headerlink" title="运行 Sentinel"></a>运行 Sentinel</h3><p>如果你使用 redis-sentinel 可执行文件，你可以使用下面的命令来运行 Sentinel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure>
<p>另外，你可以直接使用 redis-server 并以 Sentinel 模式来启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<p>两种方式是一样的。</p>
<p>不管咋样，使用一个配置文件来运行 Sentinel 是必须的，这个文件被系统使用来存储当前状态，如果重启，这些状态会被重新载入。如果没有配置文件或者配置文件的路径不对，Sentinel 将会拒绝启动。</p>
<p>默认情况下，Sentinels 监听 TCP 端口 26379，所以为了让 Sentinels 运行，你的机器的 26379 端口必须是打开的，用来接收其他 Sentinel 实例的连接，否则，Sentinels 不能互相交流，也不知道该干什么，也不会执行故障转移。</p>
<h3 id="部署之前了解关于-Sentinel-的基本东西"><a href="#部署之前了解关于-Sentinel-的基本东西" class="headerlink" title="部署之前了解关于 Sentinel 的基本东西"></a>部署之前了解关于 Sentinel 的基本东西</h3><ul>
<li>一个健康的集群部署，至少需要三个 Sentinel 实例</li>
<li>三个 Sentinel 实例应该被放在失败独立的电脑上或虚拟机中，比如说不同的物理机或者在不同的可用区域上执行的虚拟机。</li>
<li>Sentinel + Redis 分布式系统在失败期间并不确保写入请求被保存，因为 Redis 使用异步拷贝。可是有很多部署 Sentinel 的 方式来让窗口把丢失写入限制在特定的时刻，当然也有另外的不安全的方式来部署。</li>
<li>如果你在开发环境中没有经常测试，或者在生产环境中也没有，那就没有高可用的设置是安全的。你或许有一个错误的配置而仅仅只是在很晚的时候才出现（凌晨 3 点你的主节点宕掉了）。</li>
<li>Sentinel，Docker ，其他的网络地址转换表，端口映射 使用应该很小心的使用：Docker 执行端口重新映射，破坏 Sentinel 自动发现另外的 Sentinel 进程和一个主节点的从节点列表。在文章的稍后部分查看更过关于 Sentinel 和 Docker 的信息。</li>
</ul>
<h3 id="Sentinel-配置"><a href="#Sentinel-配置" class="headerlink" title="Sentinel 配置"></a>Sentinel 配置</h3><p>Redis 源码中包含一个名为 sentinel.conf 的文件，是一个你可以用来配置 Sentinel 的示例配置文件。一个典型的最小配置文件像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">sentinel monitor resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br></pre></td></tr></table></figure>
<p>你仅仅只需要指定要监控的主节点，并给每个单独的主节点一个不同的名称。不需要指定从节点，从节点会被自动发现。Sentinel 将会根据从节点额外的信息自动更新配置（为了在重启时保留信息）。在故障转移中每当一个从节点被提升为主节点或者当一个新的 Sentinel 被发现的时候，配置信息也被重新写入。</p>
<p>示例配置在上面，监控两个 Redis 实例集合，每个集合由一个主节点和不明确数量的从节点组成。一个集合叫做 mymaster，另外一个叫做 resque。</p>
<p>sentinel monitor 参数的意思在下面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>
<p>为了更加清晰明了，让我们一行一行来检查配置选项的意思：</p>
<p>第一行用来告诉 Redis 监控一个叫做 mymaster 的主节点，地址是 127.0.0.1 端口号是 6379，并且有 2 个仲裁机器。所有的意思都很明显，但是除了这个 quorum 参数：</p>
<ul>
<li>quorum 是 需要同意主节点不可用的 Sentinels 的数量</li>
<li>然而 quorum 仅仅只是用来检测失败。为了实际的执行故障转移，Sentinels 中的一个需要被选定为 leader 并且被授权进行操作，这仅仅发生在大多数 Sentinels 进行投票的时候。</li>
</ul>
<p>比如如果你有五个 Sentinel 进程，对于一个主节点 quorum 被设置为 2，下面是发生的事情：</p>
<ul>
<li>同时有两个 Sentinels 同意主节点不可用，其中的一个将会尝试开始故障转移。</li>
<li>如果至少有三个 Sentinels 是可用的，故障转移将会被授权并且开始。</li>
</ul>
<p>实际中，这意味着在失败时，如果大多数的 Sentinel 进程没有同意，Sentinel 永远不会开始故障转移。</p>
<h3 id="其他的-Sentinels-选项"><a href="#其他的-Sentinels-选项" class="headerlink" title="其他的 Sentinels 选项"></a>其他的 Sentinels 选项</h3><p>其他的选项几乎都是如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;</span><br></pre></td></tr></table></figure>
<p>用途如下：</p>
<p>down-after-milliseconds：当一个实例失去联系（要么不回复我们的请求，要么回复一个错误）超过了这个时间（毫秒为单位），Sentinel 就开始认为这个实例挂掉了。</p>
<p>parallel-syncs：设置的从节点的数量，这些从节点在一次故障转移过后可以使用新的主节点进行重新配置。数量越少，完成故障转移过程将花费更多的时间，如果从节点为旧的数据提供服务，你或许不想所有的从节点使用主节点进行重新同步。复制进程对于从节点来说大部分是非阻塞的，还是有一个时刻它会停下来去从主节点加载数据。你或许想确保一次只有一个从节点是不可达的，可以通过设置这个选项的值为 1 来完成。</p>
<p>别的选项在文章的其他部分进行描述。</p>
<p>所有的配置参数都可以在运行时使用 SENTINEL SET 命令进行更改，查看 Reconfiguring Sentinel at runtime 章节获取更多内容。</p>
<h3 id="Sentinel-部署示例"><a href="#Sentinel-部署示例" class="headerlink" title="Sentinel 部署示例"></a>Sentinel 部署示例</h3><p>现在你已经知道了 Sentinel 的基本信息，你或许想知道哪里放置你的 Sentinel 进程，需要多少个 Sentinel 进程等等。这个章节给出了几个部署的例子。</p>
<p>为了以图形（graphical ）格式展示配置示例，我们使用 ASCII 艺术。下面是不同的符号的意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| 这是一个独立电脑   |</span><br><span class="line">| 或者VM。我们称它为 |</span><br><span class="line">| “box”            |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<p>我们把我们想要运行的东西写到 boxes 里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">| Redis master M1   |</span><br><span class="line">| Redis Sentinel S1 |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure>
<p>不同的 box 之间通过一条线连接，表示他们之间可以互相交流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------------+               +-------------+</span><br><span class="line">| Sentinel S1 |---------------| Sentinel S2 |</span><br><span class="line">+-------------+               +-------------+</span><br></pre></td></tr></table></figure>
<p>中断的线条表示不同的网络分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------------+                +-------------+</span><br><span class="line">| Sentinel S1 |------ // ------| Sentinel S2 |</span><br><span class="line">+-------------+                +-------------+</span><br></pre></td></tr></table></figure>
<p>同时还要注意：</p>
<ul>
<li>主节点称为 M1，M2，M3，…，Mn。</li>
<li>从节点称为 R1，R2，R3，…，Rn。</li>
<li>Sentinels 称为 S1，S2，S3，…，Sn。</li>
<li>客户端称为 C1，C2，C3，…，Cn。</li>
<li>当一个实例因为 Sentinels 的行为转换角色，我们把它放在方括号里，所以[M1]表示一个实例现在是主节点。</li>
</ul>
<p>注意永远不要设置只有两个 Sentinels，因为开始一个故障转移，Sentinels 总是需要和大多数 Sentinels 交流。</p>
<h4 id="示例-1：仅仅只有两个-Sentinels，永远不要这么做"><a href="#示例-1：仅仅只有两个-Sentinels，永远不要这么做" class="headerlink" title="示例 1：仅仅只有两个 Sentinels，永远不要这么做"></a>示例 1：仅仅只有两个 Sentinels，永远不要这么做</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br><span class="line"></span><br><span class="line">Configuration: quorum = 1</span><br></pre></td></tr></table></figure>
<p>在这个设置中，如果 M1 宕掉了，R1 将会被提升至主节点，因为两个 Sentinels 将会达成一致（显然把 quorum 设置为 1），并且授权开始一个故障转移因为大多数是两个。显然，表面上可以工作，但是请检查下一个点来看看为什么这种设置是不可以的。</p>
<p>如果 M1 的 box 停止工作，M1 也会停止。运行在另外一个 box 中的 S2 将不会被授权进行故障转移，所以系统将不可用。</p>
<p>注意，需要大多数是为了应付不同的故障，最新的配置稍后会传播给所有的 Sentinels。同时注意在上述设置中单独一边的故障转移能力，没有任何协议，将是非常危险的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----+           +------+</span><br><span class="line">| M1 |----//-----| [M1] |</span><br><span class="line">| S1 |           | S2   |</span><br><span class="line">+----+           +------+</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，我们完美对称地创建了两个主节点（假设 S2 在没有授权的情况下可以进行故障转移），客户端或许会不确定写往哪一边，并且没有办法理解当分区治愈时候哪边的配置是正确的。</p>
<p>所以请至少部署三个 Sentinels 在三个不同的 box 当中。</p>
<h4 id="示例-2：三个-box-的基本设置"><a href="#示例-2：三个-box-的基本设置" class="headerlink" title="示例 2：三个 box 的基本设置"></a>示例 2：三个 box 的基本设置</h4><p>这是一个非常简单的设置，拥有更加安全的优点。它是基于三个 boxes 的，每个 box 运行一个 Redis 进程和 Sentinel 进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br><span class="line"></span><br><span class="line">Configuration: quorum = 2</span><br></pre></td></tr></table></figure>
<p>如果 M1 挂掉，S2 和 S3 将认同这次失败，并且能授权开始一次故障转移，这样使客户端可以继续使用。</p>
<p>在每一个 Sentinel 设置中，Redis 是异步复制的，总是有丢失一些写入数据的危险，因为当一个从节点被提升为主节点的时候一个写入确认还没有到达。然而在上面的设置中，还有一种更加危险的情况，由于客户端和一个老的主节点在一个网络分区中，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">         +----+</span><br><span class="line">         | M1 |</span><br><span class="line">         | S1 | &lt;- C1 (writes will be lost)</span><br><span class="line">         +----+</span><br><span class="line">            |</span><br><span class="line">            /</span><br><span class="line">            /</span><br><span class="line">+------+    |    +----+</span><br><span class="line">| [M2] |----+----| R3 |</span><br><span class="line">| S2   |         | S3 |</span><br><span class="line">+------+         +----+</span><br></pre></td></tr></table></figure>
<p>在这种情况下，网络分区把旧的主节点[M1]给孤立了，所以从节点 R2 被提升为主节点。然而，像客户端 C1，和旧的主节点在同一个网络分区中，或许继续像旧的主节点写入数据。当分区治愈，这些数据将永久丢失，这个旧得主节点将会被重新配置，作为新的主节点下的一个从节点，并丢弃它自己的数据。</p>
<p>可以使用下面的 Redis 复制特性减轻这个问题，如果一个主节点发现它不再能够把它的写入请求发送给指定数量的从节点，它就停止接受写入请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>
<p>当上面的配置应用于一个 Redis 实例。Redis 发现它不能写入至少一个 1 从节点，作为主节点的 Reids 将会停止接受写入请求。由于复制是异步，不能写入也意味着从节点也是断开的，或者超过了指定的 max-lag 秒数没有发送异步回应。</p>
<p>在上面的示例中，使用这个配置的旧的主节点 M1，在 10 秒过后就不可用了。当分区治愈，Sentinel 配置将会统一为新的，客户端 C1 将获取到一个有效的配置并且继续。</p>
<p>然而天下没有免费的午餐，在这种改进下，如果两个从节点挂掉了，主节点将会停止接收写入请求，这就是一个权衡。</p>
<h4 id="示例-3：Sentinel-在客户端所在的-box-中"><a href="#示例-3：Sentinel-在客户端所在的-box-中" class="headerlink" title="示例 3：Sentinel 在客户端所在的 box 中"></a>示例 3：Sentinel 在客户端所在的 box 中</h4><p>有时候，我们只有两个 Redis box 是可用的，一个给主节点，一个给从节点。在那种情况下，示例 2 中的配置是不可行的，我们可以采取下面的方法，Sentinels 被放置在客户端所在的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            +----+         +----+</span><br><span class="line">            | M1 |----+----| R1 |</span><br><span class="line">            | S1 |    |    | S2 |</span><br><span class="line">            +----+    |    +----+</span><br><span class="line">                      |</span><br><span class="line">         +------------+------------+</span><br><span class="line">         |            |            |</span><br><span class="line">         |            |            |</span><br><span class="line">      +----+        +----+      +----+</span><br><span class="line">      | C1 |        | C2 |      | C3 |</span><br><span class="line">      | S1 |        | S2 |      | S3 |</span><br><span class="line">      +----+        +----+      +----+</span><br><span class="line"></span><br><span class="line">      Configuration: quorum = 2</span><br><span class="line">在这种设置下，Sentinels的视角和客户端是 一样的：如</span><br></pre></td></tr></table></figure>
<p>在这种设置下，Sentinels 的视角和客户端是 一样的：如果大部分的客户端认为一个主节点是可用的，它就是可用的。这里的 C1，C2，C3 是一般的客户端， 并不意味着 C1 是连接到 Redis 的单个客户端，它更像一个应用服务器，一个 Redis app，或者类似的东西。</p>
<p>如果 M1 和 S1 所在的 box 挂掉了，故障转移将会进行，但是很明显的看到不同的网络分区将导致不同的行为。比如说，如果客户端和 Redis 服务断开连接，Sentinel 将不会被设置，因为 Redis 的主节点和从节点都是不可用的。</p>
<p>注意如果 C3 和 M1 在一个分区，我们有了一个和示例 2 中描述的类似的问题，不同的是，这里我们没有办法打破对称，因为只有一个主节点和从节点，所以主节点不会停止接收请求。</p>
<p>所以这是一个有效的设置，但是实例 2 中的设置更有优势，比如 Redis 高可用系统，Redis 运行在同一个 box 中，更容易被管理，并且可以限制在小部分的分区中主节点接收写入请求的时间。</p>
<h4 id="示例-4：Sentinel-客户端-这一边少于三个客户端"><a href="#示例-4：Sentinel-客户端-这一边少于三个客户端" class="headerlink" title="示例 4：Sentinel 客户端 这一边少于三个客户端"></a>示例 4：Sentinel 客户端 这一边少于三个客户端</h4><p>示例 3 描述的设置中，如果客户端这一边的 box 少于不够三个，这个 设置就不能使用。在这种情况下，我们需要借助混合设置，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      +----+         +----+</span><br><span class="line">      | M1 |----+----| R1 |</span><br><span class="line">      | S1 |    |    | S2 |</span><br><span class="line">      +----+    |    +----+</span><br><span class="line">                |</span><br><span class="line">         +------+-----+</span><br><span class="line">         |            |  </span><br><span class="line">         |            |</span><br><span class="line">      +----+        +----+</span><br><span class="line">      | C1 |        | C2 |</span><br><span class="line">      | S3 |        | S4 |</span><br><span class="line">      +----+        +----+</span><br><span class="line"></span><br><span class="line">Configuration: quorum = 3</span><br></pre></td></tr></table></figure>
<p>这和示例 3 中的设置非常相似，但是这里我们在可用的四个 box 中运行了四个 Sentinel。如果主节点 M1 变成不可用节点，其他三个 Sentinel 将执行故障转移。</p>
<p>理论上，当移除 S2 和 S4 正在运行的 box，这个设置可以工作，把 quorum 设置为 2。然而，在应用层没有高可用的系统，想在 Redis 这一边得到高可用是不太可能的。</p>
<h4 id="Sentinel，Docker-NAT-和可能的问题"><a href="#Sentinel，Docker-NAT-和可能的问题" class="headerlink" title="Sentinel，Docker,NAT 和可能的问题"></a>Sentinel，Docker,NAT 和可能的问题</h4><p>Docker 使用被称为端口映射的技术：与一个程序认为他使用的端口相比，运行在 Docker 容器里面的程序可能被暴露在不同的端口上。为了运行多个容器在相同的服务器上同时使用同一个端口，这是非常有用的。</p>
<p>Docker 不是唯一会发生这件事情的软件系统，也有其他的网络地址转换设置导致端口是被重映射，并且有时候没有端口，只有 IP 地址。</p>
<p>端口和地址重映射在两个方面制造了与 Sentinel 有关的问题：</p>
<p>Sentinel 的自动发现服务将停止工作，因为它使基于每个 Sentinel 往它监听的端口和 IP 地址广播 hello 消息来实现的。但是 Sentinels 没有办法来理解端口和 IP 地址被重映射了，所以他会宣布它和其他的 Sentinels 的连接是不正常的。<br>在一个主节点的 INFO 输出中，从节点 被列出来也是类似的方式：主节点检查远端对等的 TCP 连接来发现地址，在握手过程中，从节点自己广告他的端口，然而由于相同的原因，端口或许是错误的。<br>因为 Sentinels 自动发现从节点使用主节点的 INFO 输出信息，发现的从节点是不可达的，并且 Sentinel 将永远不会开始故障转移，因为从系统的观点来看，没有好的从节点，所以目前没有方式监控使用 Docker 部署的主节点和从节点实例，除非你通知 Docker 以 1:1 映射端口。</p>
<p>对于第一个问题，万一你想使用 Docker 运行一堆 Sentinel 实例，你可以使用下面的两个 Sentinel 配置，为了强迫 Sentinel 宣布一个指定的端口和 IP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel announce-ip &lt;ip&gt;</span><br><span class="line">sentinel announce-port &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>注意，Docker 可以运行 host networking 模式。这就不会有问题因为端口不会被重新映射。</p>
<h2 id="快速教程"><a href="#快速教程" class="headerlink" title="快速教程"></a>快速教程</h2><p>在文章接下来的部分中，所有的说明都是关于 Sentinel API，配置和语义。对于想尽快上手的人，这部分的教程展示了三个 Sentinel 怎么配置和交互。</p>
<p>现在我假设三个实例分别在端口 5000、5001、5002 上。我也假设你在 6379 上有一个主节点 Redis 实例，6380 上有一个从节点实例。在本教程中我们将使用 IPV4 回调地址 127.0.0.1，假设你在你的电脑上运行了 模拟环境。</p>
<p>三个 Sentinel 配置文件应该看起来像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 5000</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>
<p>另外的两个配置文件也是相同的，但是使用 5001,5002 作为端口号。</p>
<p>上面的配置中需要注意的一些事情：</p>
<p>主节点集群称为 mymaster，它定义了主节点和它的从节点。因为每个 master set 有一个不同的名称，Sentinel 能同时监控不同的主节点和从节点的集合。<br>quorum 被设置为 2。<br>down-after-milliseconds 的值是 5000 毫秒，就是 5 秒钟，所以在这个时间内一旦我们不能收到回复，主节点将发现失败。<br>一旦你启动了三个 Sentinels，可以看到他们打印的一些信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+monitor master mymaster 127.0.0.1 637这是一个Sentinel事件，如果你</span><br></pre></td></tr></table></figure>
<p>SUBSCRIBE 了指定名称的事件，你可以收到这种事件通过发布/订阅。</p>
<p>Sentinel 在故障检测和故障转移中生成和打印不同的事件。</p>
<h3 id="询问-Sentinel-关于主节点的状态"><a href="#询问-Sentinel-关于主节点的状态" class="headerlink" title="询问 Sentinel 关于主节点的状态"></a>询问 Sentinel 关于主节点的状态</h3><p>Sentinel 开始启动的时候，要做的事情是检查主节点的监控是否正常：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p <span class="number">5000</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>&gt; sentinel master mymaster</span><br><span class="line"> <span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">"mymaster"</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">"ip"</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">"127.0.0.1"</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">"port"</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">"6379"</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">"runid"</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">"953ae6a589449c13ddefaee3538d356d287f509b"</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">"flags"</span></span><br><span class="line"><span class="number">10</span>) <span class="string">"master"</span></span><br><span class="line"><span class="number">11</span>) <span class="string">"link-pending-commands"</span></span><br><span class="line"><span class="number">12</span>) <span class="string">"0"</span></span><br><span class="line"><span class="number">13</span>) <span class="string">"link-refcount"</span></span><br><span class="line"><span class="number">14</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">15</span>) <span class="string">"last-ping-sent"</span></span><br><span class="line"><span class="number">16</span>) <span class="string">"0"</span></span><br><span class="line"><span class="number">17</span>) <span class="string">"last-ok-ping-reply"</span></span><br><span class="line"><span class="number">18</span>) <span class="string">"735"</span></span><br><span class="line"><span class="number">19</span>) <span class="string">"last-ping-reply"</span></span><br><span class="line"><span class="number">20</span>) <span class="string">"735"</span></span><br><span class="line"><span class="number">21</span>) <span class="string">"down-after-milliseconds"</span></span><br><span class="line"><span class="number">22</span>) <span class="string">"5000"</span></span><br><span class="line"><span class="number">23</span>) <span class="string">"info-refresh"</span></span><br><span class="line"><span class="number">24</span>) <span class="string">"126"</span></span><br><span class="line"><span class="number">25</span>) <span class="string">"role-reported"</span></span><br><span class="line"><span class="number">26</span>) <span class="string">"master"</span></span><br><span class="line"><span class="number">27</span>) <span class="string">"role-reported-time"</span></span><br><span class="line"><span class="number">28</span>) <span class="string">"532439"</span></span><br><span class="line"><span class="number">29</span>) <span class="string">"config-epoch"</span></span><br><span class="line"><span class="number">30</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">31</span>) <span class="string">"num-slaves"</span></span><br><span class="line"><span class="number">32</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">33</span>) <span class="string">"num-other-sentinels"</span></span><br><span class="line"><span class="number">34</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">35</span>) <span class="string">"quorum"</span></span><br><span class="line"><span class="number">36</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">37</span>) <span class="string">"failover-timeout"</span></span><br><span class="line"><span class="number">38</span>) <span class="string">"60000"</span></span><br><span class="line"><span class="number">39</span>) <span class="string">"parallel-syncs"</span></span><br><span class="line"><span class="number">40</span>) <span class="string">"1"</span></span><br></pre></td></tr></table></figure>
<p>像你所见的，它打印了主节点的一些信息。有几个是我们特别有兴趣的：</p>
<ol>
<li>num-other-sentinels 是 2，所以我们知道对于这个主节点 Sentinel 已经发现了两个以上的 Sentinels。如果你检查日志，你可以看到+sentinel 事件发生。</li>
<li>flags 是 master。如果主节点挂掉了，我们可以看到 s_down 或者 o_down 标志。</li>
<li>num-slaves 现在是 1，所以 Sentinel 发现有一个从节点。</li>
</ol>
<p>为了探测关于这个实例更多的信息，你可以尝试下面的两个命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL slaves mymaster</span><br><span class="line">SENTINEL sentinels mymaster</span><br></pre></td></tr></table></figure>
<p>第一个将提供关于从节点类似的信息，第二个是关于另外的 Sentinels。</p>
<h3 id="获取当前主节点的地址"><a href="#获取当前主节点的地址" class="headerlink" title="获取当前主节点的地址"></a>获取当前主节点的地址</h3><p>Sentinel 也作为一个配置提供者，提供给客户端它们想连接的主节点和从节点的集群。因为可能的故障转移和重配置，客户端不知道一个集群实例内当前的活着的主节点，所以 Sentinel 提供了一个 API：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>&gt; SENTINEL get-master-addr-by-name mymaster</span><br><span class="line"><span class="number">1</span>) <span class="string">"127.0.0.1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"6379"</span></span><br></pre></td></tr></table></figure>
<h3 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h3><p>现在我们部署 Sentinel 可以被测试了。我们可以杀死主节点然后查看配置变化。做我们可以做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 DEBUG sleep 30</span><br></pre></td></tr></table></figure>
<p>这个命令让我们的主节点变为不可达，睡眠 30 秒，它基本上模拟了主节点挂掉的一些原因。</p>
<p>如果你检查 Sentinel 的日志，你应该能看到许多动作：</p>
<ol>
<li>每个 Sentinel 发现了主节点挂掉了并有一个+sdown 事件</li>
<li>这个事件稍候升级到+odown，意味着大多数 Sentinel 已经同意了主节点是不可达的。</li>
<li>Sentinels 开始投票一个 Sentinel 开始并尝试故障转移</li>
<li>故障转移开始</li>
</ol>
<p>如果你重新询问 mymaster 的当前主节点的地址，这次我们会得到一个不同的回复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:5000&gt; SENTINEL get-master-addr-by-name mymaster</span><br><span class="line">1) &quot;127.0.0.1&quot;</span><br><span class="line">2) &quot;6380&quot;</span><br></pre></td></tr></table></figure>
<p>目前为止一切都很顺利，现在你可以创建你自己的 Sentinel 部署或者阅读更多来理解 Sentinel 的命令和内部原理。</p>
<h2 id="Sentinel-API"><a href="#Sentinel-API" class="headerlink" title="Sentinel API"></a>Sentinel API</h2><p>Sentinel 提供了一个 API，可以用来检查它的状态，检查主节点和从节点的健康，订阅具体的通知并在运行时改变 Sentinel 的配置。</p>
<p>默认情况下 Sentinel 使用 TCP 端口号 26379。Sentinels 接收使用 Redis 的协议命令，所以你可以使用 redis-cli 或者其他未修改的 Redis 客户端来和 Sentinel 交流。</p>
<p>直接查询一个 Sentinel 来检查所监控的 Redis 实例的状态，看看另外的 Sentinels 所知道是可能的。有两种方式，使用发布/订阅，每当一些事件发生，比如说一次故障转移，或一个实例发生错误等，都可能接收到一个从 Sentinels 推送过来的通知。</p>
<h3 id="Sentinel-命令"><a href="#Sentinel-命令" class="headerlink" title="Sentinel 命令"></a>Sentinel 命令</h3><p>下面是可以接收的命令列表，没有覆盖到那些用来改变 Sentinel 配置的命令：</p>
<ul>
<li>PING 这个命令仅仅返回 PONG。</li>
<li>SENTINEL masters 展示监控的主节点和它们的状态列表</li>
<li>SENTINEL master <master name> 展示指定的主节点的信息</master></li>
<li>SENTINEL salves <master name> 展示这个主节点的从节点，以及它们的状态</master></li>
<li>SENTINEL sentinels <master name> 展示这个主节点的 sentinel 实例，以及它们的状态</master></li>
<li>SENTINEL get-master-addr-by-name <master name> 返回主节点的 IP 和端口号。如果这个主节点的一次故障转移正在进行，就返回提升的从节点的 IP 和端口号</master></li>
<li>SENTINEL reset <pattern> 这个命令将会根据匹配的名称重置主节点，pattern 参数是通配符（glob-style）类型，重置进程清除主节点中之前的所有状态，并且移除主节点发现和关联的从节点和 sentinel。</pattern></li>
<li>SENTINEL failover <master name> 如果主节点不可达，强制开始故障转移，不需要另外的 Sentinels 同意。</master></li>
<li>SENTINEL ckquorum <master name> 检查当前的 Sentinel 配置对于主节点的故障转移是否能达到仲裁人数，并且大多数是需要的来授权故障转移。这个命令应该在监控系统中使用来检查一个 Sentinel 部署是否正常。</master></li>
<li>SENTINEL flushconfig 强制 Sentinel 重新写入它的配置到磁盘上，包括当前 Sentinel 状态。通常，每次当它状态里的一些东西改变，Sentinel 就会重写配置信息。然而有时候配置文件会丢失，由于错误的操作、磁盘故障、包升级脚本、或配置管理。在那种情况下，强制 Sentinel 重写它的配置文件是容易的。甚至之前的配置文件完全丢失，这个命令也能很好的工作。</li>
</ul>
<h3 id="运行时重新配置-Sentinel"><a href="#运行时重新配置-Sentinel" class="headerlink" title="运行时重新配置 Sentinel"></a>运行时重新配置 Sentinel</h3><p>从 Redis 2.8.4 开始，Sentinel 提供了一个 API 为了增加、移除或者改变一个给定的主节点的配置。注意如果你有多个 sentinels，为了工作正常，你应该改变所有的 Redis Sentinel 实例。这意味着改变单个 Sentinel 的配置不会把变化发送给在网络中另外的 Sentinels.</p>
<p>下面是 SENTINEL 自命令列表，用来更新一个 Sentinel 实例的配置：</p>
<ul>
<li>SENTINEL MONITOR <name> <ip> <port> <quorum> 这个命令告诉 Sentinel 开始监控一个指定名称、IP、端口号、quorum 的主节点，它和 sentinel.conf 配置文件中的 sentinel monitor 配置指令是完全相同的，不同的是这里不能使用主机名作为 IP，需要提供一个 IPV4 或 IPV6 地址。</quorum></port></ip></name></li>
<li>SENTINEL REMOVE <name> 用来移除指定的主节点：主节点不再被监控，并且将被从 Sentinel 的内部状态中被完全移除，所以不会被 SENTINEL masters 列出。</name></li>
<li>SENTINEL SET <name> <option> <value> SET 命令和 Reids 的 CONFIG SET 指令非常相似，被用来改变一个指定主节点的配置参数。多个选项-值可以被指定。所有通过 sentinel.conf 配置的参数可以使用 SET 命令重新配置。</value></option></name></li>
</ul>
<p>下面是 SENTINEL SET 命令的一个例子，为了修改一个名为 objects-cache 的主节点的 down-after-milliseconds 配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL SET objects-cache-master down-after-milliseconds 1000</span><br></pre></td></tr></table></figure>
<p>正如我们提到的，SENTINEL SET 可以被用来设置所有的在启动配置文件中被设置的参数。而且，还可以仅仅改变主节点的 quorum 配置，而不需要使用 SENTINEL REMOVE 和 SENTINEL MONITOR 来删除或者增加主节点，只需要使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL SET objects-cache-master quorum 5</span><br></pre></td></tr></table></figure>
<p>注意，没有等价的 GET 命令，因为 SENTINEL MASTER 以一种易于解析的格式提供了所有的配置参数。</p>
<h3 id="添加和移除-sentinels"><a href="#添加和移除-sentinels" class="headerlink" title="添加和移除 sentinels"></a>添加和移除 sentinels</h3><p>添加一个新的 sentinel 到你的部署中是很容易的一个过程，因为 Sentinel 有自动发现机制。所有的你需要做的事情是开启一个新的 Sentinel 来监控当前的主节点。10 秒过后，Sentinel 将获取到其他的 Sentinels 列表和当前主节点的从节点。</p>
<p>如果你想一次性增加多个 Sentinels，建议你一个接一个的增加，等所有的 Sentinels 已经知道第一个再添加另一个。在添加的新的 Sentinels 过程中错误有可能发生，在这时候保证在一次网络分区内中大部分是可用是很有用的。</p>
<p>在没有网络分区时，通过在 30 秒后增加每个新的节点，这是很容易实现的。</p>
<p>最后，可以使用 SENTINEL MASTER mastername 命令来检查是否全部 Sentinels 都同意了监控主节点的 Sentinels 的总数。</p>
<p>移除一个 Sentinel 稍微复杂一点：Sentinels 永远不会忘记已经看到的 Sentinels，甚至他们在相当长的一段时间内不可达，因为我们不想动态的改变授权一次故障转移和创建新的配置所需要的大多数。在没有网络分区的说话，需要执行下面的步骤来移除一个 Sentinel：</p>
<ol>
<li>停止你想要移除的 Sentinel 的进程</li>
<li>发送一个 SENTINEL RESET * 命令到其他的 Sentinel 实例，相继的，两次发送到实例之间至少等待 30 秒</li>
<li>检查所有的 Sentinels 赞同的当前存活的 Sentinels 的数量，通过检查每个 SENTINEL MASTER mastername 的输出。</li>
</ol>
<h3 id="移除旧的主节点或不可达的从节点"><a href="#移除旧的主节点或不可达的从节点" class="headerlink" title="移除旧的主节点或不可达的从节点"></a>移除旧的主节点或不可达的从节点</h3><p>Sentinels 永远不会忘记一个主节点的从节点，甚至当他们很长时间都不可达。这是很有用的，因为在一次网络分区或失败事件发生后，Sentinels 应该能正确地重新配置一个返回的从节点。</p>
<p>而且，在故障转移发生之后，被故障转移的主节点实际上被添加为新的主节点的从节点，一旦它可用的时候，这种方式将重新配置来复制新的主节点。</p>
<p>然而有时候你想从 Sentinels 监控的从节点列表中永久的移除一个从节点。</p>
<p>为了做这件事，你需要发送一个 SENTINEL RESET mastername 命令给所有的 Sentinels：它们将在十秒后刷新从节点列表，只添加当前主节点的 INFO 输出中正确的复制列表。</p>
<h3 id="发布-订阅消息"><a href="#发布-订阅消息" class="headerlink" title="发布/订阅消息"></a>发布/订阅消息</h3><p>一个客户端能使用一个 Sentinel 作为一个 Redis 兼容的发布/订阅服务器，为了 SUBSCRIBE 或者 PSUBSCRIBE 到指定频道，获取指定事件通知。</p>
<p>频道的名称和事件的名称是一样的。比如说名称为+sdown 的频道将收到所有的关于实例进入 SDOWN 条件的通知。</p>
<p>使用 PSUBSCRIBE * 订阅来获取所有的消息。</p>
<p>下面是一个频道列表，以及使用 API，你可以接收到的消息格式。第一个词是频道/事件名称，剩余部分是数据格式。</p>
<p>注意，指定 instance details 的地方意味着提供了下面的参数用于表示目标实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;</span><br></pre></td></tr></table></figure>
<p>标识主节点的部分（从@开始到结束）是可选的，只有实例本身不是主节点的时指定。</p>
<ul>
<li>+reset-master <instance details> — 主节点被重置。</instance></li>
<li>+slave <instance details> — 一个新的从节点被发现和关联。</instance></li>
<li>+failover-state-reconf-slaves <instance details> — 故障转移状态被转换为 reconf-slaves 状态。</instance></li>
<li>+failover-detected <instance details> — 另一个 Sentinel 开始了故障转移或者其他的外部实体被发现（一个关联的从节点变为主节点）。</instance></li>
<li>+slave-reconf-sent <instance details> — 为了给新的从节点重新配置，sentinel 中的 leader 发送 SLAVEOF 命令到这个实例。</instance></li>
<li>+slave-reconf-inprog <instance details> –从节点被重新配置展示一个主节点的从节点，但是同步过程尚未完成。</instance></li>
<li>+slave-reconf-done <instance details> — 从节点现在和主节点是同步的。</instance></li>
<li>-dup-sentinel <instance details> –指定的主节点，一个或者多个 sentinels 被 移除，因为是重复的。</instance></li>
<li>+sentinel <instance details> — 这个主节点的一个新的 sentinel 被发现和关联。</instance></li>
<li>+sdown <instance details> — 指定的实例现在处于主观下线状态。</instance></li>
<li>-sdown <instance details> — 指定的实例不再处于主观下线状态。</instance></li>
<li>+odown <instance details> — 指定的实例现在处于客观下线状态。</instance></li>
<li>-odown <instance details> — 指定的实例现在不处于客观下线状态。</instance></li>
<li>+new-epoch <instance details> — 当前时间被更新。</instance></li>
<li>+try-failover <instance details> — 准备新的故障转移，等待大多数的选举。</instance></li>
<li>+elected-leader <instance details> — 赢得了选举，开始故障转移。</instance></li>
<li>+failover-state-select-slave <instance details> — 新的故障转移状态是 select-slave：我们 正在寻找合适提升为主节点的从节点。</instance></li>
<li>no-good-slave <instance details> — 没有合适进行提升的从节点。一般会在稍后重试，但是这或许会改变并且终止故障转移。</instance></li>
<li>selected-slave <instance details> — 我们找到了指定的从节点来进行提升。</instance></li>
<li>failover-state-send-slaveof-noone <instance details> — 我们尝试重新配置这个提升后的主节点，等待它切换。</instance></li>
<li>failover-end-for-timeout <instance details> — 故障转移由于超时而停止，无论如何从节点最后被配置为复制新的主节点。</instance></li>
<li>failover-end <instance details> — 故障转移由于成功而停止，所有的从节点被配置为复制新的主节点。</instance></li>
<li>switch-master <master name> <oldip> <oldport> <newip> <newport> — 配置改变后，主节点新的 IP 和地址都是指定的。这是大多数外部用户感兴趣的消息。</newport></newip></oldport></oldip></master></li>
<li>+tilt — 进入 Tilt 模式。</li>
<li>-tilt — 退出 Tilt 模式。</li>
</ul>
<h3 id="BUSY-状态的处理"><a href="#BUSY-状态的处理" class="headerlink" title="BUSY 状态的处理"></a>BUSY 状态的处理</h3><p>当一个 Lua 脚本的运行时间超过了配置中指定的 Lua 脚本时间限制，Redis 实例将返回 -BUSY 错误。当这个发生的时候，在触发故障转移之前 Redis Sentinel 将尝试发送 SCRIPT KILL 命令，如果脚本是只读的，就会成功。</p>
<p>如果在这个尝试后，实例仍然处于失败情况，它最后会开始故障转移。</p>
<h4 id="从节点优先"><a href="#从节点优先" class="headerlink" title="从节点优先"></a>从节点优先</h4><p>Redis 实例有个配置参数叫 slave-priority。这个信息在 Redis 从节点实例的 INFO 输出中展示出来，并且 Sentinel 使用它来选择一个从节点在一次故障转移中：</p>
<ol>
<li>如果从节点的优先级被设置为 0，这个从节点永远不会被提升为主节点。</li>
<li>Sentinel 首选一个由更低（ lower）优先级的从节点。</li>
</ol>
<p>比如在当前主节点的同一个数据中心有一个从节点 S1，并且有另外的从节点 S2 在另外的数据中心，可以将 S1 优先级设置为 10，S2 优先级设置为 100，如果主节点挂掉了并且 S1 和 S2 都是可用的，S1 将是首选的。</p>
<p>查看关于从节点选举的更多信息，请查看本文章的 slave selection and priority 章节。</p>
<h4 id="Sentinel-和-Redis-权限"><a href="#Sentinel-和-Redis-权限" class="headerlink" title="Sentinel 和 Redis 权限"></a>Sentinel 和 Redis 权限</h4><p>当主节点被配置为从客户端需要密码，作为一个安全措施，从节点也需要知道这个密码为了主节点认证并且创建主-从连接用于异步复制协议。</p>
<p>使用下列的配置选项来实现：</p>
<ul>
<li>requirepass 在主节点中，为了设置认证密码，并且确保实例不会处理来自没有认证的客户端的请求。</li>
<li>masterauth 在从节点中，为了取得主节点的认证，来从主节点正确的复制 数据。</li>
</ul>
<p>当 Sentinel 使用的时候，没有一个单独的主节点，因为一次故障转移过后，从节点将扮演主节点的角色，并且老的主节点被重新配置作为一个从节点，所以你要做的是在全部的实例中设置上面的选项，包括主节点和从节点。</p>
<p>这通常是一个理智的设置，因为你不想要仅仅在主节点中保护你的数据，在从节点中有同样的数据。</p>
<p>然而，在罕见的情况下，你需要一个从节点是可进入的而不需要认证，你可以设置一个优先级为 0 的从节点来实现，阻止这个从节点被提升为主节点，配置这个从节点的 masterauth 选项，不要使用 requirepass 选项，以便数据可以被读在没有认证的情况下。</p>
<h4 id="Sentinel-客户端实现"><a href="#Sentinel-客户端实现" class="headerlink" title="Sentinel 客户端实现"></a>Sentinel 客户端实现</h4><p>Sentinel 需要显式的客户端支持，除非系统配置为执行脚本来执行一个透明的重定向对于所有的主节点实例的请求（虚拟 IP 或类似的系统）。可以参考文档 Sentinel clients guidelines。</p>
<h2 id="更高级的概念"><a href="#更高级的概念" class="headerlink" title="更高级的概念"></a>更高级的概念</h2><p>下面的章节是关于 Sentinel 怎么工作的一些细节，没有付诸于实现的想法和算法在文章的最后章节。</p>
<h3 id="SDOWN-和-ODOWN-失败状态"><a href="#SDOWN-和-ODOWN-失败状态" class="headerlink" title="SDOWN 和 ODOWN 失败状态"></a>SDOWN 和 ODOWN 失败状态</h3><p>Redis Sentine 有两个不同概念的下线，一个被称为主观下线（Subjectively Down ）条件（SDOWN），是一个本地 Sentinel 实例下线条件。另一个被称为客观下线（Objectively Down ）条件（ODOWN），是当足够的 Sentinels 具有 SDOWN 条件就满足 ODOWN，并且从其他的 Sentinels 使用 SENTINEL is-master-down-by-addr 命令得到反馈。</p>
<p>从一个 Sentinel 的角度来看，满足一个 SDOWN 条件就是在指定的时间内对于 PING 请求不能收到有效的回复，这个时间在配置文件中是 is-master-down-after-milliseconds 参数。</p>
<p>一个 PING 请求可接受的回复是下列之一：</p>
<p>回复+PONG。<br>回复 -LOADING 错误。<br>回复-MASTERDOWN 错误。<br>其他的回复（或根本没有回复）被认为是无效的。注意一个合理的主节点在 INFO 输出中通知他自己是一个从节点被认为是下线的。</p>
<p>注意 SDOWN 需要在配置中整个的时间间隔都没有收到有效的回复，因此对于实例如果时间间隔是 30000 毫秒，并且我们每隔 29 秒收到有效的回复，这个实例就被认为在工作。</p>
<p>SDOWN 还不够触发故障转移：它仅仅意味着一个单独的 Sentinel 相信一个 Redis 实例不可达。要触发故障转移，必须达到 ODOWN 状态。</p>
<p>从 SDOWN 转换到 ODOWN，没有使用强一致性算法，而仅仅是 gossip 的形式：如果一个 Sentinel 在一个给定的时间范围内从足够的 Sentinels 得到一个报告说一个主节点没有在工作，SDOWN 被提升为 ODOWN。如果这个确认稍候消失，这个标识也会清除。</p>
<p>一个更加严格的授权是使用大多数需要为了真正的开始故障转移，但是在达到 ODOWN 状态之前不会触发故障转移。</p>
<p>ODOWN 条件只适用于主节点。对于其他类型的实例，Sentinel 不需要采取行动，所以对于从节点和其他的 sentinels 来说 ODOWN 状态永远不可能达到，而仅仅只有 SDOWN 状态。</p>
<p>然而 SDOWN 也有语义的影响，比如一个从节点在 SDOWN 状态不会被选举来提升来执行一个故障转移。</p>
<h3 id="Sentinels-和从节点自动发现"><a href="#Sentinels-和从节点自动发现" class="headerlink" title="Sentinels 和从节点自动发现"></a>Sentinels 和从节点自动发现</h3><p>Sentinels 和其他的 Sentinels 保持连接为了互相之间检查是否可达和交换消息。然而你不需要在每个运行的 Sentinel 实例中配置其他的 Sentinel 地址列表，Sentinel 使用 Redis 实例的发布/订阅能力来发现其他的监控相同的主节点和从节点的 Sentinels。</p>
<p>通过往名称为<strong>sentinel</strong>:hello 的通道发送 hello 消息（hello messages）来实现这个特性。</p>
<p>同样的，你不需要配置一个主节点关联的从节点的列表，Sentinel 也会自动发现这个列表通过问询 Redis：</p>
<ul>
<li>每隔两秒，每个 Sentinel 向每个监控的主节点和从节点的发布/订阅通道<strong>sentinel</strong>:hello 来公布一个消息，宣布它自己的 IP，端口，id。</li>
<li>每个 Sentinel 都订阅每个主节点和从节点的发布/订阅通道<strong>sentinel</strong>:hello，寻找未知的 sentinels。当新的 sentinels 被检测到，他们增加这个主节点的 sentinels。</li>
<li>Hello 消息也包含主节点的全部配置信息，如果接收的 Sentinel 有一个更旧的配置，它会立即更新它的配置。</li>
<li>在增加一个主节点的新的 sentinel 之前，Sentinel 总是要检查是否已经有一个有相同的 id、地址的 sentinel。在这种情况下，所有匹配的 sentinels 被移除，新的被增加。</li>
</ul>
<h3 id="故障转移之外重新配置"><a href="#故障转移之外重新配置" class="headerlink" title="故障转移之外重新配置"></a>故障转移之外重新配置</h3><p>即使没有故障转移，Sentinels 将尝试设置当前的配置到监控的实例上面。</p>
<p>特别的：</p>
<ul>
<li>从节点声称为主节点，将被作为从节点配置来复制当前的主节点。</li>
<li>从节点连接了一个错误的主节点，也会被重新配置来复制正确的主节点。</li>
</ul>
<p>Sentinels 重新配置从节点，错误的配置在一段时间内应该被观察到，比在广播新的配置的时候要好得多。</p>
<p>这个阻止了有一个过时配置（比如说从一个分区中重新加入）的 Sentinels 在收到更新之前去交换从节点的配置。</p>
<p>同样注意：</p>
<ul>
<li>主节点的故障转移被重新配置作为从节点当他们返回可用的时候</li>
<li>在一个网络分区中，从节点一旦可达，被重新配置。</li>
</ul>
<p>本章最重要的教训就是：Sentinels 是每个进程总是尝试去把最后的配置施加到监控的实例上的一个系统。</p>
<h3 id="从节点选举和优先级"><a href="#从节点选举和优先级" class="headerlink" title="从节点选举和优先级"></a>从节点选举和优先级</h3><p>当一个 Sentinel 实例准备执行故障转移，因为主节点在 ODOWN 状态下并且 Sentinel 从大多数已知的 Sentinel 实例中收到了授权开始故障转移，一个合适的从节点要被选举出来。</p>
<p>从节点选举过程评估从节点的下列信息：</p>
<ol>
<li>与主节点断开的时间</li>
<li>从节点优先级</li>
<li>复制偏移处理</li>
<li>运行 ID</li>
</ol>
<p>一个从节点被发现从主节点断开超过主节点配置超时（down-after-milliseconds 选项）时间十倍以上，加上从正在执行故障转移的 Sentinel 的角度看主节点不可用的时间，将被认为是不合适的并且会被跳过。</p>
<p>在更严格的条件下，一个从节点的 INFO 输出建议了从主节点断开超过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds \* 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure>
<p>被认为是不可靠的并且会被无视。</p>
<p>从节点选举只会考虑通过了上述测试的从节点，并根据上面的条件进行排序，以下列顺序：</p>
<ol>
<li>根据 Redis 实例中的 redis.conf 文件中配置的 slave-priority 进行排序，更低的优先级会被优先。</li>
<li>如果优先级相同，检查复制偏移处理，从主节点收到更加新的数据的从节点会被选择。</li>
<li>如果多个从节点有相同的优先级和数据偏移，执行进一步检查，选择有着更小运行 ID 的从节点。有一个更小的 ID 并不是具有正真的优点，但是对于从节点选举来说更确定，而不是随机选择一个从节点。</li>
</ol>
<p>如果有机器是首选，Redis 主节点、从节点必须被配置一个 slave-priority。否则，所有的实例都有一个默认的 ID。</p>
<p>一个 Redis 实例可以被配置指定 slave-priority 为 0 为了永远不被 Sentinels 选择为新的主节点。然而一个这样配置的从节点会被 Sentinels 重新配置，为了在一次故障转移后复制新的主节点，唯一不同的是，它永远不会成为主节点。</p>
<h2 id="算法和内部结构"><a href="#算法和内部结构" class="headerlink" title="算法和内部结构"></a>算法和内部结构</h2><p>下面的章节，我们将会探索 Sentinel 特性的细节。对于使用者来说，并不需要知道全部的细节，但是一个更深入的理解可能会帮助部署和操作 Sentinel 以一个更加有效的方式。</p>
<h3 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h3><p>前面的章节展示了每个被 Sentinel 监控的主节点和一个配置的 quorum 相关联。它指定了需要同意主节点是不可达或者错误的 Sentinel 进程的数量为了触发一次故障转移。</p>
<p>可是，在故障转移触发后，为了真正地执行故障转移，至少大多数的 Sentinels 必须授权一个 Sentinel 开始故障转移。当只有小部分的 Sentinels 存在的一个网络分区中，故障转移永远不会执行。</p>
<p>我们尝试让这件事更加清晰：</p>
<ul>
<li>Quorum：为了把一个主节点标记成 ODOWN，需要的 Sentinel 进程数量来发现错误条件。</li>
<li>ODOWN 状态触发故障转移。</li>
<li>一旦故障转移被触发，Sentinel 尝试向大多数的 Sentinels 请求授权。</li>
</ul>
<p>不同之处看起来很微妙，但是实际上很简单地理解和使用。如果你又 5 个 Sentinel 实例，quorum 被设置为 2，一旦 2 个 Sentinel 认为主节点不可达，故障转移就会被触发。然而 2 个 Sentinels 中的一个得到 3 个 Sentinels 的授权才开始故障转移。</p>
<p>把 quorum 设置为 5，必须所有的 Sentinels 同意主节点失败，并为了开始故障转移，需要得到所有 Sentinels 的授权。</p>
<p>这意味着 quorum 在两方面可以被用来调整 Sentinel：</p>
<ul>
<li>如果 quorum 被设置为小于我们部署的 Sentinels 大多数，我们使 Sentinel 对主节点失败更加敏感，并一旦少数的 Sentinels 不再和主节点交流就会触发故障转移。</li>
<li>如果 quorum 被设置为大于我们部署的 Sentinels 大多数，仅仅当大多数连接良好的 Sentinels 同意主节点挂掉的时候，Sentinel 才能开始故障转移。</li>
</ul>
<h3 id="配置-epochs"><a href="#配置-epochs" class="headerlink" title="配置 epochs"></a>配置 epochs</h3><p>为了开始故障转移，Sentinels 需要从大多数得到授权，有下面几个重要的原因：</p>
<p>当一个 Sentinel 被授权，它为故障转移的主节点获得一个独一无二的配置 epoch。这将用来标识新的配置的版本在故障转移完成之后。因为大多数同意一个版本被分配给指定的 Sentinel，没有其他的 Sentinel 可以使用它。这意味着，每次故障转移的配置都有一个独一无二的版本号。我们将看到这为什么是很重要的。</p>
<p>此外 Sentinels 有一个规则：如果一个 Sentinel 投票给其他的 Sentinel 在一次故障转移中，它将等待一段时间再次尝试故障转移这个主节点，你可以在 sentinel.conf 中配置这个延迟时间 failover-timeout。这意味着 Sentinels 在相同的时间内不会尝试故障转移相同的主节点，第一次请求授权的将会尝试，如果失败了，另一个将会在一段时间后尝试，等等。</p>
<p>Redis Sentinel 保证了活性（liveness）性质，如果大多数 Sentinels 能够交流。如果主节点挂了，最后将有一个会被授权开始故障转移。</p>
<p>Redis Sentinel 同样也保证了安全（safety ）性质，每个 Sentinel 将使用不同的配置 epoch（configuration epoch）来故障转移同一个主节点。</p>
<h3 id="配置传播"><a href="#配置传播" class="headerlink" title="配置传播"></a>配置传播</h3><p>一旦一个 Sentinel 能成功的故障转移一个主节点，它将开始广播新的配置以便其他的 Sentinels 更新他们关于主节点的信息。</p>
<p>为了认定一次故障转移是成功的，它需要 Sentinel 能发送 SLAVEOF NO ONE 指令给选举的从节点，并且切换为主节点，稍后能在主节点的 INFO 输出中观察到。</p>
<p>这时候，即使从节点的重新配置正在进行，故障转移也被认为是成功的，并且所有的 Sentinels 需要开始报告新的配置。</p>
<p>一个新的配置广播的方式，就是为什么我们需要每次 Sentinel 被授权故障转移时有一个不同的版本号的原因。</p>
<p>每个 Sentinel 使用 Redis 发布/订阅消息来连续不断的广播它的一个主节点的配置的版本号，所有的从节点和主节点。同时，所有的 Sentinels 等待消息来查看其他的 Sentinels 广播的配置。</p>
<p>配置在<strong>sentinel</strong>:hello 发布/订阅频道中被广播。</p>
<p>因为每个配置都有一个不同的版本号，大的版本号总是赢得小的版本号。</p>
<p>例如 一开始所有的 Sentinels 认为主节点 mymaster 的配置为 192.168.1.50:6379。这个配置的版本号为 1。一段时间后，一个被授权开始故障转移有版本号 2，如果故障转移成功，它将广播新的配置，它说是 192.168.1.50:9000，版本号为 2,。所有其他的实例将看到这个配置并更新他们的配置，因为新的配置有更高的版本号。</p>
<p>这意味着 Sentinel 保证第二个活性属性：一个 Sentinels 集合能互相交流并且把配置信息收敛到一个更高的版本号。</p>
<p>基本上，如果网络是分区的，每个分区将收敛到一个更高的本地配置。没有网络分区的特殊性情况下，只有一个分区并且每个 Sentinel 将同意配置。</p>
<p>分区下的一致性</p>
<p>Redis Sentinel 配置是最终一致的，所以每个分区将收敛到更高的可用的配置。然而在使用 Sentinel 的真实世界的系统中，有三个不同的角色：</p>
<ul>
<li>Redis 实例</li>
<li>Sentinel 实例</li>
<li>客户端</li>
</ul>
<p>为了定义系统的行为，我们考虑所有的三种。</p>
<p>下面是一个简单的有三个节点的网络，每个都运行一个 Redis 实例和一个 Sentinel 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            +-------------+</span><br><span class="line">            | Sentinel 1  |----- Client A</span><br><span class="line">            | Redis 1 (M) |</span><br><span class="line">            +-------------+</span><br><span class="line">                    |</span><br><span class="line">                    |</span><br><span class="line">+-------------+     |          +------------+</span><br><span class="line">| Sentinel 2  |-----+-- // ----| Sentinel 3 |----- Client B</span><br><span class="line">| Redis 2 (S) |                | Redis 3 (M)|</span><br><span class="line">+-------------+                +------------+</span><br></pre></td></tr></table></figure>
<p>在这个系统中，原始状态是 Redis3 是主节点，Redis1 和 Redis2 是从节点。一个网络分区发生隔离了旧的主节点。Sentinels1 和 2 开始一个故障转移过程提升 Sentinel 1 为新的主节点。</p>
<p>Sentinel 的属性保证 Sentinel 1 和 2 现在有了一个主节点的新的配置。可是 Sentinel 3 依然有旧的配置因为它在一个不同的分区中存活。</p>
<p>我们知道 Sentinel 3 将得到他的配置更新当网络分区治愈的时候，但是如果有客户端和旧的主节点在一起，分区时会发生什么呢？</p>
<p>客户端仍然可以向 Redis 3 写入数据。当网络分区治愈，Redis 3 变成 Reids 1 的一个从节点，在分区期间写入的数据都会丢失。</p>
<p>根据你的配置，你可以想或不想让这种情况发生：</p>
<ul>
<li>如果你使用 Redis 作为缓存，客户端 B 仍然可以向旧的主节点写入数据是很方便的，即使数据将会丢失。</li>
<li>如果你使用 Redis 作为存储，这是不好的，你需要配置系统为了部分的阻止这个问题。</li>
</ul>
<p>因为 Redis 是异步复制的，这种情况下，没有办法完全阻止数据丢失，但是你可以使用下面的 Redis 配置选项来限制 Redis 3 和 Redis 1 之间的分歧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>
<p>当一个 Redis 有上面的配置，当作为主节点的时候，如果他不能向至少一个从节点写入数据，将会停止接受写入请求。因为复制是异步的，不能写（not being able to write ）意味着从节点都是分离的，或者没有发送异步确认超过了指定的 max-lag 的时间。</p>
<p>使用这个配置，上面的例子中的 Redis 3 将会在 10 秒之后变得不可用。当分区治愈，Sentinel 3 的配置将会是新的，Client B 能获取到一个有效的配置并继续工作。</p>
<p>总之， Redis + Sentinel 是一个最终一致性系统（ eventually consistent system），功能是最后一个故障转移获胜（ last failover wins）。旧节点中的数据会被丢弃，从当前主节点复制数据，所以总有一个丢失确认写的窗口。这是由于 Redis 的异步复制和系统的“虚拟”合并功能的丢弃性质。注意，Sentinel 本身没有限制，如果你把故障转移编排起来，相同的属性仍然适用，仅仅有两种方式来避免丢失写入确认：</p>
<p>使用同步复制<br>使用一个最终一致的系统，相同物体的不同版本能被合并<br>Redis 现在不能使用上面的任何系统，是目前的发展目标。可是有一个代理实现解决方案 2 在 Redis 存储之上，比如说 SoundCloud Roshi，或者 Netflix Dynomite。</p>
<h3 id="Sentinel-持久化状态"><a href="#Sentinel-持久化状态" class="headerlink" title="Sentinel 持久化状态"></a>Sentinel 持久化状态</h3><p>Sentinel 状态保存在 sentinel 配置文件中。例如，每次一个收到一个新的配置，主节点，配置和配置 epoch 一起被保存在磁盘上。这意味着停止和重启 Sentinel 进程是很安全的。</p>
<h3 id="TILT-模式"><a href="#TILT-模式" class="headerlink" title="TILT 模式"></a>TILT 模式</h3><p>Redis Sentinel 严重依赖电脑时间：例如为了推断一个实例是否可达，它会记住最后一次成功回复 PING 命令的时间，并和当前时间比较来推断哪个是旧的。</p>
<p>可是，如果电脑时间意外改变了，或者电脑非常繁忙，或进程由于某些原因阻塞。Sentinel 或许开始表现意外的行为。</p>
<p>TILT 模式是一个特殊的“保护”模式，当发现奇怪的事情可能降低系统的可靠性，一个 Sentinel 可以进入这个模式。Sentinel 定时中断调用每秒 10 次，所以我们期待定时中断调用之间间隔 100 毫米左右。</p>
<p>Sentinel 所做的就是登记之前的中断调用时间，并和当前的调用时间比较：如果结果是负数或意外的数，将会进入 TILT 模式。</p>
<p>当处于 Sentinel 模式 Sentinel 将会继续监控每件事，但是：</p>
<ul>
<li>停止一切动作</li>
<li>开始回复负数给 SENTINEL is-master-down-by-addr 请求让检测失败不再有信</li>
<li>如果 30 秒内每件事都表现正常，将退出 TILT 模式。</li>
</ul>
<p>注意某些情况下，使用许多内核提供的单调时钟 API 代替 TILT 模式。可是它仍然是不清晰的如果这是一个很好的解决方案，因为在进程只是仅仅挂起或调度很长时间没有执行的情况下，当前的系统会避免这个问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/19/database/nosql/redis/Redis复制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/19/database/nosql/redis/Redis复制/" itemprop="url">Redis 复制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T00:00:00+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#redis-复制要点">Redis 复制要点</a></li>
<li><a href="#当主服务器不进行持久化时复制的安全性">当主服务器不进行持久化时复制的安全性</a></li>
<li><a href="#redis-主从复制是如何工作的">Redis 主从复制是如何工作的</a></li>
<li><a href="#部分重新同步">部分重新同步</a></li>
<li><a href="#无磁盘复制">无磁盘复制</a></li>
<li><a href="#配置">配置</a></li>
<li><a href="#只读从服务器">只读从服务器</a></li>
<li><a href="#设置从服务器到主服务器验证">设置从服务器到主服务器验证</a></li>
<li><a href="#限制有-n-个以上从服务器才允许写入">限制有 N 个以上从服务器才允许写入</a></li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="Redis-复制要点"><a href="#Redis-复制要点" class="headerlink" title="Redis 复制要点"></a>Redis 复制要点</h2><ul>
<li>Redis 使用异步复制。但从 Redis 2.8 开始，从服务器会周期性的应答从复制流中处理的数据量。</li>
<li>一个主服务器（master）可以有多个从服务器（slave）。</li>
<li>从服务器也可以接受其他从服务器的连接。除了多个从服务器连接到一个主服务器之外，多个从服务器也可以连接到一个从服务器上，形成一个图状结构</li>
<li>Redis 主从复制不阻塞主服务器端。也就是说当若干个从服务器在进行初始同步时，主服务器仍然可以处理请求。</li>
<li>主从复制也不阻塞从服务器端。当从服务器进行初始同步时，它使用旧版本的数据来应对查询请求，假设你在 redis.conf 配置文件是这么配置的。否则的话，你可以配置当复制流关闭时让从服务器给客户端返回一个错误。但是，当初始同步完成后，需要删除旧的数据集和加载新的数据集，在这个短暂的时间内，从服务器会阻塞连接进来的请求。</li>
<li>主从复制可以用来增强扩展性，使用多个从服务器来处理只读的请求（比如，繁重的排序操作可以放到从服务器去做），也可以简单的用来做数据冗余。</li>
<li>使用主从复制可以为主服务器免除把数据写入磁盘的消耗：在主服务器的 redis.conf 文件中配置“避免保存”（注释掉所有“保存“命令），然后连接一个配置为“进行保存”的从服务器即可。但是这个配置要确保主服务器不会自动重启（要获得更多信息请阅读下一段）</li>
</ul>
<h2 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h2><p>在使用 Redis 复制功能时的设置中，强烈建议在 master 和在 slave 中启用持久化。当不可能启用时，例如由于非常慢的磁盘性能而导致的延迟问题，<strong>应该配置实例来避免重置后自动重启</strong>。</p>
<p>关闭了持久化并配置了自动重启的 master 是危险的，原因如下：</p>
<ul>
<li>我们设置节点 A 为 master 并关闭它的持久化设置，节点 B 和 C 从 节点 A 复制数据。</li>
<li>节点 A 崩溃，但是他有一些自动重启的系统可以重启进程。但是由于持久化被关闭了，节点重启后其数据集合为空。</li>
<li>节点 B 和 节点 C 会从节点 A 复制数据，但是节点 A 的数据集是空的，因此复制的结果是它们会销毁自身之前的数据副本。</li>
</ul>
<p>当在高可用系统中使用 Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于 Sentinel 都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</p>
<p>如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p>
<h2 id="Redis-主从复制是如何工作的"><a href="#Redis-主从复制是如何工作的" class="headerlink" title="Redis 主从复制是如何工作的"></a>Redis 主从复制是如何工作的</h2><p>如果你设置了一个从服务器，在连接时它发送了一个 SYNC 命令，不管它是第一次连接还是再次连接都没有关系。</p>
<p>然后主服务器<strong>开始后台存储</strong>，并且开始缓存新连接进来的修改数据的命令。<strong>当后台存储完成后，主服务器把数据文件发送到从服务器，从服务器将其保存在磁盘上，然后加载到内存中</strong>。然后主服务器把刚才缓存的命令发送到从服务器。这是作为命令流来完成的，并且和 Redis 协议本身格式相同。</p>
<p>你可以通过 telnet 自己尝试一下。在 Redis 服务器工作时连接到 Redis 端口，发送 SYNC 命令，会看到一个批量的传输，并且主服务器接收的每一个命令都会通过 telnet 会话重新发送一遍。</p>
<p>当主从服务器之间的连接由于某些原因断开时，从服务器可以自动进行重连接。当有多个从服务器同时请求同步时，主服务器只进行一个后台存储。</p>
<p>当连接断开又重新连上之后，一般都会进行一个完整的重新同步，但是从 Redis2.8 开始，只重新同步一部分也可以。</p>
<h2 id="部分重新同步"><a href="#部分重新同步" class="headerlink" title="部分重新同步"></a>部分重新同步</h2><p>从 Redis 2.8 开始，如果遭遇连接断开，重新连接之后可以从中断处继续进行复制，而不必重新同步。</p>
<p>它的工作原理是这样，<strong>主服务器端为复制流维护一个内存缓冲区（in-memory backlog）。主从服务器都维护一个复制偏移量（replication offset）和 master run id ，当连接断开时，从服务器会重新连接上主服务器，然后请求继续复制，假如主从服务器的两个 master run id 相同，并且指定的偏移量在内存缓冲区中还有效，复制就会从上次中断的点开始继续</strong>。如果其中一个条件不满足，就会进行完全重新同步（在 2.8 版本之前就是直接进行完全重新同步）。因为主运行 id 不保存在磁盘中，如果从服务器重启了的话就只能进行完全同步了。</p>
<p>部分重新同步这个新特性内部使用 PSYNC 命令，旧的实现中使用 SYNC 命令。Redis2.8 版本可以检测出它所连接的服务器是否支持 PSYNC 命令，不支持的话使用 SYNC 命令。</p>
<h2 id="无磁盘复制"><a href="#无磁盘复制" class="headerlink" title="无磁盘复制"></a>无磁盘复制</h2><p>通常来讲，一个完全重新同步需要在磁盘上创建一个 RDB 文件，然后加载这个文件以便为从服务器发送数据。</p>
<p>如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力。Redis 从 2.8.18 版本开始尝试支持无磁盘的复制。使用这种设置时，子进程直接将 RDB 通过网络发送给从服务器，不使用磁盘作为中间存储。</p>
<p>这一特性目前只是实验性的。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>主从复制的配置十分简单：把下面这行加入到从服务器的配置文件中即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure>
<p>当然你需要把其中的 192.168.1.1 6379 替换为你自己的主服务器 IP（或者主机名 hostname）和端口。另外你可以调用 SLAVEOF 命令，主服务器就会开始与从服务器同步。</p>
<p>关于部分重新同步，还有一些针对复制内存缓冲区的优化参数。查看 Redis 介质中的 Redis.conf 示例获得更多信息。</p>
<p>使用 repl-diskless-sync 配置参数来启动无磁盘复制。使用 repl-diskless-sync-delay 参数来配置传输开始的延迟时间，以便等待更多的从服务器连接上来。查看 Redis 介质中的 Redis.conf 示例获得更多信息。</p>
<h2 id="只读从服务器"><a href="#只读从服务器" class="headerlink" title="只读从服务器"></a>只读从服务器</h2><p>从 Redis 2.6 开始，从服务器支持只读模式，并且是默认模式。这个行为是由 Redis.conf 文件中的 slave-read-only 参数控制的，可以在运行中通过 CONFIG SET 来启用或者禁用。</p>
<p>只读的从服务器会拒绝所有写命令，所以对从服务器不会有误写操作。但这不表示可以把从服务器实例暴露在危险的网络环境下，因为像 DEBUG 或者 CONFIG 这样的管理命令还是可以运行的。不过你可以通过使用 rename-command 命令来为这些命令改名来增加安全性。</p>
<p>你可能想知道为什么只读限制还可以被还原，使得从服务器还可以进行写操作。虽然当主从服务器进行重新同步或者从服务器重启后，这些写操作都会失效，还是有一些使用场景会想从服务器中写入临时数据的，但将来这个特性可能会被去掉。</p>
<h2 id="设置从服务器到主服务器验证"><a href="#设置从服务器到主服务器验证" class="headerlink" title="设置从服务器到主服务器验证"></a>设置从服务器到主服务器验证</h2><p>如果主服务器设置了密码，配置从服务器在所有同步中使用这个密码十分简单。</p>
<p>对于运行中的实例，使用 redis-cli 并输入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>config set masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要使配置永久生效，把如下命令加入到配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="限制有-N-个以上从服务器才允许写入"><a href="#限制有-N-个以上从服务器才允许写入" class="headerlink" title="限制有 N 个以上从服务器才允许写入"></a>限制有 N 个以上从服务器才允许写入</h2><p>从 Redis 2.8 版本开始，可以配置主服务器连接 N 个以上从服务器才允许对主服务器进行写操作。但是，因为 Redis 使用的是异步主从复制，没办法确保从服务器确实收到了要写入的数据，所以还是有一定的数据丢失的可能性。</p>
<p>这一特性的工作原理如下：</p>
<ul>
<li>从服务器每秒钟 ping 一次主服务器，确认处理的复制流数量。</li>
<li>主服务器记住每个从服务器最近一次 ping 的时间。</li>
<li>用户可以配置最少要有 N 个服务器有小于 M 秒的确认延迟。</li>
</ul>
<p>如果有 N 个以上从服务器，并且确认延迟小于 M 秒，主服务器接受写操作。</p>
<p>你可以把这看做是 CAP 原则（一致性，可用性，分区容错性）不严格的一致性实现，虽然不能百分百确保一致性，但至少保证了丢失的数据不会超过 M 秒内的数据量。</p>
<p>如果条件不满足，主服务器会拒绝写操作并返回一个错误。</p>
<ul>
<li>min-slaves-to-write（最小从服务器数）</li>
<li>min-slaves-max-lag（从服务器最大确认延迟）</li>
</ul>
<p>查看 Redis 介质中的 Redis.conf 示例获得更多信息。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="http://ifeve.com/redis-replication/" target="_blank" rel="noopener">http://ifeve.com/redis-replication/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/13/programming/java/javaweb/standalone/security/shiro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/13/programming/java/javaweb/standalone/security/shiro/" itemprop="url">Shiro</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T00:00:00+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><blockquote>
<p>Shiro 是一个安全框架，具有认证、授权、加密、会话管理功能。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#概述">概述</a><ul>
<li><a href="#shiro-功能">Shiro 功能</a></li>
<li><a href="#shiro-架构">Shiro 架构</a></li>
</ul>
</li>
<li><a href="#认证">认证</a></li>
<li><a href="#授权">授权</a></li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Shiro-功能"><a href="#Shiro-功能" class="headerlink" title="Shiro 功能"></a>Shiro 功能</h3><p align="center"><br>  <img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/standalone/security/shiro/shiro-features.png"><br></p>

<ul>
<li><strong>Authentication</strong> - 身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization</strong> - 授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li><strong>Session Manager</strong> - 会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</li>
<li><strong>Cryptography</strong> - 加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li><strong>Web Support</strong> - Web 支持，可以非常容易的集成到 Web 环境；</li>
<li><strong>Caching</strong> - 缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong> - shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong> - 提供测试支持；</li>
<li><strong>Run As</strong> - 允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong> - 记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<p>记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去提供；然后通过相应的接口注入给 Shiro 即可。</p>
<h3 id="Shiro-架构"><a href="#Shiro-架构" class="headerlink" title="Shiro 架构"></a>Shiro 架构</h3><p align="center"><br>  <img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/standalone/security/shiro/ShiroBasicArchitecture.png"><br></p>

<ul>
<li><strong>Subject</strong> - 主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</li>
<li><strong>SecurityManager</strong> - 安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</li>
<li><strong>Realm</strong> - 域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</li>
</ul>
<p align="center"><br>  <img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/standalone/security/shiro/ShiroArchitecture.png"><br></p>

<ul>
<li><strong>Subject</strong> - 主体，可以看到主体可以是任何可以与应用交互的“用户”；</li>
<li><strong>SecurityManager</strong> - 相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</li>
<li><strong>Authenticator</strong> - 认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li>
<li><strong>Authrizer</strong> - 授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li>
<li><strong>Realm</strong> - 可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意 - Shiro 不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</li>
<li><strong>SessionManager</strong> - 如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li>
<li><strong>SessionDAO</strong> - DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</li>
<li><strong>CacheManager</strong> - 缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</li>
<li><strong>Cryptography</strong> - 密码模块，Shiro 提高了一些常见的加密组件用于如密码加密/解密的。</li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="http://shiro.apache.org/reference.html" target="_blank" rel="noopener">shiro 官方文档</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/category/305053" target="_blank" rel="noopener">跟我学 Shiro</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/13/programming/java/javaweb/distributed/mq/kafka-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/13/programming/java/javaweb/distributed/mq/kafka-advanced/" itemprop="url">Kafka</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T00:00:00+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><blockquote>
<p>Kafka 是一个分布式的、可水平扩展的、基于发布/订阅模式的、支持容错的消息系统。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-概述">1. 概述</a><ul>
<li><a href="#11-分布式">1.1. 分布式</a></li>
<li><a href="#12-容错">1.2. 容错</a></li>
<li><a href="#13-提交日志">1.3. 提交日志</a></li>
<li><a href="#14-消息队列">1.4. 消息队列</a></li>
<li><a href="#15-为什么要使用消息系统">1.5. 为什么要使用消息系统</a></li>
<li><a href="#16-kafka-的关键功能">1.6. Kafka 的关键功能</a></li>
<li><a href="#17-kafka-基本概念">1.7. Kafka 基本概念</a></li>
<li><a href="#18-kafka-核心-api">1.8. Kafka 核心 API</a></li>
<li><a href="#19-topic-和日志">1.9. Topic 和日志</a></li>
</ul>
</li>
<li><a href="#2-kafka-工作原理">2. Kafka 工作原理</a></li>
<li><a href="#3-持久化">3. 持久化</a></li>
<li><a href="#4-复制">4. 复制</a></li>
<li><a href="#5-流处理">5. 流处理</a><ul>
<li><a href="#51-无状态处理">5.1. 无状态处理</a></li>
<li><a href="#52-有状态处理">5.2. 有状态处理</a></li>
</ul>
</li>
<li><a href="#6-kafka-应用场景">6. Kafka 应用场景</a></li>
<li><a href="#7-幂等性">7. 幂等性</a><ul>
<li><a href="#71-幂等性实现">7.1. 幂等性实现</a></li>
<li><a href="#72-幂等性的应用实例">7.2. 幂等性的应用实例</a></li>
</ul>
</li>
<li><a href="#8-事务">8. 事务</a><ul>
<li><a href="#81-事务属性理解">8.1. 事务属性理解</a></li>
<li><a href="#82-引入事务目的">8.2. 引入事务目的</a></li>
<li><a href="#83-事务操作的-api">8.3. 事务操作的 API</a></li>
<li><a href="#84-事务属性的应用实例">8.4. 事务属性的应用实例</a></li>
<li><a href="#85-生产者事务的实现">8.5. 生产者事务的实现</a></li>
<li><a href="#86-其他思考">8.6. 其他思考</a></li>
</ul>
</li>
<li><a href="#9-资料">9. 资料</a><ul>
<li><a href="#91-官方资料">9.1. 官方资料</a></li>
<li><a href="#92-第三方资料">9.2. 第三方资料</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-分布式"><a href="#1-1-分布式" class="headerlink" title="1.1. 分布式"></a>1.1. 分布式</h3><p>分布式系统是一个由多个运行机器组成的系统，所有这些机器在一个集群中一起工作，对最终端用户表现为一个节点。</p>
<p>Kafka 的分布式意义在于：它在不同的节点上存储、接收和发送消息。</p>
<h3 id="1-2-容错"><a href="#1-2-容错" class="headerlink" title="1.2. 容错"></a>1.2. 容错</h3><p>分布式系统一般都会设计容错机制，保证集群中几个节点出现故障时，仍能对外提供服务。</p>
<h3 id="1-3-提交日志"><a href="#1-3-提交日志" class="headerlink" title="1.3. 提交日志"></a>1.3. 提交日志</h3><p>提交日志（也称为预写日志，事务日志）是仅支持附加的持久有序数据结构。您不能修改或删除记录。它从左到右读取并保证项目排序。</p>
<p>Kafka 实际上将所有的消息存储到磁盘，并在结构中对它们进行排序，以便利用顺序磁盘读取。</p>
<h3 id="1-4-消息队列"><a href="#1-4-消息队列" class="headerlink" title="1.4. 消息队列"></a>1.4. 消息队列</h3><p>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上, 队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。常用的消息队列技术是 Message Queue。</p>
<p>Message Queue 的通信模式：</p>
<ul>
<li><strong>点对点</strong>：点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</li>
<li><strong>多点广播</strong>：MQ 适用于不同类型的应用。其中重要的，也是正在发展中的是”多点广播”应用，即能够将消息发送到多个目标站点 (Destination List)。可以使用一条 MQ 指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ 不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ 将消息的一个复制版本和该系统上接收者的名单发送到目标 MQ 系统。目标 MQ 系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</li>
<li><strong>发布/订阅 (Publish/Subscribe)</strong>：发布/订阅功能使消息的分发可以突破目的队列地理指向的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅功能使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。</li>
<li><strong>集群 (Cluster)</strong>：为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster(集群) 的解决方案。集群类似于一个域 (Domain)，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群 (Cluster) 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li>
</ul>
<h3 id="1-5-为什么要使用消息系统"><a href="#1-5-为什么要使用消息系统" class="headerlink" title="1.5. 为什么要使用消息系统"></a>1.5. 为什么要使用消息系统</h3><ul>
<li>解耦<br>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</li>
<li>冗余<br>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</li>
<li>扩展性<br>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</li>
<li>灵活性 &amp; 峰值处理能力<br>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</li>
<li>可恢复性<br>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</li>
<li>顺序保证<br>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka 保证一个 Partition 内的消息的有序性。</li>
<li>缓冲<br>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</li>
<li>异步通信<br>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</li>
</ul>
<h3 id="1-6-Kafka-的关键功能"><a href="#1-6-Kafka-的关键功能" class="headerlink" title="1.6. Kafka 的关键功能"></a>1.6. Kafka 的关键功能</h3><ul>
<li>发布和订阅流记录，类似于消息队列或企业级消息系统。</li>
<li>以容错、持久化的方式存储流记录。</li>
<li>处理流记录。</li>
</ul>
<h3 id="1-7-Kafka-基本概念"><a href="#1-7-Kafka-基本概念" class="headerlink" title="1.7. Kafka 基本概念"></a>1.7. Kafka 基本概念</h3><ul>
<li>Kafka 作为一个集群运行在一台或多台可以跨越多个数据中心的服务器上。</li>
<li>Kafka 集群在称为 Topic 的类别中存储记录流。</li>
<li>Kafka 的每个记录由一个键，一个值和一个时间戳组成。</li>
</ul>
<h3 id="1-8-Kafka-核心-API"><a href="#1-8-Kafka-核心-API" class="headerlink" title="1.8. Kafka 核心 API"></a>1.8. Kafka 核心 API</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-core-api.png" width="400"><br></div>

<ul>
<li>Producer - 允许应用程序将记录流发布到一个或多个 Kafka Topic。</li>
<li>Consumer - 允许应用程序订阅一个或多个 Topic 并处理为他们生成的记录流。</li>
<li>Streams - 允许应用程序充当流处理器，从一个或多个 Topic 中消费输入流，并将输出流生成为一个或多个输出 Topic，从而将输入流有效地转换为输出流。</li>
<li>Connector - 允许构建和运行可重复使用的生产者或消费者，将 Kafka Topic 连接到现有的应用程序或数据系统。例如，连接到关系数据库的连接器可能会捕获对表的每个更改。</li>
</ul>
<p>在 Kafka 中，客户端和服务器之间的通信是采用 TCP 协议方式。</p>
<h3 id="1-9-Topic-和日志"><a href="#1-9-Topic-和日志" class="headerlink" title="1.9. Topic 和日志"></a>1.9. Topic 和日志</h3><p>Topic 是一个目录名，它保存着发布记录。kafka 的 Topic 始终是多订阅者的，也就是说，一个主题可以有零个，一个或多个订阅写入数据的 Consumer。</p>
<p>在 Kafka 中，任意一个 Topic 维护一个 Partition 的日志，类似下图：</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-log-anatomy.png" width="400"><br></div>

<p>每个 Partition 都是一个有序的，不可变的记录序列，不断追加到结构化的提交日志中。Partition 中的记录每个分配一个连续的 id 号，称为偏移量，用于唯一标识 Partition 内的每条记录。</p>
<p>Kafka 集群持久化保存（使用可配置的保留期限）所有发布记录——无论它们是否被消费。例如，如果保留期限被设置为两天，则在记录发布后的两天之内，它都可以被消费，超过时间后将被丢弃以释放空间。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-log-consumer.png" width="400"><br></div>

<p>实际上，保留在每个 Consumer 基础上的唯一元数据是该 Consumer 在日志中的抵消或位置。这个偏移量是由 Consumer 控制的：Consumer 通常会在读取记录时线性地推进其偏移量，但实际上，由于位置由 Consumer 控制，因此它可以按照喜欢的任何顺序消费记录。</p>
<p>这种功能组合意味着 Kafka Consumer 的开销很小——它们的出现对集群和其他 Consumer 没有多少影响。</p>
<p>日志中的 Partition 有多种目的。首先，它们允许日志的大小超出服务器限制的大小。每个单独的 Partition 必须适合承载它的服务器，但是一个主题可能有很多 Partition，因此它可以处理任意数量的数据。其次，它们作为并行的单位。</p>
<h2 id="2-Kafka-工作原理"><a href="#2-Kafka-工作原理" class="headerlink" title="2. Kafka 工作原理"></a>2. Kafka 工作原理</h2><ul>
<li><strong>Broker</strong> - Kafka 集群包含一个或多个服务器，这种服务器被称为 broker。</li>
<li><strong>Topic</strong> - 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。</li>
<li><strong>Partition</strong> - Parition 是物理上的概念，每个 Topic 包含一个或多个 Partition。</li>
<li><strong>Producer</strong> - 负责发布消息到 Kafka broker。</li>
<li><strong>Consumer</strong> - 消息消费者，向 Kafka broker 读取消息的客户端。</li>
<li><strong>Consumer Group</strong> - 每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</li>
</ul>
<p>Producer 将消息（记录）发送到 Kafka 节点（Broker），消息由称为 Consumer 的其他应用程序处理。消息被存储在 Topic 中，并且 Consumer 订阅该主题以接收新消息。</p>
<p>随着 Topic 变得日益庞大，它们会被分割成更小的 Partition 以提高性能和可伸缩性。Kafka 保证 Partition 内的所有消息按照它们出现的顺序排序。区分特定消息的方式是通过它的偏移量，您可以将它看作普通数组索引，每个新消息都会增加一个序列号在一个 Partition 中。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-log-anatomy.png" width="400"><br></div>

<p>Kafka 遵循发布/订阅模式。这意味着 Kafka 不会跟踪 Kafka 读取哪些记录并删除它们，而是将它们存储一段时间（例如一天）或直到满足某个大小阈值。Consumer 自己对 Kafka 进行新的消息调查并说出他们想要阅读的记录。这使得他们可以按照自己的意愿递增/递减偏移量，从而能够重播和重新处理事件。</p>
<p>Kafka 集群持久化保存（使用可配置的保留期限）所有发布记录——无论它们是否被消费。例如，如果保留期限被设置为两天，则在记录发布后的两天之内，它都可以被消费，超过时间后将被丢弃以释放空间。</p>
<p>值得注意的是，Consumer 实际上是内部拥有一个或多个 Consumer 流程的 Consumer 群体。为了避免两个进程读两次相同的消息，每个 Partition 仅与每个组的一个 Consumer 进程相关联。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-producer-consumer.png" width="640"><br></div>

<h2 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3. 持久化"></a>3. 持久化</h2><p>Kafka 实际上将其所有记录存储在磁盘中，并且不会将任何内容保留在 RAM 中。</p>
<ul>
<li>Kafka 有一个将消息分组在一起的协议。它允许网络请求将消息分组在一起以减少网络开销。服务器一气呵成的将消息的数据块持久化并立即获取较大的线性块。</li>
<li>线性读取/写入磁盘速度很快。现代磁盘速度较慢的概念是由于大量的磁盘搜索，这在大型线性操作中不是问题。</li>
<li>所说的线性操作由操作系统通过预读（预取大块数倍）和后写（将小的逻辑写入大物理写入）技术进行了大量优化。</li>
<li>现代操作系统将磁盘缓存在可用 RAM 中。这被称为 pagecache。</li>
<li>由于 Kafka 在整个流程（生产者 -&gt; 经纪 -&gt; 消费者）中以标准化的二进制格式存储未修改的消息，所以它可以利用零拷贝优化。这就是操作系统将数据从页面缓存直接复制到套接字时，完全绕过了 Kafka 经纪人应用程序。</li>
</ul>
<p>所有这些优化都允许 Kafka 以接近网络速度传递消息。</p>
<h2 id="4-复制"><a href="#4-复制" class="headerlink" title="4. 复制"></a>4. 复制</h2><p>分区数据在多个代理中复制，以便在一个代理死亡的情况下保存数据。</p>
<p>在任何时候，一个代理“拥有”一个分区，并且是应用程序通过该分区读写数据的节点。这被称为分区领导。它将它收到的数据复制到 N 个其他代理（称为追随者）。他们也存储数据，并准备在领导者节点死亡的情况下取代领导者。这就是典型的一主多从模式。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-replication.png" width="640"><br></div>

<p>生产者/消费者如何知道分区的领导者是谁？</p>
<p>对于生产者/消费者来说，从一个分区写入/读取，他们需要知道它的领导者，对吧？这些信息需要从某处获得。Kafka 将这种元数据存储在一个名为 Zookeeper 的服务中。</p>
<p>生产者和消费者都和 Zookeeper 连接并通信。Kafka 一直在摆脱这种耦合，自 0.8 和 0.9 版分别开始，客户端直接从 Kafka 经纪人那里获取元数据信息，他们自己与 Zookeeper 交谈。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-metadata-flow.png" width="640"><br></div>

<h2 id="5-流处理"><a href="#5-流处理" class="headerlink" title="5. 流处理"></a>5. 流处理</h2><p>在 Kafka 中，流处理器是任何需要从输入主题中持续输入数据流，对该输入执行一些处理并生成输出主题的数据流（或外部服务，数据库，垃圾桶，无论哪里真的……）</p>
<p>可以直接使用生产者/消费者 API 进行简单处理，但对于更复杂的转换（如将流连接在一起），Kafka 提供了一个集成的 Streams API 库。</p>
<p>此 API 旨在用于您自己的代码库中，它不在代理上运行。它与消费者 API 类似，可帮助您扩展多个应用程序的流处理工作（类似于消费者群体）。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-stream-processor.png" width="640"><br></div>

<h3 id="5-1-无状态处理"><a href="#5-1-无状态处理" class="headerlink" title="5.1. 无状态处理"></a>5.1. 无状态处理</h3><p>流的无状态处理是确定性处理，不依赖于任何外部。你知道，对于任何给定的数据，你将总是产生独立于其他任何东西的相同输出。</p>
<p>一个流可以被解释为一个表，一个表可以被解释为一个流。</p>
<p>流可以被解释为数据的一系列更新，其中聚合是表的最终结果。</p>
<p>如果您看看如何实现同步数据库复制，您会发现它是通过所谓的流式复制，其中表中的每个更改都发送到副本服务器。</p>
<p>Kafka 流可以用同样的方式解释 - 当从最终状态积累时的事件。这样的流聚合被保存在本地的 RocksDB 中（默认情况下），被称为 KTable。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-ktable.png" width="640"><br></div>

<p>可以将表格视为流中每个键的最新值的快照。以同样的方式，流记录可以产生一个表，表更新可以产生一个更新日志流。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-table-as-stream.png" width="640"><br></div>

<h3 id="5-2-有状态处理"><a href="#5-2-有状态处理" class="headerlink" title="5.2. 有状态处理"></a>5.2. 有状态处理</h3><p>一些简单的操作，如 map() 或 filter() 是无状态的，并且不要求您保留有关处理的任何数据。但是，在现实生活中，你要做的大多数操作都是有状态的（例如 count()），因此需要存储当前的累积状态。</p>
<p>维护流处理器上的状态的问题是流处理器可能会失败！你需要在哪里保持这个状态才能容错？</p>
<p>一种天真的做法是简单地将所有状态存储在远程数据库中，并通过网络连接到该存储。问题在于没有数据的地方和大量的网络往返，这两者都会显著减慢你的应用程序。一个更微妙但重要的问题是，您的流处理作业的正常运行时间将与远程数据库紧密耦合，并且作业不会自成体系（数据库中来自另一个团队的更改可能会破坏您的处理过程）。</p>
<p>那么更好的方法是什么？</p>
<p>回想一下表和流的双重性。这使我们能够将数据流转换为与我们的处理共处一地的表格。它还为我们提供了处理容错的机制 - 通过将流存储在 Kafka 代理中。</p>
<p>流处理器可以将其状态保存在本地表（例如 RocksDB）中，该表将从输入流更新（可能是某种任意转换之后）。当进程失败时，它可以通过重放流来恢复其数据。</p>
<p>您甚至可以让远程数据库成为流的生产者，从而有效地广播更新日志，以便在本地重建表。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-stateful-process.png" width="640"><br></div>

<h2 id="6-Kafka-应用场景"><a href="#6-Kafka-应用场景" class="headerlink" title="6. Kafka 应用场景"></a>6. Kafka 应用场景</h2><ul>
<li>构建实时的流数据管道，在系统或应用间获取可靠数据。</li>
<li>构建实时的流应用程序，用于转换或响应数据流。</li>
</ul>
<p>正如我们已经介绍的那样，Kafka 允许您将大量消息通过集中介质存储并存储，而不用担心性能或数据丢失等问题。</p>
<p>这意味着它非常适合用作系统架构的核心，充当连接不同应用程序的集中介质。 Kafka 可以成为事件驱动架构的核心部分，并允许您真正将应用程序彼此分离。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/mq/kafka/kafka-event-system.png" width="640"><br></div>

<p>Kafka 允许您轻松分离不同（微）服务之间的通信。利用 Streams API，现在比以往更容易编写业务逻辑，丰富了 Kafka 主题数据以便服务消费。</p>
<h2 id="7-幂等性"><a href="#7-幂等性" class="headerlink" title="7. 幂等性"></a>7. 幂等性</h2><p>幂等性引入目的：生产者重复生产消息。生产者进行 retry 会产生重试时，会重复产生消息。有了幂等性之后，在进行 retry 重试时，只会生成一个消息。</p>
<h3 id="7-1-幂等性实现"><a href="#7-1-幂等性实现" class="headerlink" title="7.1. 幂等性实现"></a>7.1. 幂等性实现</h3><h4 id="7-1-1-PID-和-Sequence-Number"><a href="#7-1-1-PID-和-Sequence-Number" class="headerlink" title="7.1.1. PID 和 Sequence Number"></a>7.1.1. PID 和 Sequence Number</h4><p>为了实现 Producer 的幂等性，Kafka 引入了 Producer ID（即 PID）和 Sequence Number。</p>
<ul>
<li>PID。每个新的 Producer 在初始化的时候会被分配一个唯一的 PID，这个 PID 对用户是不可见的。</li>
<li>Sequence Numbler。（对于每个 PID，该 Producer 发送数据的每个&lt;Topic, Partition&gt;都对应一个从 0 开始单调递增的 Sequence Number。</li>
</ul>
<p>Broker 端在缓存中保存了这 seq number，对于接收的每条消息，如果其序号比 Broker 缓存中序号大于 1 则接受它，否则将其丢弃。这样就可以实现了消息重复提交了。但是，只能保证单个 Producer 对于同一个&lt;Topic, Partition&gt;的 Exactly Once 语义。不能保证同一个 Producer 一个 topic 不同的 partion 幂等。</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/1-1.png"></div><br></p>
<p>实现幂等之后</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/2.png"></div><br></p>
<h4 id="7-1-2-生成-PID-的流程"><a href="#7-1-2-生成-PID-的流程" class="headerlink" title="7.1.2. 生成 PID 的流程"></a>7.1.2. 生成 PID 的流程</h4><p>在执行创建事务时，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(props);</span><br></pre></td></tr></table></figure>
<p>会创建一个 Sender，并启动线程，执行如下 run 方法，在 maybeWaitForProducerId()中生成一个 producerId，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">====================================</span><br><span class="line">类名：Sender</span><br><span class="line">====================================</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 ........</span><br><span class="line">                <span class="keyword">if</span> (!transactionManager.isTransactional()) &#123;</span><br><span class="line">                    <span class="comment">// 为idempotent producer生成一个producer id</span></span><br><span class="line">                    maybeWaitForProducerId();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()) &#123;</span><br><span class="line">                   ........</span><br></pre></td></tr></table></figure>
<h3 id="7-2-幂等性的应用实例"><a href="#7-2-幂等性的应用实例" class="headerlink" title="7.2. 幂等性的应用实例"></a>7.2. 幂等性的应用实例</h3><p>（1）配置属性</p>
<p>需要设置：</p>
<ul>
<li>enable.idempotence，需要设置为 ture,此时就会默认把 acks 设置为 all，所以不需要再设置 acks 属性了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Producer <span class="title">buildIdempotProducer</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create instance for properties to access producer configs</span></span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bootstrap.servers是Kafka集群的IP地址。多个时,使用逗号隔开</span></span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"></span><br><span class="line">    props.put(<span class="string">"enable.idempotence"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If the request fails, the producer can automatically retry,</span></span><br><span class="line">    props.put(<span class="string">"retries"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Reduce the no of requests less than 0</span></span><br><span class="line">    props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The buffer.memory controls the total amount of memory available to the producer for buffering.</span></span><br><span class="line">    props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kafka消息是以键值对的形式发送,需要设置key和value类型序列化器</span></span><br><span class="line">    props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">    props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）发送消息</p>
<p>跟一般生产者一样，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceIdempotMessage</span><span class="params">(String topic, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Producer</span></span><br><span class="line">    Producer producer = buildIdempotProducer();</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topic, message));</span><br><span class="line">    producer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，因为我们并没有配置 transaction.id 属性，所以不能使用事务相关 API，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.initTransactions();</span><br></pre></td></tr></table></figure>
<p>否则会出现如下错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main” java.lang.IllegalStateException: Transactional method invoked on a non-transactional producer.</span><br><span class="line">    at org.apache.kafka.clients.producer.internals.TransactionManager.ensureTransactional(TransactionManager.java:<span class="number">777</span>)</span><br><span class="line">    at org.apache.kafka.clients.producer.internals.TransactionManager.initializeTransactions(TransactionManager.java:<span class="number">202</span>)</span><br><span class="line">    at org.apache.kafka.clients.producer.KafkaProducer.initTransactions(KafkaProducer.java:<span class="number">544</span>)</span><br></pre></td></tr></table></figure>
<h2 id="8-事务"><a href="#8-事务" class="headerlink" title="8. 事务"></a>8. 事务</h2><h3 id="8-1-事务属性理解"><a href="#8-1-事务属性理解" class="headerlink" title="8.1. 事务属性理解"></a>8.1. 事务属性理解</h3><p>事务属性是 2017 年 Kafka 0.11.0.0 引入的新特性。类似于数据库事务，只是这里的数据源是 Kafka，<strong>kafka 事务属性是指一系列的生产者生产消息和消费者提交偏移量的操作在一个事务，或者说是是一个原子操作），同时成功或者失败</strong>。</p>
<p>注意：在理解消息的事务时，一直处于一个错误理解就是如下代码中，把操作 db 的业务逻辑跟操作消息当成是一个事务。其实这个是有问题的，操作 DB 数据库的数据源是 DB，消息数据源是 kfaka，这是完全不同两个数据，一种数据源（如 mysql，kafka）对应一个事务，所以它们是两个独立的事务：kafka 事务指 kafka 一系列 生产、消费消息等操作组成一个原子操作；db 事务是指操作数据库的一系列增删改操作组成一个原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">kakfa_in_tranction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.kafa的操作：读取消息或者生产消息</span></span><br><span class="line">    kafkaOperation();</span><br><span class="line">    <span class="comment">// 2.db操作</span></span><br><span class="line">    dbOperation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-引入事务目的"><a href="#8-2-引入事务目的" class="headerlink" title="8.2. 引入事务目的"></a>8.2. 引入事务目的</h3><p>在事务属性之前先引入了生产者幂等性，它的作用为：</p>
<ul>
<li>生产者多次发送消息可以封装成一个原子操作，要么都成功，要么失败</li>
<li>consumer-transform-producer 模式下，因为消费者提交偏移量出现问题，导致在重复消费消息时，生产者重复生产消息。需要将这个模式下消费者提交偏移量操作和生产者一系列生成消息的操作封装成一个原子操作。</li>
</ul>
<p><strong>消费者提交偏移量导致重复消费消息的场景</strong>：消费者在消费消息完成提交便宜量 o2 之前挂掉了（假设它最近提交的偏移量是 o1），此时执行再均衡时，其它消费者会重复消费消息(o1 到 o2 之间的消息）。</p>
<h3 id="8-3-事务操作的-API"><a href="#8-3-事务操作的-API" class="headerlink" title="8.3. 事务操作的 API"></a>8.3. 事务操作的 API</h3><p>producer 提供了 initTransactions, beginTransaction, sendOffsets, commitTransaction, abortTransaction 五个事务方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化事务。需要注意的有：</span></span><br><span class="line"><span class="comment"> * 1、前提</span></span><br><span class="line"><span class="comment"> * 需要保证transation.id属性被配置。</span></span><br><span class="line"><span class="comment"> * 2、这个方法执行逻辑是：</span></span><br><span class="line"><span class="comment"> *   （1）Ensures any transactions initiated by previous instances of the producer with the same</span></span><br><span class="line"><span class="comment"> *      transactional.id are completed. If the previous instance had failed with a transaction in</span></span><br><span class="line"><span class="comment"> *      progress, it will be aborted. If the last transaction had begun completion,</span></span><br><span class="line"><span class="comment"> *      but not yet finished, this method awaits its completion.</span></span><br><span class="line"><span class="comment"> *    （2）Gets the internal producer id and epoch, used in all future transactional</span></span><br><span class="line"><span class="comment"> *      messages issued by the producer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTransactions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为消费者提供的在事务内提交偏移量的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOffsetsToTransaction</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String consumerGroupId)</span> <span class="keyword">throws</span> ProducerFencedException </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放弃事务，类似回滚事务的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abortTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException </span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-事务属性的应用实例"><a href="#8-4-事务属性的应用实例" class="headerlink" title="8.4. 事务属性的应用实例"></a>8.4. 事务属性的应用实例</h3><p>在一个原子操作中，根据包含的操作类型，可以分为三种情况，<strong>前两种情况是事务引入的场景</strong>，最后一种情况没有使用价值。</p>
<p>只有 Producer 生产消息；</p>
<p>消费消息和生产消息并存，<strong>这个是事务场景中最常用的情况</strong>，就是我们常说的“consume-transform-produce ”模式</p>
<p>只有 consumer 消费消息，这种操作其实没有什么意义，跟使用手动提交效果一样，而且也不是事务属性引入的目的，所以一般不会使用这种情况</p>
<h4 id="8-4-1-相关属性配置"><a href="#8-4-1-相关属性配置" class="headerlink" title="8.4.1. 相关属性配置"></a>8.4.1. 相关属性配置</h4><p>使用 kafka 的事务 api 时的一些注意事项：</p>
<ul>
<li>需要消费者的自动模式设置为 false,并且不能子再手动的进行执行 consumer#commitSync 或者 consumer#commitAsyc</li>
<li>生产者配置 transaction.id 属性</li>
<li>生产者不需要再配置 enable.idempotence，因为如果配置了 transaction.id，则此时 enable.idempotence 会被设置为 true</li>
<li>消费者需要配置 Isolation.level。在 consume-trnasform-produce 模式下使用事务时，必须设置为 READ_COMMITTED。</li>
</ul>
<h4 id="8-4-2-只有写"><a href="#8-4-2-只有写" class="headerlink" title="8.4.2. 只有写"></a>8.4.2. 只有写</h4><p>创建一个事务，在这个事务操作中，只有生成消息操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个事务只有生产消息操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlyProduceInTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Producer producer = buildProducer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.初始化事务</span></span><br><span class="line">    producer.initTransactions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开启事务</span></span><br><span class="line">    producer.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3.kafka写操作集合</span></span><br><span class="line">        <span class="comment">// 3.1 do业务逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 发送消息</span></span><br><span class="line">        producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"test"</span>, <span class="string">"transaction-data-1"</span>));</span><br><span class="line"></span><br><span class="line">        producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"test"</span>, <span class="string">"transaction-data-2"</span>));</span><br><span class="line">        <span class="comment">// 3.3 do其他业务逻辑,还可以发送其他topic的消息。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.事务提交</span></span><br><span class="line">        producer.commitTransaction();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 5.放弃事务</span></span><br><span class="line">        producer.abortTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建生产者，代码如下,需要:</p>
<ul>
<li>配置 transactional.id 属性</li>
<li>配置 enable.idempotence 属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要:</span></span><br><span class="line"><span class="comment"> * 1、设置transactional.id</span></span><br><span class="line"><span class="comment"> * 2、设置enable.idempotence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Producer <span class="title">buildProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create instance for properties to access producer configs</span></span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bootstrap.servers是Kafka集群的IP地址。多个时,使用逗号隔开</span></span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事务id</span></span><br><span class="line">    props.put(<span class="string">"transactional.id"</span>, <span class="string">"first-transactional"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置幂等性</span></span><br><span class="line">    props.put(<span class="string">"enable.idempotence"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set acknowledgements for producer requests.</span></span><br><span class="line">    props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If the request fails, the producer can automatically retry,</span></span><br><span class="line">    props.put(<span class="string">"retries"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Specify buffer size in config,这里不进行设置这个属性,如果设置了,还需要执行producer.flush()来把缓存中消息发送出去</span></span><br><span class="line">    <span class="comment">//props.put("batch.size", 16384);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Reduce the no of requests less than 0</span></span><br><span class="line">    props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The buffer.memory controls the total amount of memory available to the producer for buffering.</span></span><br><span class="line">    props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kafka消息是以键值对的形式发送,需要设置key和value类型序列化器</span></span><br><span class="line">    props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">    props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-3-消费-生产并存（consume-transform-produce）"><a href="#8-4-3-消费-生产并存（consume-transform-produce）" class="headerlink" title="8.4.3. 消费-生产并存（consume-transform-produce）"></a>8.4.3. 消费-生产并存（consume-transform-produce）</h4><p>在一个事务中，既有生产消息操作又有消费消息操作，即常说的 Consume-tansform-produce 模式。如下实例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个事务内,即有生产消息又有消费消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeTransferProduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建上产者</span></span><br><span class="line">    Producer producer = buildProducer();</span><br><span class="line">    <span class="comment">// 2.初始化事务(生成productId),对于一个生产者,只能执行一次初始化事务操作</span></span><br><span class="line">    producer.initTransactions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.构建消费者和订阅主题</span></span><br><span class="line">    Consumer consumer = buildConsumer();</span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">"test"</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 4.开启事务</span></span><br><span class="line">        producer.beginTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 接受消息</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5.2 do业务逻辑;</span></span><br><span class="line">            System.out.println(<span class="string">"customer Message---"</span>);</span><br><span class="line">            Map&lt;TopicPartition, OffsetAndMetadata&gt; commits = Maps.newHashMap();</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 5.2.1 读取消息,并处理消息。print the offset,key and value for the consumer records.</span></span><br><span class="line">                System.out.printf(<span class="string">"offset = %d, key = %s, value = %s\n"</span>,</span><br><span class="line">                        record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.2.2 记录提交的偏移量</span></span><br><span class="line">                commits.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()),</span><br><span class="line">                        <span class="keyword">new</span> OffsetAndMetadata(record.offset()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6.生产新的消息。比如外卖订单状态的消息,如果订单成功,则需要发送跟商家结转消息或者派送员的提成消息</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"test"</span>, <span class="string">"data2"</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.提交偏移量</span></span><br><span class="line">            producer.sendOffsetsToTransaction(commits, <span class="string">"group0323"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.事务提交</span></span><br><span class="line">            producer.commitTransaction();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 7.放弃事务</span></span><br><span class="line">            producer.abortTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建消费者代码，需要：</p>
<ul>
<li>将配置中的自动提交属性（auto.commit）进行关闭</li>
<li>而且在代码里面也不能使用手动提交 commitSync( )或者 commitAsync( )</li>
<li>设置 isolation.level</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要:</span></span><br><span class="line"><span class="comment"> * 1、关闭自动提交 enable.auto.commit</span></span><br><span class="line"><span class="comment"> * 2、isolation.level为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Consumer <span class="title">buildConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// bootstrap.servers是Kafka集群的IP地址。多个时,使用逗号隔开</span></span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    <span class="comment">// 消费者群组</span></span><br><span class="line">    props.put(<span class="string">"group.id"</span>, <span class="string">"group0323"</span>);</span><br><span class="line">    <span class="comment">// 设置隔离级别</span></span><br><span class="line">    props.put(<span class="string">"isolation.level"</span>,<span class="string">"read_committed"</span>);</span><br><span class="line">    <span class="comment">// 关闭自动提交</span></span><br><span class="line">    props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>);</span><br><span class="line">    props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">    props.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    props.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">            <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer</span><br><span class="line">            &lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-4-只有读"><a href="#8-4-4-只有读" class="headerlink" title="8.4.4. 只有读"></a>8.4.4. 只有读</h4><p>创建一个事务，在这个事务操作中，只有生成消息操作，如下代码。这种操作其实没有什么意义，跟使用手动提交效果一样，无法保证消费消息操作和提交偏移量操作在一个事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个事务只有消息操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlyConsumeInTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Producer producer = buildProducer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.初始化事务</span></span><br><span class="line">    producer.initTransactions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开启事务</span></span><br><span class="line">    producer.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.kafka读消息的操作集合</span></span><br><span class="line">    Consumer consumer = buildConsumer();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.1 接受消息</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3.2 do业务逻辑;</span></span><br><span class="line">            System.out.println(<span class="string">"customer Message---"</span>);</span><br><span class="line">            Map&lt;TopicPartition, OffsetAndMetadata&gt; commits = Maps.newHashMap();</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 3.2.1 处理消息 print the offset,key and value for the consumer records.</span></span><br><span class="line">                System.out.printf(<span class="string">"offset = %d, key = %s, value = %s\n"</span>,</span><br><span class="line">                        record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2.2 记录提交偏移量</span></span><br><span class="line">                commits.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()),</span><br><span class="line">                        <span class="keyword">new</span> OffsetAndMetadata(record.offset()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.提交偏移量</span></span><br><span class="line">            producer.sendOffsetsToTransaction(commits, <span class="string">"group0323"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.事务提交</span></span><br><span class="line">            producer.commitTransaction();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 6.放弃事务</span></span><br><span class="line">            producer.abortTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-生产者事务的实现"><a href="#8-5-生产者事务的实现" class="headerlink" title="8.5. 生产者事务的实现"></a>8.5. 生产者事务的实现</h3><h4 id="8-5-1-相关配置"><a href="#8-5-1-相关配置" class="headerlink" title="8.5.1. 相关配置"></a>8.5.1. 相关配置</h4><h4 id="8-5-2-幂等性和事务性的关系"><a href="#8-5-2-幂等性和事务性的关系" class="headerlink" title="8.5.2. 幂等性和事务性的关系"></a>8.5.2. 幂等性和事务性的关系</h4><h5 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h5><p>事务属性实现前提是幂等性，即在配置事务属性 transaction id 时，必须还得配置幂等性；但是幂等性是可以独立使用的，不需要依赖事务属性。</p>
<ul>
<li>幂等性引入了 Porducer ID</li>
<li>事务属性引入了 Transaction Id 属性。、</li>
</ul>
<p>设置</p>
<ul>
<li>enable.idempotence = true，transactional.id 不设置：只支持幂等性。</li>
<li>enable.idempotence = true，transactional.id 设置：支持事务属性和幂等性</li>
<li>enable.idempotence = false，transactional.id 不设置：没有事务属性和幂等性的 kafka</li>
<li>enable.idempotence = false，transactional.id 设置：无法获取到 PID，此时会报错</li>
</ul>
<h5 id="tranaction-id-、productid-和-epoch"><a href="#tranaction-id-、productid-和-epoch" class="headerlink" title="tranaction id 、productid 和 epoch"></a>tranaction id 、productid 和 epoch</h5><p><strong>一个 app 有一个 tid，同一个应用的不同实例 PID 是一样的，只是 epoch 的值不同</strong>。如：</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/3-1.png"></div><br></p>
<p>同一份代码运行两个实例，分步执行如下：<em>在实例 1 没有进行提交事务前，开始执行实例 2 的初始化事务</em></p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/4-1-1024x458.png"></div><br></p>
<p><strong>step1 实例 1-初始化事务</strong>。的打印出对应 productId 和 epoch，信息如下：</p>
<p>[2018-04-21 20:56:23,106] INFO [TransactionCoordinator id=0] Initialized transactionalId first-transactional with producerId 8000 and producer epoch 123 on partition __transaction_state-12 (kafka.coordinator.transaction.TransactionCoordinator)</p>
<p><strong>step2 实例 1-发送消息。</strong></p>
<p><strong>step3 实例 2-初始化事务</strong>。初始化事务时的打印出对应 productId 和 epoch，信息如下：</p>
<p>18-04-21 20:56:48,373] INFO [TransactionCoordinator id=0] Initialized transactionalId first-transactional with producerId 8000 and producer epoch 124 on partition __transaction_state-12 (kafka.coordinator.transaction.TransactionCoordinator)</p>
<p><strong>step4 实例 1-提交事务</strong>，此时报错</p>
<p>org.apache.kafka.common.errors.ProducerFencedException: Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer’s transaction has been expired by the broker.</p>
<p><strong>step5 实例 2-提交事务</strong></p>
<p>为了避免这种错误，同一个事务 ID，只有保证如下顺序 epch 小 producer 执行 init-transaction 和 committransaction，然后 epoch 较大的 procuder 才能开始执行 init-transaction 和 commit-transaction，如下顺序：</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/80061024.png"></div><br></p>
<p>有了 transactionId 后，Kafka 可保证：</p>
<ul>
<li>跨 Session 的数据幂等发送。当具有相同 Transaction ID 的新的 Producer 实例被创建且工作时，旧的且拥有相同 Transaction ID 的 Producer 将不再工作【上面的实例可以验证】。kafka 保证了关联同一个事务的所有 producer（一个应用有多个实例）必须按照顺序初始化事务、和提交事务，否则就会有问题，这保证了同一事务 ID 中消息是有序的（不同实例得按顺序创建事务和提交事务）。</li>
</ul>
<h4 id="8-5-3-事务最佳实践-单实例的事务性"><a href="#8-5-3-事务最佳实践-单实例的事务性" class="headerlink" title="8.5.3. 事务最佳实践-单实例的事务性"></a>8.5.3. 事务最佳实践-单实例的事务性</h4><p>通过上面实例中可以看到 kafka 是跨 Session 的数据幂等发送，即如果应用部署多个实例时常会遇到上面的问题“<em>org.apache.kafka.common.errors.ProducerFencedException: Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer’s transaction has been expired by the broker</em>.”，必须保证这些实例生产者的提交事务顺序和创建顺序保持一致才可以，否则就无法成功。其实，在实践中，我们更多的是<strong>如何实现对应用单实例的事务性</strong>。可以通过 spring-kafaka 实现思路来学习，即<strong>每次创建生产者都设置一个不同的 transactionId 的值</strong>，如下代码：</p>
<p>在 spring-kafka 中，对于一个线程创建一个 producer，事务提交之后，还会关闭这个 producer 并清除，后续同一个线程或者新的线程重新执行事务时，此时就会重新创建 producer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">====================================</span><br><span class="line">类名：ProducerFactoryUtils</span><br><span class="line">====================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Obtain a Producer that is synchronized with the current transaction, if any.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> producerFactory the ConnectionFactory to obtain a Channel for</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;K&gt; the key type.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;V&gt; the value type.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the resource holder.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">KafkaResourceHolder&lt;K, V&gt; <span class="title">getTransactionalResourceHolder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProducerFactory&lt;K, V&gt; producerFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(producerFactory, <span class="string">"ProducerFactory must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对于每一个线程会生成一个唯一key，然后根据key去查找resourceHolder</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    KafkaResourceHolder&lt;K, V&gt; resourceHolder = (KafkaResourceHolder&lt;K, V&gt;) TransactionSynchronizationManager</span><br><span class="line">            .getResource(producerFactory);</span><br><span class="line">    <span class="keyword">if</span> (resourceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.创建一个消费者</span></span><br><span class="line">        Producer&lt;K, V&gt; producer = producerFactory.createProducer();</span><br><span class="line">        <span class="comment">// 3.开启事务</span></span><br><span class="line">        producer.beginTransaction();</span><br><span class="line">        resourceHolder = <span class="keyword">new</span> KafkaResourceHolder&lt;K, V&gt;(producer);</span><br><span class="line">        bindResourceToTransaction(resourceHolder, producerFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resourceHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建消费者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">====================================</span><br><span class="line">类名：DefaultKafkaProducerFactory</span><br><span class="line">====================================</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Producer&lt;K, V&gt; <span class="title">createTransactionalProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Producer&lt;K, V&gt; producer = <span class="keyword">this</span>.cache.poll();</span><br><span class="line">    <span class="keyword">if</span> (producer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="keyword">this</span>.configs);</span><br><span class="line">        <span class="comment">// 对于每一次生成producer时，都设置一个不同的transactionId</span></span><br><span class="line">        configs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG,</span><br><span class="line">                <span class="keyword">this</span>.transactionIdPrefix + <span class="keyword">this</span>.transactionIdSuffix.getAndIncrement());</span><br><span class="line">        producer = <span class="keyword">new</span> KafkaProducer&lt;K, V&gt;(configs, <span class="keyword">this</span>.keySerializer, <span class="keyword">this</span>.valueSerializer);</span><br><span class="line">        <span class="comment">// 1.初始化话事务。</span></span><br><span class="line">        producer.initTransactions();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CloseSafeProducer&lt;K, V&gt;(producer, <span class="keyword">this</span>.cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-5-4-Consume-transform-Produce-的流程"><a href="#8-5-4-Consume-transform-Produce-的流程" class="headerlink" title="8.5.4. Consume-transform-Produce 的流程"></a>8.5.4. Consume-transform-Produce 的流程</h4><p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/Snip20180504_56.png"></div><br></p>
<p><strong>流程 1</strong> <strong>：</strong>查找 Tranaction Corordinator。</p>
<p>Producer 向任意一个 brokers 发送 FindCoordinatorRequest 请求来获取 Transaction Coordinator 的地址。</p>
<p><strong>流程 2：</strong>初始化事务 initTransaction</p>
<p>Producer 发送 InitpidRequest 给事务协调器，获取一个 Pid<strong>。InitpidRequest 的处理过程是同步阻塞的，一旦该调用正确返回，Producer 就可以开始新的事务</strong>。TranactionalId 通过 InitpidRequest 发送给 Tranciton Corordinator，然后在 Tranaciton Log 中记录这&lt;TranacionalId,pid&gt;的映射关系。除了返回 PID 之外，还具有如下功能：</p>
<ul>
<li>对 PID 对应的 epoch 进行递增，这样可以保证同一个 app 的不同实例对应的 PID 是一样的，但是 epoch 是不同的。</li>
<li>回滚之前的 Producer 未完成的事务（如果有）。</li>
</ul>
<p><strong>流程 3：</strong> 开始事务 beginTransaction</p>
<p>执行 Producer 的 beginTransacion()，它的作用是 Producer 在本地记录下这个 transaction 的状态为开始状态。</p>
<p>注意：这个操作并没有通知 Transaction Coordinator。</p>
<p><strong>流程 4：</strong> Consume-transform-produce loop</p>
<p><strong>流程 4.0：</strong> 通过 Consumtor 消费消息，处理业务逻辑</p>
<p><strong>流程 4.1：</strong> producer 向 TransactionCordinantro 发送 AddPartitionsToTxnRequest</p>
<p>在 producer 执行 send 操作时，如果是第一次给&lt;topic,partion&gt;发送数据，此时会向 Trasaction Corrdinator 发送一个 AddPartitionsToTxnRequest 请求，Transaction Corrdinator 会在 transaction log 中记录下 tranasactionId 和&lt;topic,partion&gt;一个映射关系，并将状态改为 begin。AddPartionsToTxnRequest 的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AddPartitionsToTxnRequest =&gt; TransactionalId PID Epoch [Topic [Partition]]</span><br><span class="line"> TransactionalId =&gt; string</span><br><span class="line"> PID =&gt; int64</span><br><span class="line"> Epoch =&gt; int16</span><br><span class="line"> Topic =&gt; string</span><br><span class="line"> Partition =&gt; int32</span><br></pre></td></tr></table></figure>
<p><strong>流程 4.2：</strong> producer#send 发送 ProduceRequst</p>
<p>生产者发送数据，虽然没有还没有执行 commit 或者 absrot，但是此时消息已经保存到 kafka 上，可以参考如下图断点位置处，此时已经可以查看到消息了，而且即使后面执行 abort，消息也不会删除，只是更改状态字段标识消息为 abort 状态。</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/62059279-1024x437.png"></div><br></p>
<p><strong>流程 4.3：</strong> AddOffsetCommitsToTxnRequest</p>
<p>Producer 通过 KafkaProducer.sendOffsetsToTransaction 向事务协调器器发送一个 AddOffesetCommitsToTxnRequests：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddOffsetsToTxnRequest =&gt; TransactionalId PID Epoch ConsumerGroupID</span><br><span class="line"> TransactionalId =&gt; string</span><br><span class="line"> PID =&gt; int64</span><br><span class="line"> Epoch =&gt; int16</span><br><span class="line"> ConsumerGroupID =&gt; string</span><br></pre></td></tr></table></figure>
<p>在执行事务提交时，可以根据 ConsumerGroupID 来推断_customer_offsets 主题中相应的 TopicPartions 信息。这样在</p>
<p><strong>流程 4.4:</strong> TxnOffsetCommitRequest</p>
<p>Producer 通过 KafkaProducer.sendOffsetsToTransaction 还会向消费者协调器 Cosumer Corrdinator 发送一个 TxnOffsetCommitRequest，在主题_consumer_offsets 中保存消费者的偏移量信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TxnOffsetCommitRequest   =&gt; ConsumerGroupID</span><br><span class="line">                            PID</span><br><span class="line">                            Epoch</span><br><span class="line">                            RetentionTime</span><br><span class="line">                            OffsetAndMetadata</span><br><span class="line">  ConsumerGroupID =&gt; string</span><br><span class="line">  PID =&gt; int64</span><br><span class="line">  Epoch =&gt; int32</span><br><span class="line">  RetentionTime =&gt; int64</span><br><span class="line">  OffsetAndMetadata =&gt; [TopicName [Partition Offset Metadata]]</span><br><span class="line">    TopicName =&gt; string</span><br><span class="line">    Partition =&gt; int32</span><br><span class="line">    Offset =&gt; int64</span><br><span class="line">    Metadata =&gt; string</span><br></pre></td></tr></table></figure>
<p><strong>流程 5：</strong> 事务提交和事务终结(放弃事务)</p>
<p>通过生产者的 commitTransaction 或 abortTransaction 方法来提交事务和终结事务，这两个操作都会发送一个 EndTxnRequest 给 Transaction Coordinator。</p>
<p><strong>流程 5.1</strong>：EndTxnRequest。Producer 发送一个 EndTxnRequest 给 Transaction Coordinator，然后执行如下操作：</p>
<ul>
<li>Transaction Coordinator 会把 PREPARE_COMMIT or PREPARE_ABORT 消息写入到 transaction log 中记录</li>
<li>执行流程 5.2</li>
<li>执行流程 5.3</li>
</ul>
<p><strong>流程 5.2</strong>：WriteTxnMarkerRequest</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WriteTxnMarkersRequest =&gt; [CoorinadorEpoch PID Epoch Marker [Topic [Partition]]]</span><br><span class="line"> CoordinatorEpoch =&gt; int32</span><br><span class="line"> PID =&gt; int64</span><br><span class="line"> Epoch =&gt; int16</span><br><span class="line"> Marker =&gt; boolean (false(0) means ABORT, true(1) means COMMIT)</span><br><span class="line"> Topic =&gt; string</span><br><span class="line"> Partition =&gt; int32</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 Producer 生产的消息。Tranaction Coordinator 会发送 WriteTxnMarkerRequest 给当前事务涉及到每个&lt;topic,partion&gt;的 leader，leader 收到请求后，会写入一个 COMMIT(PID) 或者 ABORT(PID)的控制信息到 data log 中</li>
<li>对于消费者偏移量信息，如果在这个事务里面包含_consumer-offsets 主题。Tranaction Coordinator 会发送 WriteTxnMarkerRequest 给 Transaction Coordinartor，Transaction Coordinartor 收到请求后，会写入一个 COMMIT(PID) 或者 ABORT(PID)的控制信息到 data log 中。</li>
</ul>
<p><strong>流程 5.3：</strong>Transaction Coordinator 会将最终的 COMPLETE_COMMIT 或 COMPLETE_ABORT 消息写入 Transaction Log 中以标明该事务结束。</p>
<ul>
<li>只会保留这个事务对应的 PID 和 timstamp。然后把当前事务其他相关消息删除掉，包括 PID 和 tranactionId 的映射关系。</li>
</ul>
<h5 id="文件类型和查看命令"><a href="#文件类型和查看命令" class="headerlink" title="文件类型和查看命令"></a>文件类型和查看命令</h5><p>kafka 文件主要包括 broker 的 data（主题：test）、事务协调器对应的 transaction_log（主题：__tranaction_state）、偏移量信息（主题:_consumer_offsets）三种类型。如下图</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/1-2-207x300.png"></div><br></p>
<p>这三种文件类型其实都是 topic 的分区，所以对于每一个目录都包含<em>.log、</em>.index、<em>.timeindex、</em>.txnindex 文件（仅这个文件是为了实现事务属性引入的）。segment 和 segmengt 对应 index、timeindex、txnindex 文件命名中序号表示的是第几个消息。如下图中，00000000000000368769.index 和 00000000000000568769.log 中“368969”就是表示文件中存储的第一个消息是 468969 个消息。</p>
<p>对于索引文案包含两部分：</p>
<ul>
<li>baseOffset：索引对应 segment 文件中的第几条 message。</li>
<li>position：在 segment 中的绝对位置。</li>
</ul>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/67930538-300x179.png"></div><br></p>
<p>查看文件内容：</p>
<p>bin/kafka-run-class.sh kafka.tools.DumpLogSegments –files /Users/wuzhonghu/data/kafka-logs/firtstopic-0/00000000000000000002.log –print-data-log</p>
<h5 id="ControlMessage-和-Transaction-markers"><a href="#ControlMessage-和-Transaction-markers" class="headerlink" title="ControlMessage 和 Transaction markers"></a>ControlMessage 和 Transaction markers</h5><p>Trasaction markers 就是 kafka 为了实现事务定义的 Controll Message。这个消息和数据消息都存放在 log 中，在 Consumer 读取事务消息时有用，可以参考下面章节-4.5.1 老版本-读取事务消息顺序。</p>
<h5 id="Transaction-Coordinator-和-Transaction-Log"><a href="#Transaction-Coordinator-和-Transaction-Log" class="headerlink" title="Transaction Coordinator 和 Transaction Log"></a>Transaction Coordinator 和 Transaction Log</h5><p>Transaction Log 如下放置在“_tranaction_state”主题下面，默认是 50 个分区，每一个分区中文件格式和 broker 存储消息是一样的,都有 log/index/timeindex 文件，如下：</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/57646045.png"></div><br></p>
<h4 id="8-5-5-消费读取事务消息-READ-COMMITED"><a href="#8-5-5-消费读取事务消息-READ-COMMITED" class="headerlink" title="8.5.5. 消费读取事务消息(READ_COMMITED)"></a>8.5.5. 消费读取事务消息(READ_COMMITED)</h4><p>Consumer 为了实现事务，新增了一个 isolation.level 配置，有两个值如下，</p>
<ul>
<li>READ_UNCOMMITTED，类似于没有事务属性的消费者。</li>
<li>READ_COMMITED，只获取执行了事务提交的消息。</li>
</ul>
<p>在本小节中我们主要讲 READ_COMMITED 模式下读取消息的流程的两种版本的演化</p>
<h5 id="老版本-读取事务消息顺序"><a href="#老版本-读取事务消息顺序" class="headerlink" title="老版本-读取事务消息顺序"></a>老版本-读取事务消息顺序</h5><p>如下图中，按顺序保存到 broker 中消息有：事务 1 消息 T1-M1、对于事务 2 的消息有 T2-M1、事务 1 消息 T1-M2、非事务消息 M1，最终到达 client 端的循序是 M1-&gt; T2-M1 -&gt; T1-M1 -&gt; T1-M2。</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/84999567.png"></div><br></p>
<p>具体步骤如下：</p>
<ul>
<li><strong>step1</strong> Consumer 接受到事务消息 T1-M1、T2-M2、T1-M2 和非事务消息 M1，因为没有收到事务 T1 和 T2 的控制消息，所以此时把事务相关消息 T1-M1、T2-M2、T1-M2 保存到内存，然后只把非事务消息 M1 返回给 client。</li>
<li><strong>step2</strong> Consumer 接受到事务 2 的控制消息 T2-C，此时就把事务消息 T2-M1 发送给 Clinet。</li>
<li><strong>step3</strong> C onsumer 接受到事务 1 的控制消息 T1-C,此时就把事务消息 T1-M1 和 T1-M2 发送给 Client</li>
</ul>
<h5 id="新版本-读取事务消息顺序"><a href="#新版本-读取事务消息顺序" class="headerlink" title="新版本-读取事务消息顺序"></a>新版本-读取事务消息顺序</h5><p>第一种方式，需要在 consumer 客户端缓存消息，当存在耗时比较长的事务时，占用客户端大量的内存资源。为了解决这个问题，通过 LSO 和 Abort Index 文件来解决这个问题，参考：</p>
<p><a href="https://docs.google.com/document/d/1Rlqizmk7QCDe8qAnVW5e5X8rGvn6m2DCR3JR2yqwVjc/edit" target="_blank" rel="noopener">https://docs.google.com/document/d/1Rlqizmk7QCDe8qAnVW5e5X8rGvn6m2DCR3JR2yqwVjc/edit</a></p>
<p>（1） LSO，Last stable offset。Broker 在缓存中维护了所有处于运行状态的事务对应的 initial offsets,LSO 的值就是这些 offsets 中最小值-1。这样在 LSO 之前数据都是已经 commit 或者 abort 的数据，只有这些数据才对 Consumer 可见，即 consumer 读取数据只能读取到 LSO 的位置。</p>
<ul>
<li>LSO 并没有持久化某一个位置，而是实时计算出来的，并保存在缓存中。</li>
</ul>
<p>（2）Absort Index 文件</p>
<p>Conusmer 发送 FetchRequest 中，新增了 Isolation 字段，表示是那种模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReplicaId MaxWaitTime MinBytes [TopicName [Partition FetchOffset MaxBytes]]</span><br><span class="line"></span><br><span class="line">  ReplicaId =&gt; int32</span><br><span class="line">  MaxWaitTime =&gt; int32</span><br><span class="line">  MinBytes =&gt; int32</span><br><span class="line">  TopicName =&gt; string</span><br><span class="line">  Partition =&gt; int32</span><br><span class="line">  FetchOffset =&gt; int64</span><br><span class="line">  MaxBytes =&gt; int32</span><br><span class="line">  Isolation =&gt; READ_COMMITTED | READ_UNCOMMITTED</span><br></pre></td></tr></table></figure>
<p>返回数据类型为 FetchResponse 的格式为：</p>
<p>ThrottleTime [TopicName [Partition ErrorCode HighwaterMarkOffset AbortedTransactions MessageSetSize MessageSet]]</p>
<p>对应各个给字段类型为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThrottleTime =&gt; int32</span><br><span class="line"> TopicName =&gt; string</span><br><span class="line"> Partition =&gt; int32</span><br><span class="line"> ErrorCode =&gt; int16</span><br><span class="line"> HighwaterMarkOffset =&gt; int64</span><br><span class="line"> AbortedTransactions =&gt; [PID FirstOffset]</span><br><span class="line">   PID =&gt; int64</span><br><span class="line">   FirstOffset =&gt; int64</span><br><span class="line"> MessageSetSize =&gt; int32</span><br></pre></td></tr></table></figure>
<ul>
<li>设置成 READ_UNCOMMITTED 模式时, the AbortedTransactions array is null.</li>
<li>设置为 READ_COMMITTED 时，the Last Stable Offset(LSO)，当事务提交之后，LSO 向前移动 offset</li>
</ul>
<p>数据如下：</p>
<ul>
<li>存放数据的 log</li>
</ul>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/1-3.png"></div><br></p>
<ul>
<li>存放 Absort Index 的内容如下：</li>
</ul>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/3-2.png"></div><br></p>
<p>执行读取数据流程如下：</p>
<p><strong>step1:</strong> 假设 consumer 读取数据的 fetched offsets 的区间是 0 到 4。</p>
<ul>
<li>首先，broker 读取 data log 中数据</li>
</ul>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/11-1.png"></div><br></p>
<ul>
<li>然后，broker 依次读取 abort index 的内容，发现 LSO 大于等于 4 就停止。如上可以获取到 P2 对应的 offset 从 2 到 5 的消息都是被丢弃的：</li>
</ul>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/12-1.png"></div><br></p>
<ul>
<li>最后，broker 将上面 data log 和 abort index 中满足条件的数据返回给 consumer。</li>
</ul>
<p><strong>step2 ：</strong>在 consumer 端根据 absrot index 中返回的内容，过滤丢弃的消息，最终给用户消息为</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/13-300x103.png"></div><br></p>
<h5 id="Absorted-Transaction-Index"><a href="#Absorted-Transaction-Index" class="headerlink" title="Absorted Transaction Index"></a>Absorted Transaction Index</h5><p>在 broker 中数据中新增一个索引文件，保存 aborted tranasation 对应的 offsets，只有事务执行 abort 时，才会往这个文件新增一个记录，初始这个文件是不存在的，只有第一条 abort 时，才会创建这个文件。</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/2-1-300x149.png"></div><br></p>
<p>这个索引文件结构的每一行结构是 TransactionEntry：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Version =&gt; int16</span><br><span class="line"> PID =&gt; int64</span><br><span class="line"> FirstOffset =&gt; int64</span><br><span class="line"> LastOffset =&gt; int64</span><br><span class="line"> LastStableOffset =&gt; int64</span><br></pre></td></tr></table></figure>
<p>当 broker 接受到控制消息（producer 执行 commitTransaction()或者 abortTransaction()）时, 执行如下操作:</p>
<p>(1)计算 LSO。</p>
<p>Broker 在缓存中维护了所有处于运行状态的事务对应的 initial offsets,LSO 的值就是这些 offsets 中最小值-1。</p>
<p>举例说明下 LSO 的计算，对于一个 data log 中内如如下</p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/31.png"></div><br></p>
<p>对应的 abort index 文件中内如如下：<strong>LSO 是递增的</strong></p>
<p><br><div align="center"><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/32.png"></div><br></p>
<p>(2)第二步 如果事务是提交状态，则在索引文件中新增 TransactionEntry。</p>
<p>(3)第三步 从 active 的 tranaction set 中移除这个 transaton，然后更新 LSO。</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>1、问题 1：producer 通过事务提交消息时抛异常了， 对于使用非事务的消费者，是否可以获取此消息？</p>
<p>对于事务消息，必须是执行 commit 或者 abstort 之后，消息才对消费者可见，即使是非事务的消费者。只是非事务消费者相比事务消费者区别，在于可以读取执行了 absort 的消息。</p>
<h3 id="8-6-其他思考"><a href="#8-6-其他思考" class="headerlink" title="8.6. 其他思考"></a>8.6. 其他思考</h3><p>1、如何保证消息不丢。</p>
<p>（1）在消费端可以建立一个日志表，和业务处理在一个事务</p>
<p>定时扫描没有表发送没有被处理的消息</p>
<p>（2）消费端，消费消息之后，修改消息表的中消息状态为已处理成功。</p>
<p>2、如何保证消息提交和业务处理在同一个事务内完成</p>
<p>在消费端可以建立一个日志表，和业务处理在一个事务</p>
<p>3、消费者角度，如何保证消息不被重复消费。</p>
<p>（1）通过 seek 操作</p>
<p>（2）通过 kafka 事务操作。</p>
<p>4、生产者角度，如何保证消息不重复生产</p>
<p>（1）kakfka 幂等性</p>
<h2 id="9-资料"><a href="#9-资料" class="headerlink" title="9. 资料"></a>9. 资料</h2><h3 id="9-1-官方资料"><a href="#9-1-官方资料" class="headerlink" title="9.1. 官方资料"></a>9.1. 官方资料</h3><p><a href="https://github.com/apache/kafka" target="_blank" rel="noopener">Github</a> | <a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="9-2-第三方资料"><a href="#9-2-第三方资料" class="headerlink" title="9.2. 第三方资料"></a>9.2. 第三方资料</h3><ul>
<li><a href="https://github.com/yahoo/kafka-manager" target="_blank" rel="noopener">Kafka Manager</a> - Kafka 管理工具</li>
<li><a href="http://www.infoq.com/cn/articles/kafka-analysis-part-1" target="_blank" rel="noopener">Kafka 剖析（一）：Kafka 背景及架构介绍</a></li>
<li><a href="https://hackernoon.com/thorough-introduction-to-apache-kafka-6fbf2989bbc1" target="_blank" rel="noopener">Thorough Introduction to Apache Kafka</a></li>
<li><a href="http://www.heartthinkdo.com/?p=2040#43" target="_blank" rel="noopener">Kafak(04) Kafka 生产者事务和幂等</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/12/programming/java/javaweb/architecture/分布式架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/12/programming/java/javaweb/architecture/分布式架构/" itemprop="url">分布式架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T00:00:00+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#分布式架构的演进">分布式架构的演进</a><ul>
<li><a href="#初始阶段架构">初始阶段架构</a></li>
<li><a href="#应用服务和数据服务分离">应用服务和数据服务分离</a></li>
<li><a href="#使用缓存改善性能">使用缓存改善性能</a></li>
<li><a href="#使用应用服务器集群">使用应用服务器集群</a></li>
<li><a href="#数据库读写分离">数据库读写分离</a></li>
<li><a href="#反向代理和-cdn-加速">反向代理和 CDN 加速</a></li>
<li><a href="#分布式文件系统和分布式数据库">分布式文件系统和分布式数据库</a></li>
<li><a href="#使用-nosql-和搜索引擎">使用 NoSQL 和搜索引擎</a></li>
<li><a href="#业务拆分">业务拆分</a></li>
<li><a href="#分布式服务">分布式服务</a></li>
</ul>
</li>
<li><a href="#分布式架构的问题">分布式架构的问题</a></li>
<li><a href="#分布式架构的关键技术">分布式架构的关键技术</a><ul>
<li><a href="#消息队列">消息队列</a></li>
<li><a href="#服务化">服务化</a></li>
<li><a href="#服务总线">服务总线</a></li>
</ul>
</li>
<li><a href="#分布式架构的通信模式">分布式架构的通信模式</a><ul>
<li><a href="#requestresponse-模式同步模式">request/response 模式（同步模式）</a></li>
<li><a href="#callback异步模式">Callback（异步模式）</a></li>
<li><a href="#future-模式">Future 模式</a></li>
<li><a href="#oneway-模式">Oneway 模式</a></li>
<li><a href="#reliable-模式">Reliable 模式</a></li>
</ul>
</li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="分布式架构的演进"><a href="#分布式架构的演进" class="headerlink" title="分布式架构的演进"></a>分布式架构的演进</h2><h2 id="分布式架构的问题"><a href="#分布式架构的问题" class="headerlink" title="分布式架构的问题"></a>分布式架构的问题</h2><ul>
<li>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</li>
<li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</li>
<li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</li>
<li>服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？</li>
<li>一个服务有多个业务消费者，如何确保服务质量？</li>
<li>随着服务的不停升级，总有些意想不到的事发生，比如 cache 写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？</li>
</ul>
<h2 id="分布式架构的关键技术"><a href="#分布式架构的关键技术" class="headerlink" title="分布式架构的关键技术"></a>分布式架构的关键技术</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列通过消息对象分解系统耦合性，不同子系统处理同一个消息。</p>
<h4 id="消息队列框架"><a href="#消息队列框架" class="headerlink" title="消息队列框架"></a>消息队列框架</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式架构-消息队列框架.jpg" width="600"><br></div>

<h4 id="消息队列原理"><a href="#消息队列原理" class="headerlink" title="消息队列原理"></a>消息队列原理</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式架构-消息队列原理.jpg" width="600"><br></div>

<h3 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h3><p>服务框架通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用。</p>
<p>服务框架是一个点对点模型。</p>
<p>服务框架面向同构系统。</p>
<p>适合：移动应用、互联网应用、外部系统。</p>
<h4 id="服务化框架"><a href="#服务化框架" class="headerlink" title="服务化框架"></a>服务化框架</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式架构-服务化框架.jpg" width="600"><br></div>

<h4 id="服务化原理"><a href="#服务化原理" class="headerlink" title="服务化原理"></a>服务化原理</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式架构-服务化原理.jpg" width="600"><br></div>

<h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>服务治理是服务框架/服务总线的核心功能。所谓服务治理，是指服务的提供方和消费方达成一致的约定，保证服务的高质量。服务治理功能可以解决将某些特定流量引入某一批机器，以及限制某些非法消费者的恶意访问，并在提供者处理量达到一定程度是，拒绝接受新的访问。</p>
<p>当前比较流行的服务治理框架：Dubbo。</p>
<h3 id="服务总线"><a href="#服务总线" class="headerlink" title="服务总线"></a>服务总线</h3><p>服务总线同服务框架一样，均是通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用。</p>
<p>服务总线是一个总线式的模型。</p>
<p>服务总线面向同构、异构系统。</p>
<p>适合：内部系统。</p>
<h4 id="服务总线框架"><a href="#服务总线框架" class="headerlink" title="服务总线框架"></a>服务总线框架</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式架构-服务总线框架.jpg" width="600"><br></div>

<h4 id="服务总线原理"><a href="#服务总线原理" class="headerlink" title="服务总线原理"></a>服务总线原理</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式架构-服务总线原理.jpg" width="600"><br></div>

<h2 id="分布式架构的通信模式"><a href="#分布式架构的通信模式" class="headerlink" title="分布式架构的通信模式"></a>分布式架构的通信模式</h2><h3 id="request-response-模式（同步模式）"><a href="#request-response-模式（同步模式）" class="headerlink" title="request/response 模式（同步模式）"></a>request/response 模式（同步模式）</h3><p>客户端发起请求一直阻塞到服务端返回请求为止。</p>
<h3 id="Callback（异步模式）"><a href="#Callback（异步模式）" class="headerlink" title="Callback（异步模式）"></a>Callback（异步模式）</h3><p>客户端发送一个 RPC 请求给服务器，服务端处理后再发送一个消息给消息发送端提供的 callback 端点，此类情况非常合适以下场景：A 组件发送 RPC 请求给 B，B 处理完成后，需要通知 A 组件做后续处理。</p>
<h3 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h3><p>客户端发送完请求后，继续做自己的事情，返回一个包含消息结果的 Future 对象。客户端需要使用返回结果时，使用 Future 对象的.get(),如果此时没有结果返回的话，会一直阻塞到有结果返回为止。</p>
<h3 id="Oneway-模式"><a href="#Oneway-模式" class="headerlink" title="Oneway 模式"></a>Oneway 模式</h3><p>客户端调用完继续执行，不管接收端是否成功。</p>
<h3 id="Reliable-模式"><a href="#Reliable-模式" class="headerlink" title="Reliable 模式"></a>Reliable 模式</h3><p>为保证通信可靠，将借助于消息中心来实现消息的可靠送达，请求将做持久化存储，在接收方在线时做送达，并由消息中心保证异常重试。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://www.zhihu.com/question/22764869/answer/31277656" target="_blank" rel="noopener">https://www.zhihu.com/question/22764869/answer/31277656</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/12/programming/java/javaweb/distributed/rpc/dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/12/programming/java/javaweb/distributed/rpc/dubbo/" itemprop="url">Dubbo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T00:00:00+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><blockquote>
<p>Dubbo 是一个基于 Java 开发的高性能 RPC 框架。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#quickstart">QuickStart</a></li>
<li><a href="#dubbo-配置">Dubbo 配置</a><ul>
<li><a href="#配置方式">配置方式</a></li>
<li><a href="#配置项">配置项</a></li>
</ul>
</li>
<li><a href="#dubbo-支持的协议">Dubbo 支持的协议</a></li>
<li><a href="#服务治理">服务治理</a><ul>
<li><a href="#集群容错">集群容错</a></li>
<li><a href="#负载均衡">负载均衡</a></li>
<li><a href="#路由规则">路由规则</a></li>
<li><a href="#服务降级">服务降级</a></li>
<li><a href="#访问控制">访问控制</a></li>
<li><a href="#动态配置">动态配置</a></li>
</ul>
</li>
<li><a href="#dubbo-架构">Dubbo 架构</a><ul>
<li><a href="#整体设计">整体设计</a></li>
</ul>
</li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Dubbo 是一个基于 Java 开发的高性能 RPC 框架。</p>
<p>Dubbo 的三个关键功能：</p>
<ol>
<li>基于接口的远程调用；</li>
<li>容错机制以及负载均衡；</li>
<li>自动服务注册以及自动服务发现。</li>
</ol>
<h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>（1）添加 maven 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）定义 Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）实现 Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）配置 Provider</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（5）启动 Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                <span class="keyword">new</span> String[] &#123;<span class="string">"META-INF/spring/dubbo-demo-provider.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        <span class="comment">// press any key to exit</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（6）配置 Consumer</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（7）启动 Consumer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"META-INF/spring/dubbo-demo-consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        <span class="comment">// obtain proxy object for remote invocation</span></span><br><span class="line">        DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>);</span><br><span class="line">        <span class="comment">// execute remote invocation</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">"world"</span>);</span><br><span class="line">        <span class="comment">// show the result</span></span><br><span class="line">        System.out.println(hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dubbo-配置"><a href="#Dubbo-配置" class="headerlink" title="Dubbo 配置"></a>Dubbo 配置</h2><p>dubbo 所有配置最终都将转换为 URL 表示，并由服务提供方生成，经注册中心传递给消费方，各属性对应 URL 的参数，参见配置项一览表中的 “对应 URL 参数” 列。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>只有 group，interface，version 是服务的匹配条件，三者决定是不是同一个服务，其它配置项均为调优和治理参数。</p>
<p><strong>URL 格式</strong></p>
<p><code>protocol://username:password@host:port/path?key=value&amp;key=value</code></p>
</blockquote>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>Dubbo 支持多种配置方式：</p>
<ul>
<li>xml 配置</li>
<li>properties 配置</li>
<li>API 配置</li>
<li>注解配置</li>
</ul>
<p>如果同时存在多种配置方式，遵循以下覆盖策略：</p>
<ul>
<li>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</li>
<li>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</li>
<li>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo配置覆盖策略.jpg" width="300"><br></div>

<h4 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h4><p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoServiceLocal"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoServiceRemote"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="properties-配置"><a href="#properties-配置" class="headerlink" title="properties 配置"></a>properties 配置</h4><p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=foo</span><br><span class="line">dubbo.application.owner=bar</span><br><span class="line">dubbo.registry.address=10.20.153.10:9090</span><br></pre></td></tr></table></figure>
<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>所有配置项分为三大类</p>
<ul>
<li><p>服务发现：表示该配置项用于服务的注册与发现，目的是让消费方找到提供方。</p>
</li>
<li><p>服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。</p>
</li>
<li><p>性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>标签</th>
<th>用途</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>dubbo:service</td>
<td>服务配置</td>
<td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>
</tr>
<tr>
<td>dubbo:reference</td>
<td>引用配置</td>
<td>用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>
</tr>
<tr>
<td>dubbo:protocol</td>
<td>协议配置</td>
<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>
</tr>
<tr>
<td>dubbo:application</td>
<td>应用配置</td>
<td>用于配置当前应用信息，不管该应用是提供者还是消费者</td>
</tr>
<tr>
<td>dubbo:module</td>
<td>模块配置</td>
<td>用于配置当前模块信息，可选</td>
</tr>
<tr>
<td>dubbo:registry</td>
<td>注册中心配置</td>
<td>用于配置连接注册中心相关信息</td>
</tr>
<tr>
<td>dubbo:monitor</td>
<td>监控中心配置</td>
<td>用于配置连接监控中心相关信息，可选</td>
</tr>
<tr>
<td>dubbo:provider</td>
<td>提供方配置</td>
<td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td>dubbo:consumer</td>
<td>消费方配置</td>
<td>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td>dubbo:method</td>
<td>方法配置</td>
<td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>
</tr>
<tr>
<td>dubbo:argument</td>
<td>参数配置</td>
<td>用于指定方法参数配置</td>
</tr>
</tbody>
</table>
<blockquote>
<p>详细配置说明请参考：<a href="http://dubbo.apache.org/books/dubbo-user-book/references/xml/introduction.html" target="_blank" rel="noopener">官方配置</a></p>
</blockquote>
<h4 id="配置之间的关系"><a href="#配置之间的关系" class="headerlink" title="配置之间的关系"></a>配置之间的关系</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo配置关系.jpg" width="600"><br></div>

<h4 id="配置覆盖关系"><a href="#配置覆盖关系" class="headerlink" title="配置覆盖关系"></a>配置覆盖关系</h4><p>以 timeout 为例，显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：</p>
<ul>
<li>方法级优先，接口级次之，全局配置再次之。</li>
<li>如果级别一样，则消费方优先，提供方次之。</li>
</ul>
<p>其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo配置覆盖关系.jpg" width="500"><br></div>

<h2 id="Dubbo-支持的协议"><a href="#Dubbo-支持的协议" class="headerlink" title="Dubbo 支持的协议"></a>Dubbo 支持的协议</h2><p>Dubbo 支持以下通信协议：</p>
<ul>
<li>dubbo</li>
<li>rmi</li>
<li>hessian</li>
<li>http</li>
<li>webservice</li>
<li>thrift</li>
<li>memcached</li>
<li>redis</li>
</ul>
<p>不同协议适合不同的服务场景，可以根据实际应用场景来选择合适的协议。</p>
<p>dubbo 协议是 dubbo 默认的协议。dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
<p>选用哪个协议，可以通过 <code>&lt;dubbo:protocol&gt;</code> 标签配置。</p>
<blockquote>
<p>更多详情请参考：<a href="https://dubbo.gitbooks.io/dubbo-user-book/references/protocol/introduction.html" target="_blank" rel="noopener">Dubbo 官方协议参考手册</a></p>
</blockquote>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><ul>
<li>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</li>
<li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</li>
<li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</li>
</ul>
<p>以上问题可以归纳为服务治理问题，这也是 Dubbo 的核心功能。</p>
<h3 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo集群容错.jpg"><br></div>

<ul>
<li><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。</li>
<li><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>
<li><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</li>
<li><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><ul>
<li>随机，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<h4 id="LeastActive"><a href="#LeastActive" class="headerlink" title="LeastActive"></a>LeastActive</h4><ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h4 id="ConsistentHash"><a href="#ConsistentHash" class="headerlink" title="ConsistentHash"></a>ConsistentHash</h4><ul>
<li>一致性 Hash，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<h3 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h3><p>路由规则决定一次 dubbo 服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展。</p>
<p>向注册中心写入路由规则的操作通常由监控中心或治理中心的页面完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">"zookeeper://10.20.153.10:2181"</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">"condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule="</span> + URL.encode(<span class="string">"host = 10.20.153.10 =&gt; host = 10.20.153.11"</span>) + <span class="string">"));</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>condition://</strong> - 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。</li>
<li><strong>0.0.0.0</strong> - 表示对所有 IP 地址生效，如果只想对某个 IP 的生效，请填入具体 IP，必填。</li>
<li><strong>com.foo.BarService</strong> - 表示只对指定服务生效，必填。</li>
<li><strong>category=routers</strong> - 表示该数据为动态配置类型，必填。</li>
<li><strong>dynamic=false</strong> - 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。</li>
<li><strong>enabled=true</strong> - 覆盖规则是否生效，可不填，缺省生效。</li>
<li><strong>force=false</strong> - 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 flase。</li>
<li><strong>runtime=false</strong> - 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 flase。</li>
<li><strong>priority=1</strong> - 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。</li>
<li><strong>rule=URL.encode(“host = 10.20.153.10 =&gt; host = 10.20.153.11”)</strong> - 表示路由规则的内容，必填。</li>
</ul>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">"zookeeper://10.20.153.10:2181"</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">"override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null"</span>));</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p><strong>mock=force:return+null</strong> 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。<br>还可以改为 <strong>mock=fail:return+null</strong> 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><h4 id="直连"><a href="#直连" class="headerlink" title="直连"></a>直连</h4><p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo访问控制-直连.jpg"><br></div>

<p>配置方式：</p>
<p>（1）通过 XML 配置</p>
<p>如果是线上需求需要点对点，可在 <a href="dubbo:reference" target="_blank" rel="noopener">dubbo:reference</a> 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"xxxService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.xxx.XxxService"</span> <span class="attr">url</span>=<span class="string">"dubbo://localhost:20890"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）通过 -D 参数指定</p>
<p>在 JVM 启动参数中加入-D 参数映射服务地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</span><br></pre></td></tr></table></figure>
<p>（3）通过文件映射<br>如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 <a href="dubbo:reference" target="_blank" rel="noopener">dubbo:reference</a> 中的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddubbo.resolve.file=xxx.properties</span><br></pre></td></tr></table></figure>
<p>然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.xxx.XxxService=dubbo://localhost:20890</span><br></pre></td></tr></table></figure>
<h4 id="只订阅"><a href="#只订阅" class="headerlink" title="只订阅"></a>只订阅</h4><p>为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。</p>
<p>可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
<p>禁用注册配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> <span class="attr">register</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090?register=false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="只注册"><a href="#只注册" class="headerlink" title="只注册"></a>只注册</h4><p>如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。</p>
<p>禁用订阅配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"hzRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"qdRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">subscribe</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"hzRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"qdRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090?subscribe=false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h4><p>有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;10.20.141.150:9090&quot; dynamic=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;10.20.141.150:9090?dynamic=false&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>服务提供者初次注册时为禁用状态，需人工启用。断线时，将不会被自动删除，需人工禁用。</p>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>向注册中心写入动态配置覆盖规则。该功能通常由监控中心或治理中心的页面完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">"zookeeper://10.20.153.10:2181"</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">"override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;timeout=1000"</span>));</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><strong>override://</strong> - 表示数据采用覆盖方式，支持 override 和 absent，可扩展，必填。</li>
<li><strong>0.0.0.0</strong> - 表示对所有 IP 地址生效，如果只想覆盖某个 IP 的数据，请填入具体 IP，必填。</li>
<li><strong>com.foo.BarService</strong> - 表示只对指定服务生效，必填。</li>
<li><strong>category=configurators</strong> - 表示该数据为动态配置类型，必填。</li>
<li><strong>dynamic=false</strong> - 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。</li>
<li><strong>enabled=true</strong> - 覆盖规则是否生效，可不填，缺省生效。</li>
<li><strong>application=foo</strong> - 表示只对指定应用生效，可不填，表示对所有应用生效。</li>
<li><strong>timeout=1000</strong> - 表示将满足以上条件的 timeout 参数的值覆盖为 1000。如果想覆盖其它参数，直接加在 override 的 URL 参数上。</li>
</ul>
<p>示例：</p>
<ul>
<li>禁用提供者：(通常用于临时踢除某台提供者机器，相似的，禁止消费者访问请使用路由规则)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;disbaled=true</span><br></pre></td></tr></table></figure>
<ul>
<li>调整权重：(通常用于容量评估，缺省权重为 100)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;weight=200</span><br></pre></td></tr></table></figure>
<ul>
<li>调整负载均衡策略：(缺省负载均衡策略为 random)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;loadbalance=leastactive</span><br></pre></td></tr></table></figure>
<ul>
<li>服务降级：(通常用于临时屏蔽某个出错的非关键服务)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null</span><br></pre></td></tr></table></figure>
<h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo基本架构.png" width="500"><br></div>

<p>节点角色：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<p>调用关系：</p>
<ol>
<li>务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo整体设计.jpg"><br></div>

<p>图例说明：</p>
<ul>
<li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li>
<li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li>
<li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li>
<li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li>
</ul>
<h4 id="各层说明"><a href="#各层说明" class="headerlink" title="各层说明"></a>各层说明</h4><ul>
<li><strong>config 配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<h4 id="各层关系说明"><a href="#各层关系说明" class="headerlink" title="各层关系说明"></a>各层关系说明</h4><ul>
<li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li>
<li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</li>
<li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li>
<li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</li>
<li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li>
</ul>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">Github</a> | <a href="https://dubbo.gitbooks.io/dubbo-user-book/content/" target="_blank" rel="noopener">用户手册</a> | <a href="https://dubbo.gitbooks.io/dubbo-dev-book/content/" target="_blank" rel="noopener">开发手册</a> | <a href="https://dubbo.gitbooks.io/dubbo-admin-book/content/" target="_blank" rel="noopener">管理员手册</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/06/11/database/nosql/redis/Redis事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/11/database/nosql/redis/Redis事件/" itemprop="url">Redis 事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T00:00:00+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-事件"><a href="#Redis-事件" class="headerlink" title="Redis 事件"></a>Redis 事件</h1><p>Redis 服务器是一个事件驱动程序。</p>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用响应的事件处理器。</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p>
<p>时间事件又分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用响应的事件处理器。</p>
<h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据 remaind_ms 的值，创建 timeval</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">    procesFileEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure>
<p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure>
<p>从事件处理的角度来看，服务器运行流程如下：</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/redis/Redis事件的调度与执行.png"><br></div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/27/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/blog/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/29/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">381</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">76</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dunwu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:forbreak@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
