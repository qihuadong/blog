<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="张鹏的博客">
<meta property="og:url" content="http://yoursite.com/page/27/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张鹏的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/27/">





  <title>张鹏的博客 - 大道至简，知易行难</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/09/programming/java/javaweb/distributed/分布式原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/09/programming/java/javaweb/distributed/分布式原理/" itemprop="url">分布式原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式原理"><a href="#分布式原理" class="headerlink" title="分布式原理"></a>分布式原理</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-分布式术语">1. 分布式术语</a><ul>
<li><a href="#11-异常">1.1. 异常</a></li>
<li><a href="#12-超时">1.2. 超时</a></li>
<li><a href="#13-衡量指标">1.3. 衡量指标</a></li>
</ul>
</li>
<li><a href="#2-数据分布">2. 数据分布</a><ul>
<li><a href="#21-哈希分布">2.1. 哈希分布</a></li>
<li><a href="#22-顺序分布">2.2. 顺序分布</a></li>
<li><a href="#23-负载均衡">2.3. 负载均衡</a></li>
</ul>
</li>
<li><a href="#3-分布式理论">3. 分布式理论</a><ul>
<li><a href="#31-cap">3.1. CAP</a></li>
<li><a href="#32-base">3.2. BASE</a></li>
</ul>
</li>
<li><a href="#4-分布式事务问题">4. 分布式事务问题</a><ul>
<li><a href="#41-两阶段提交2pc">4.1. 两阶段提交（2PC）</a></li>
<li><a href="#42-补偿事务tcc">4.2. 补偿事务（TCC）</a></li>
<li><a href="#43-本地消息表异步确保">4.3. 本地消息表（异步确保）</a></li>
<li><a href="#44-mq-事务消息">4.4. MQ 事务消息</a></li>
</ul>
</li>
<li><a href="#5-共识性问题">5. 共识性问题</a><ul>
<li><a href="#51-paxos">5.1. Paxos</a></li>
<li><a href="#52-raft">5.2. Raft</a></li>
</ul>
</li>
<li><a href="#6-分布式缓存问题">6. 分布式缓存问题</a><ul>
<li><a href="#61-缓存雪崩">6.1. 缓存雪崩</a></li>
<li><a href="#62-缓存穿透">6.2. 缓存穿透</a></li>
<li><a href="#63-缓存预热">6.3. 缓存预热</a></li>
<li><a href="#64-缓存更新">6.4. 缓存更新</a></li>
<li><a href="#65-缓存降级">6.5. 缓存降级</a></li>
</ul>
</li>
<li><a href="#7-参考资料">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-分布式术语"><a href="#1-分布式术语" class="headerlink" title="1. 分布式术语"></a>1. 分布式术语</h2><h3 id="1-1-异常"><a href="#1-1-异常" class="headerlink" title="1.1. 异常"></a>1.1. 异常</h3><h4 id="服务器宕机"><a href="#服务器宕机" class="headerlink" title="服务器宕机"></a>服务器宕机</h4><p>内存错误、服务器停电等都会导致服务器宕机，此时节点无法正常工作，称为不可用。</p>
<p>服务器宕机会导致节点失去所有内存信息，因此需要将内存信息保存到持久化介质上。</p>
<h4 id="网络异常"><a href="#网络异常" class="headerlink" title="网络异常"></a>网络异常</h4><p>有一种特殊的网络异常称为——<strong>网络分区</strong> ，即集群的所有节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<h4 id="磁盘故障"><a href="#磁盘故障" class="headerlink" title="磁盘故障"></a>磁盘故障</h4><p>磁盘故障是一种发生概率很高的异常。</p>
<p>使用冗余机制，将数据存储到多台服务器。</p>
<h3 id="1-2-超时"><a href="#1-2-超时" class="headerlink" title="1.2. 超时"></a>1.2. 超时</h3><p>在分布式系统中，一个请求除了成功和失败两种状态，还存在着超时状态。</p>
<p>可以将服务器的操作设计为具有 <strong>幂等性</strong> ，即执行多次的结果与执行一次的结果相同。如果使用这种方式，当出现超时的时候，可以不断地重新请求直到成功。</p>
<h3 id="1-3-衡量指标"><a href="#1-3-衡量指标" class="headerlink" title="1.3. 衡量指标"></a>1.3. 衡量指标</h3><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>常见的性能指标有：吞吐量、响应时间。</p>
<p>其中，吞吐量指系统在某一段时间可以处理的请求总数，通常为每秒的读操作数或者写操作数；响应时间指从某个请求发出到接收到返回结果消耗的时间。</p>
<p>这两个指标往往是矛盾的，追求高吞吐的系统，往往很难做到低响应时间，解释如下：</p>
<ul>
<li><p>在无并发的系统中，吞吐量为响应时间的倒数，例如响应时间为 10 ms，那么吞吐量为 100 req/s，因此高吞吐也就意味着低响应时间。</p>
</li>
<li><p>但是在并发的系统中，由于一个请求在调用 I/O 资源的时候，需要进行等待。服务器端一般使用的是异步等待方式，即等待的请求被阻塞之后不需要一直占用 CPU 资源。这种方式能大大提高 CPU 资源的利用率，例如上面的例子中，单个请求在无并发的系统中响应时间为 10 ms，如果在并发的系统中，那么吞吐量将大于 100 req/s。因此为了追求高吞吐量，通常会提高并发程度。但是并发程度的增加，会导致请求的平均响应时间也增加，因为请求不能马上被处理，需要和其它请求一起进行并发处理，响应时间自然就会增高。</p>
</li>
</ul>
<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>可用性指系统在面对各种异常时可以提供正常服务的能力。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>可以从两个角度理解一致性：从客户端的角度，读写操作是否满足某种特性；从服务器的角度，多个数据副本之间是否一致。</p>
<h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>指系统通过扩展集群服务器规模来提高性能的能力。理想的分布式系统需要实现“线性可扩展”，即随着集群规模的增加，系统的整体性能也会线性增加。</p>
<h2 id="2-数据分布"><a href="#2-数据分布" class="headerlink" title="2. 数据分布"></a>2. 数据分布</h2><p>分布式存储系统的数据分布在多个节点中，常用的数据分布方式有哈希分布和顺序分布。</p>
<p>数据库的水平切分（Sharding）也是一种分布式存储方法，下面的数据分布方法同样适用于 Sharding。</p>
<h3 id="2-1-哈希分布"><a href="#2-1-哈希分布" class="headerlink" title="2.1. 哈希分布"></a>2.1. 哈希分布</h3><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<p><strong>一致性哈希</strong></p>
<p>Distributed Hash Table（DHT）：对于哈希空间 [0, 2<sup>n</sup>-1]，将该哈希空间看成一个哈希环，将每个节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<p>一致性哈希的优点是在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将数据对象 C 重新存放到节点 X 上即可，对于节点 A、B、D 都没有影响。</p>
<h3 id="2-2-顺序分布"><a href="#2-2-顺序分布" class="headerlink" title="2.2. 顺序分布"></a>2.2. 顺序分布</h3><p>哈希分布式破坏了数据的有序性，顺序分布则不会。</p>
<p>顺序分布的数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如下图中，User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p>
<p>顺序分布的优点是可以充分利用每个节点的空间，而哈希分布很难控制一个节点存储多少数据。</p>
<p>但是顺序分布需要使用一个映射表来存储数据到节点的映射，这个映射表通常使用单独的节点来存储。当数据量非常大时，映射表也随着变大，那么一个节点就可能无法存放下整个映射表。并且单个节点维护着整个映射表的开销很大，查找速度也会变慢。为了解决以上问题，引入了一个中间层，也就是 Meta 表，从而分担映射表的维护工作。</p>
<h3 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3. 负载均衡"></a>2.3. 负载均衡</h3><p>衡量负载的因素很多，如 CPU、内存、磁盘等资源使用情况、读写请求数等。</p>
<p>分布式系统存储应当能够自动负载均衡，当某个节点的负载较高，将它的部分数据迁移到其它节点。</p>
<p>每个集群都有一个总控节点，其它节点为工作节点，由总控节点根据全局负载信息进行整体调度，工作节点定时发送心跳包（Heartbeat）将节点负载相关的信息发送给总控节点。</p>
<p>一个新上线的工作节点，由于其负载较低，如果不加控制，总控节点会将大量数据同时迁移到该节点上，造成该节点一段时间内无法工作。因此负载均衡操作需要平滑进行，新加入的节点需要较长的一段时间来达到比较均衡的状态。</p>
<h2 id="3-分布式理论"><a href="#3-分布式理论" class="headerlink" title="3. 分布式理论"></a>3. 分布式理论</h2><h3 id="3-1-CAP"><a href="#3-1-CAP" class="headerlink" title="3.1. CAP"></a>3.1. CAP</h3><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式理论-CAP.jpg" width="450"><br></div>

<h4 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h4><p>一致性指的是多个数据副本是否能保持一致的特性。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<h4 id="可用性-1"><a href="#可用性-1" class="headerlink" title="可用性"></a>可用性</h4><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h4><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h4 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h4><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="3-2-BASE"><a href="#3-2-BASE" class="headerlink" title="3.2. BASE"></a>3.2. BASE</h3><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式理论-BASE.png"><br></div>

<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="4-分布式事务问题"><a href="#4-分布式事务问题" class="headerlink" title="4. 分布式事务问题"></a>4. 分布式事务问题</h2><h3 id="4-1-两阶段提交（2PC）"><a href="#4-1-两阶段提交（2PC）" class="headerlink" title="4.1. 两阶段提交（2PC）"></a>4.1. 两阶段提交（2PC）</h3><p>两阶段提交（Two-phase Commit，2PC）</p>
<p>主要用于实现分布式事务，分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</p>
<p>通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式事务两阶段提交-01.jpg"><br></div>

<h5 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h5><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式事务两阶段提交-02.jpg"><br></div><br>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。<br><br>#### 问题<br><br>##### 同步阻塞<br><br>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。<br><br>##### 单点问题<br><br>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。<br><br>##### 数据不一致<br><br>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。<br><br>##### 太过保守<br><br>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。<br><br>#### 2PC 优缺点<br><br>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致）<br>缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。<br><br>### 4.2. 补偿事务（TCC）<br><br>补偿事务（TCC）其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：<br><br>1.  Try 阶段主要是对业务系统做检测及资源预留。<br>2.  Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。<br>3.  Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。<br><br>举个例子，假设 Bob 要向 Smith 转账，思路大概是：<br><br>1.  首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。<br>2.  在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。<br>3.  如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。<br><br>#### TCC 优缺点<br><br>- 优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。<br>- 缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。<br><br>### 4.3. 本地消息表（异步确保）<br><br>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。<br><br>1.  在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。<br>2.  之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。<br>3.  在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。<br><br><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式事务本地消息.jpg"><br></div>

<p>这种方案遵循 BASE 理论，采用的是最终一致性。</p>
<p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p>
<h4 id="本地消息表优缺点"><a href="#本地消息表优缺点" class="headerlink" title="本地消息表优缺点"></a>本地消息表优缺点</h4><ul>
<li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li>
<li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li>
</ul>
<h3 id="4-4-MQ-事务消息"><a href="#4-4-MQ-事务消息" class="headerlink" title="4.4. MQ 事务消息"></a>4.4. MQ 事务消息</h3><p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p>
<ol>
<li>Prepared 消息，会拿到消息的地址。</li>
<li>执行本地事务。</li>
<li>通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ol>
<p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<h4 id="MQ-事务消息优缺点"><a href="#MQ-事务消息优缺点" class="headerlink" title="MQ 事务消息优缺点"></a>MQ 事务消息优缺点</h4><ul>
<li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li>
<li>缺点：实现难度大，主流 MQ 不支持。</li>
</ul>
<h2 id="5-共识性问题"><a href="#5-共识性问题" class="headerlink" title="5. 共识性问题"></a>5. 共识性问题</h2><h3 id="5-1-Paxos"><a href="#5-1-Paxos" class="headerlink" title="5.1. Paxos"></a>5.1. Paxos</h3><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<p>算法需要满足 safety 和 liveness 两方面的约束要求（实际上这两个基础属性是大部分分布式算法都该考虑的）：</p>
<ul>
<li>safety：保证决议结果是对的，无歧义的，不会出现错误情况。<ul>
<li>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；</li>
<li>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；</li>
</ul>
</li>
<li>liveness：保证决议过程能在有限时间内完成。<ul>
<li>决议总会产生，并且 learners 能获得被批准（chosen）的决议。</li>
</ul>
</li>
</ul>
<p>基本过程包括 proposer 提出提案，先争取大多数 acceptor 的支持，超过一半支持时，则发送结案结果给所有人进行确认。一个潜在的问题是 proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新的一轮提案的 proposer 都恰好故障，系统则永远无法达成一致（概率很小）。</p>
<p>Paxos 能保证在超过 $1/2$ 的正常节点存在时，系统能达成共识。</p>
<h4 id="单个提案者-多接收者"><a href="#单个提案者-多接收者" class="headerlink" title="单个提案者+多接收者"></a>单个提案者+多接收者</h4><p>如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接收者的投票，即可认为通过，因为系统中不存在其他的提案。</p>
<p>但一旦提案者故障，则系统无法工作。</p>
<h4 id="多个提案者-单个接收者"><a href="#多个提案者-单个接收者" class="headerlink" title="多个提案者+单个接收者"></a>多个提案者+单个接收者</h4><p>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。</p>
<p>缺陷也是容易发生单点故障，包括接收者故障或首个提案者节点故障。</p>
<p>以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。</p>
<p>当提案者和接收者都推广到多个的情形，会出现一些挑战。</p>
<h4 id="多个提案者-多个接收者"><a href="#多个提案者-多个接收者" class="headerlink" title="多个提案者+多个接收者"></a>多个提案者+多个接收者</h4><p>既然限定单提案者或单接收者都会出现故障，那么就得允许出现多个提案者和多个接收者。问题一下子变得复杂了。</p>
<p>一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个数字来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。</p>
<p>另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。</p>
<p>如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。</p>
<p>此外，提案者即便收到了多数接收者的投票，也不敢说就一定通过。因为在此过程中系统可能还有其它的提案。</p>
<h3 id="5-2-Raft"><a href="#5-2-Raft" class="headerlink" title="5.2. Raft"></a>5.2. Raft</h3><p>Raft 算法是 Paxos 算法的一种简化实现。</p>
<p>包括三种角色：leader、candidate 和 follower，其基本过程为：</p>
<ul>
<li><strong>Leader 选举</strong> - 每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；</li>
<li><strong>同步 log</strong> - leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；</li>
</ul>
<p><em>注：此处 log 并非是指日志消息，而是各种事件的发生记录。</em></p>
<h4 id="单个-Candidate-的竞选"><a href="#单个-Candidate-的竞选" class="headerlink" title="单个 Candidate 的竞选"></a>单个 Candidate 的竞选</h4><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-candidate-01.gif"><br></div>

<ul>
<li>此时 A 发送投票请求给其它所有节点。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-candidate-02.gif"><br></div>

<ul>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-candidate-03.gif"><br></div>

<ul>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-candidate-04.gif"><br></div>

<h4 id="多个-Candidate-竞选"><a href="#多个-Candidate-竞选" class="headerlink" title="多个 Candidate 竞选"></a>多个 Candidate 竞选</h4><ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-multi-candidate-01.gif"><br></div>

<ul>
<li>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-multi-candidate-02.gif"><br></div>

<h4 id="同步日志"><a href="#同步日志" class="headerlink" title="同步日志"></a>同步日志</h4><ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-sync-log-01.gif"><br></div>

<ul>
<li>Leader 会把修改复制到所有 Follower。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-sync-log-02.gif"><br></div>

<ul>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-sync-log-03.gif"><br></div>

<ul>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/raft-sync-log-04.gif"><br></div>

<h2 id="6-分布式缓存问题"><a href="#6-分布式缓存问题" class="headerlink" title="6. 分布式缓存问题"></a>6. 分布式缓存问题</h2><h3 id="6-1-缓存雪崩"><a href="#6-1-缓存雪崩" class="headerlink" title="6.1. 缓存雪崩"></a>6.1. 缓存雪崩</h3><p>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>解决方案：</p>
<ul>
<li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。</li>
<li>还有一个简单的方案，就是将缓存失效时间分散开，不要所有缓存时间长度都设置成 5 分钟或者 10 分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
</ul>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<h3 id="6-2-缓存穿透"><a href="#6-2-缓存穿透" class="headerlink" title="6.2. 缓存穿透"></a>6.2. 缓存穿透</h3><p>缓存穿透是指：用户查询的数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p>
<p>解决方案：</p>
<ol>
<li>在封装的缓存 SET 和 GET 部分增加个步骤，如果查询一个 KEY 不存在，就以这个 KEY 为前缀设定一个标识 KEY；以后再查询该 KEY 的时候，先查询标识 KEY，如果标识 KEY 存在，就返回一个协定好的非 false 或者 NULL 值，然后 APP 做相应的处理，这样缓存层就不会被穿透。当然这个验证 KEY 的失效时间不能太长。</li>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h3 id="6-3-缓存预热"><a href="#6-3-缓存预热" class="headerlink" title="6.3. 缓存预热"></a>6.3. 缓存预热</h3><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="6-4-缓存更新"><a href="#6-4-缓存更新" class="headerlink" title="6.4. 缓存更新"></a>6.4. 缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="6-5-缓存降级"><a href="#6-5-缓存降级" class="headerlink" title="6.5. 缓存降级"></a>6.5. 缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul>
<li>杨传辉. 大规模分布式存储系统: 原理解析与架构实战[M]. 机械工业出版社, 2013.</li>
<li><a href="https://www.gitbook.com/book/yeasy/blockchain_guide/details" target="_blank" rel="noopener">区块链技术指南</a></li>
<li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener">NEAT ALGORITHMS - PAXOS</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/09/programming/java/javaweb/distributed/分布式技术实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/09/programming/java/javaweb/distributed/分布式技术实现/" itemprop="url">分布式技术实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式技术实现"><a href="#分布式技术实现" class="headerlink" title="分布式技术实现"></a>分布式技术实现</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-分布式事务">1. 分布式事务</a></li>
<li><a href="#2-分布式锁">2. 分布式锁</a><ul>
<li><a href="#21-基于数据库实现分布式锁">2.1. 基于数据库实现分布式锁</a></li>
<li><a href="#22-基于-redis-实现分布式锁">2.2. 基于 Redis 实现分布式锁</a></li>
<li><a href="#23-基于-zookeeper-实现分布式锁">2.3. 基于 ZooKeeper 实现分布式锁</a></li>
</ul>
</li>
<li><a href="#3-分布式-session">3. 分布式 Session</a><ul>
<li><a href="#31-sticky-sessions">3.1. Sticky Sessions</a></li>
<li><a href="#32-session-replication">3.2. Session Replication</a></li>
<li><a href="#33-session-server">3.3. Session Server</a></li>
</ul>
</li>
<li><a href="#4-分布式存储">4. 分布式存储</a></li>
<li><a href="#5-分布式缓存">5. 分布式缓存</a></li>
<li><a href="#6-分布式计算">6. 分布式计算</a></li>
<li><a href="#7-负载均衡">7. 负载均衡</a><ul>
<li><a href="#71-算法">7.1. 算法</a></li>
<li><a href="#72-实现">7.2. 实现</a></li>
</ul>
</li>
<li><a href="#8-资料">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h2><blockquote>
<p>参考：<a href="分布式原理.md#4-分布式事务问题">分布式原理#4-分布式事务问题</a></p>
</blockquote>
<h2 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h2><p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<h3 id="2-1-基于数据库实现分布式锁"><a href="#2-1-基于数据库实现分布式锁" class="headerlink" title="2.1. 基于数据库实现分布式锁"></a>2.1. 基于数据库实现分布式锁</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-获取锁"><a href="#2-获取锁" class="headerlink" title="2. 获取锁"></a>2. 获取锁</h5><p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<h5 id="3-释放锁"><a href="#3-释放锁" class="headerlink" title="3. 释放锁"></a>3. 释放锁</h5><p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h3 id="2-2-基于-Redis-实现分布式锁"><a href="#2-2-基于-Redis-实现分布式锁" class="headerlink" title="2.2. 基于 Redis 实现分布式锁"></a>2.2. 基于 Redis 实现分布式锁</h3><p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h4 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h4><ul>
<li>setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li>expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li>delete - delete key：删除 key</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>单点实现步骤：</p>
<ol>
<li>获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul>
<li>单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。</li>
<li>如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>可以考虑使用 <a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">redisson 的解决方案</a>。</p>
<h3 id="2-3-基于-ZooKeeper-实现分布式锁"><a href="#2-3-基于-ZooKeeper-实现分布式锁" class="headerlink" title="2.3. 基于 ZooKeeper 实现分布式锁"></a>2.3. 基于 ZooKeeper 实现分布式锁</h3><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="3-分布式-Session"><a href="#3-分布式-Session" class="headerlink" title="3. 分布式 Session"></a>3. 分布式 Session</h2><p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于 cache DB 缓存的 session 共享</li>
</ol>
<h3 id="3-1-Sticky-Sessions"><a href="#3-1-Sticky-Sessions" class="headerlink" title="3.1. Sticky Sessions"></a>3.1. Sticky Sessions</h3><p>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-StickySessions.jpg"><br></div>

<h3 id="3-2-Session-Replication"><a href="#3-2-Session-Replication" class="headerlink" title="3.2. Session Replication"></a>3.2. Session Replication</h3><p>在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-SessionReplication.jpg"><br></div>

<h3 id="3-3-Session-Server"><a href="#3-3-Session-Server" class="headerlink" title="3.3. Session Server"></a>3.3. Session Server</h3><p>使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/MultiNode-SpringSession.jpg"><br></div>

<h2 id="4-分布式存储"><a href="#4-分布式存储" class="headerlink" title="4. 分布式存储"></a>4. 分布式存储</h2><p>通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<blockquote>
<p>参考：<a href="分布式原理.md#2-数据分布">分布式原理.md#2-数据分布</a></p>
</blockquote>
<h2 id="5-分布式缓存"><a href="#5-分布式缓存" class="headerlink" title="5. 分布式缓存"></a>5. 分布式缓存</h2><p>使用缓存的好处：</p>
<ul>
<li>提升数据读取速度</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>应用内缓存：如：EHCache</li>
<li>分布式缓存：如：Memached、Redis</li>
</ul>
<blockquote>
<p>参考：<a href="分布式原理.md#6-分布式缓存问题">分布式原理.md#6-分布式缓存问题</a></p>
</blockquote>
<h2 id="6-分布式计算"><a href="#6-分布式计算" class="headerlink" title="6. 分布式计算"></a>6. 分布式计算</h2><h2 id="7-负载均衡"><a href="#7-负载均衡" class="headerlink" title="7. 负载均衡"></a>7. 负载均衡</h2><h3 id="7-1-算法"><a href="#7-1-算法" class="headerlink" title="7.1. 算法"></a>7.1. 算法</h3><h4 id="轮询（Round-Robin）"><a href="#轮询（Round-Robin）" class="headerlink" title="轮询（Round Robin）"></a>轮询（Round Robin）</h4><p>轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之轮询-01.jpg" width="640"><br></div>

<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之轮询-02.jpg" width="640"><br></div>

<h4 id="加权轮询（Weighted-Round-Robbin）"><a href="#加权轮询（Weighted-Round-Robbin）" class="headerlink" title="加权轮询（Weighted Round Robbin）"></a>加权轮询（Weighted Round Robbin）</h4><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之加权轮询.jpg" width="640"><br></div>

<h4 id="最少连接（least-Connections）"><a href="#最少连接（least-Connections）" class="headerlink" title="最少连接（least Connections）"></a>最少连接（least Connections）</h4><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之最少连接-01.jpg" width="640"><br></div>

<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之最少连接-02.jpg" width="640"><br></div>

<h4 id="加权最少连接（Weighted-Least-Connection）"><a href="#加权最少连接（Weighted-Least-Connection）" class="headerlink" title="加权最少连接（Weighted Least Connection）"></a>加权最少连接（Weighted Least Connection）</h4><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之加权最少连接.jpg" width="640"><br></div>

<h4 id="随机算法（Random）"><a href="#随机算法（Random）" class="headerlink" title="随机算法（Random）"></a>随机算法（Random）</h4><p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之随机.jpg" width="640"><br></div>

<h4 id="源地址哈希法-IP-Hash"><a href="#源地址哈希法-IP-Hash" class="headerlink" title="源地址哈希法 (IP Hash)"></a>源地址哈希法 (IP Hash)</h4><p>源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。</p>
<ul>
<li>优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。</li>
<li>缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/负载均衡算法之IpHash.jpg" width="640"><br></div>

<h3 id="7-2-实现"><a href="#7-2-实现" class="headerlink" title="7.2. 实现"></a>7.2. 实现</h3><h4 id="HTTP-重定向"><a href="#HTTP-重定向" class="headerlink" title="HTTP 重定向"></a>HTTP 重定向</h4><p>HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/Http重定向.png" width="640"><br></div>

<h4 id="DNS-重定向"><a href="#DNS-重定向" class="headerlink" title="DNS 重定向"></a>DNS 重定向</h4><p>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>缺点：</p>
<ul>
<li>DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/Dns重定向.png" width="640"><br></div>

<h4 id="修改-MAC-地址"><a href="#修改-MAC-地址" class="headerlink" title="修改 MAC 地址"></a>修改 MAC 地址</h4><p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/修改Mac地址.png" width="640"><br></div>

<h4 id="修改-IP-地址"><a href="#修改-IP-地址" class="headerlink" title="修改 IP 地址"></a>修改 IP 地址</h4><p>在网络层修改请求的目的 IP 地址。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/修改IP地址.png" width="640"><br></div>

<h4 id="代理自动配置"><a href="#代理自动配置" class="headerlink" title="代理自动配置"></a>代理自动配置</h4><p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>PAC 服务器是用来判断一个请求是否要经过代理。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/代理自动配置.jpg" width="640"><br></div>

<h2 id="8-资料"><a href="#8-资料" class="headerlink" title="8. 资料"></a>8. 资料</h2><ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></li>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">https://juejin.im/post/5a20cd8bf265da43163cdd9a</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8</a></li>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">https://github.com/L316476844/distributed-session</a></li>
<li><a href="https://juejin.im/entry/57e39e320e3dd90058021bff" target="_blank" rel="noopener">分布式缓存架构基础</a></li>
<li><a href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&amp;utm_campaign=client_share&amp;from=singlemessage&amp;timestamp=1521281305&amp;app=news_article&amp;utm_source=weixin&amp;iid=28128279343&amp;utm_medium=toutiao_android&amp;weixin_list=1&amp;wxshare_count=2&amp;pbid=6517746516513195523" target="_blank" rel="noopener">阿里 P8 技术专家细究分布式缓存问题</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/05/programming/java/javaweb/distributed/负载均衡/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/05/programming/java/javaweb/distributed/负载均衡/" itemprop="url">负载均衡</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T00:00:00+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-负载均衡原理">1. 负载均衡原理</a></li>
<li><a href="#2-负载均衡分类">2. 负载均衡分类</a><ul>
<li><a href="#21-dns-负载均衡">2.1. DNS 负载均衡</a></li>
<li><a href="#22-ip-负载均衡">2.2. IP 负载均衡</a></li>
<li><a href="#23-链路层负载均衡">2.3. 链路层负载均衡</a></li>
<li><a href="#24-混合型负载均衡">2.4. 混合型负载均衡</a></li>
</ul>
</li>
<li><a href="#3-负载均衡算法">3. 负载均衡算法</a><ul>
<li><a href="#31-轮询">3.1. 轮询</a></li>
<li><a href="#32-随机">3.2. 随机</a></li>
<li><a href="#33-最少连接">3.3. 最少连接</a></li>
<li><a href="#34-hash源地址散列">3.4. Hash（源地址散列）</a></li>
<li><a href="#35-加权">3.5. 加权</a></li>
</ul>
</li>
<li><a href="#4-硬件负载均衡">4. 硬件负载均衡</a></li>
<li><a href="#5-ngnix-负载均衡">5. Ngnix 负载均衡</a><ul>
<li><a href="#51-ngnix-特点">5.1. Ngnix 特点</a></li>
<li><a href="#52-ngnix-功能">5.2. Ngnix 功能</a></li>
<li><a href="#53-ngnix-架构">5.3. Ngnix 架构</a></li>
<li><a href="#54-ngnix-均衡策略">5.4. Ngnix 均衡策略</a></li>
<li><a href="#55-ngnix-场景">5.5. Ngnix 场景</a></li>
</ul>
</li>
<li><a href="#6-lvs-负载均衡">6. LVS 负载均衡</a><ul>
<li><a href="#61-lvs-功能">6.1. LVS 功能</a></li>
<li><a href="#62-lvs-架构">6.2. LVS 架构</a></li>
<li><a href="#63-lvs-均衡策略">6.3. LVS 均衡策略</a></li>
<li><a href="#64-lvs-场景">6.4. LVS 场景</a></li>
</ul>
</li>
<li><a href="#7-haproxy-负载均衡">7. HaProxy 负载均衡</a><ul>
<li><a href="#71-haproxy-特点">7.1. HaProxy 特点</a></li>
<li><a href="#72-haproxy-均衡策略">7.2. HaProxy 均衡策略</a></li>
</ul>
</li>
<li><a href="#8-资料">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-负载均衡原理"><a href="#1-负载均衡原理" class="headerlink" title="1. 负载均衡原理"></a>1. 负载均衡原理</h2><p>系统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。纵向扩展，是从单机的角度通过增加硬件处理能力，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构：如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213194550278-786046258.png"></div><br></p>
<ul>
<li>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</li>
<li>负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</li>
</ul>
<p>负载均衡的作用（解决的问题）：</p>
<ol>
<li><p>解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；</p>
</li>
<li><p>提供故障转移，实现高可用；</p>
</li>
<li><p>通过添加或减少服务器数量，提供网站伸缩性（扩展性）；</p>
</li>
<li><p>安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）</p>
</li>
</ol>
<h2 id="2-负载均衡分类"><a href="#2-负载均衡分类" class="headerlink" title="2. 负载均衡分类"></a>2. 负载均衡分类</h2><p>根据实现技术不同，可分为 DNS 负载均衡，HTTP 负载均衡，IP 负载均衡，链路层负载均衡等。</p>
<h3 id="2-1-DNS-负载均衡"><a href="#2-1-DNS-负载均衡" class="headerlink" title="2.1. DNS 负载均衡"></a>2.1. DNS 负载均衡</h3><p>最早的负载均衡技术，利用域名解析实现负载均衡，在 DNS 服务器，配置多个 A 记录，这些 A 记录对应的服务器构成集群。大型网站总是部分使用 DNS 解析，作为第一级负载均衡。如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213194538622-1255166256.png"></div><br></p>
<p>优点</p>
<ol>
<li>使用简单：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li>提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能；</li>
</ol>
<p>缺点</p>
<ol>
<li>可用性差：DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li>扩展性低：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li>维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ol>
<p>实践建议</p>
<p>将 DNS 作为第一级负载均衡，A 记录对应着内部负载均衡的 IP 地址，通过内部负载均衡将请求分发到真实的 Web 服务器上。一般用于互联网公司，复杂的业务系统不合适使用。如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213194500497-164261027.png"></div><br></p>
<h3 id="2-2-IP-负载均衡"><a href="#2-2-IP-负载均衡" class="headerlink" title="2.2. IP 负载均衡"></a>2.2. IP 负载均衡</h3><p>在网络层通过修改请求目标地址进行负载均衡。</p>
<p>用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然后将请求目的地址修改为，获得的真实 ip 地址，不需要经过用户进程处理。</p>
<p>真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器，再将数据包源地址修改为自身的 ip 地址，发送给用户浏览器。如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213195925966-1272593644.png"></div><br></p>
<p>IP 负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式：</p>
<ol>
<li>负载均衡服务器在修改目的 ip 地址的同时修改源地址。将数据包源地址设为自身盘，即源地址转换（snat）。</li>
<li>将负载均衡服务器同时作为真实物理服务器集群的网关服务器。</li>
</ol>
<p>优点：在内核进程完成数据分发，比在应用层分发性能更好；</p>
<p>缺点：所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽；</p>
<h3 id="2-3-链路层负载均衡"><a href="#2-3-链路层负载均衡" class="headerlink" title="2.3. 链路层负载均衡"></a>2.3. 链路层负载均衡</h3><p>在通信协议的数据链路层修改 mac 地址，进行负载均衡。</p>
<p>数据分发时，不修改 ip 地址，指修改目标 mac 地址，配置真实物理服务器集群所有机器虚拟 ip 和负载均衡服务器 ip 地址一致，达到不修改数据包的源地址和目标地址，进行数据分发的目的。</p>
<p>实际处理服务器 ip 和数据请求目的 ip 一致，不需要经过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。也称为直接路由模式（DR 模式）。如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213195947762-1630980523.png"></div><br></p>
<p>优点：性能好；</p>
<p>缺点：配置复杂；</p>
<p>实践建议：DR 模式是目前使用最广泛的一种负载均衡方式。</p>
<h3 id="2-4-混合型负载均衡"><a href="#2-4-混合型负载均衡" class="headerlink" title="2.4. 混合型负载均衡"></a>2.4. 混合型负载均衡</h3><p>由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。</p>
<p>此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。</p>
<p>方式一，如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200106747-94797427.png"></div><br></p>
<p>以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。</p>
<p>方式二，如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200117825-1452672107.png"></div><br></p>
<p>以上模式，适合动态请求场景。</p>
<p>因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。</p>
<h2 id="3-负载均衡算法"><a href="#3-负载均衡算法" class="headerlink" title="3. 负载均衡算法"></a>3. 负载均衡算法</h2><p>常用的负载均衡算法有：轮询、随机、最少连接、源地址散列、加权等方式。</p>
<h3 id="3-1-轮询"><a href="#3-1-轮询" class="headerlink" title="3.1. 轮询"></a>3.1. 轮询</h3><p>将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。</p>
<p>优点：服务器请求数目相同；</p>
<p>缺点：服务器压力不一样，不适合服务器配置不同的情况；</p>
<h3 id="3-2-随机"><a href="#3-2-随机" class="headerlink" title="3.2. 随机"></a>3.2. 随机</h3><p>请求随机分配到各个服务器。</p>
<p>优点：使用简单；</p>
<p>缺点：不适合机器配置不同的场景；</p>
<h3 id="3-3-最少连接"><a href="#3-3-最少连接" class="headerlink" title="3.3. 最少连接"></a>3.3. 最少连接</h3><p>将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。</p>
<p>优点：根据服务器当前的请求处理情况，动态分配；</p>
<p>缺点：算法实现相对复杂，需要监控服务器请求连接数；</p>
<h3 id="3-4-Hash（源地址散列）"><a href="#3-4-Hash（源地址散列）" class="headerlink" title="3.4. Hash（源地址散列）"></a>3.4. Hash（源地址散列）</h3><p>根据 IP 地址进行 Hash 计算，得到 IP 地址。</p>
<p>优点：将来自同一 IP 地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。</p>
<p>缺点：目标服务器宕机后，会话会丢失；</p>
<h3 id="3-5-加权"><a href="#3-5-加权" class="headerlink" title="3.5. 加权"></a>3.5. 加权</h3><p>在轮询，随机，最少链接，Hash’等算法的基础上，通过加权的方式，进行负载服务器分配。</p>
<p>优点：根据权重，调节转发服务器的请求数目；</p>
<p>缺点：使用相对复杂；</p>
<h2 id="4-硬件负载均衡"><a href="#4-硬件负载均衡" class="headerlink" title="4. 硬件负载均衡"></a>4. 硬件负载均衡</h2><p>采用硬件的方式实现负载均衡，一般是单独的负载均衡服务器，价格昂贵，一般土豪级公司可以考虑，业界领先的有两款，F5 和 A10。</p>
<p>使用硬件负载均衡，主要考虑一下几个方面：</p>
<p>（1）功能考虑：功能全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡；</p>
<p>（2）性能考虑：一般软件负载均衡支持到 5 万级并发已经很困难了，硬件负载均衡可以支持</p>
<p>（3）稳定性：商用硬件负载均衡，经过了良好的严格的测试，从经过大规模使用，在稳定性方面高；</p>
<p>（4）安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙，防 DDOS 攻击等安全功能；</p>
<p>（5）维护角度：提供良好的维护管理界面，售后服务和技术支持；</p>
<p>（6）土豪公司：F5 Big Ip 价格：15w~55w 不等；A10 价格：55w-100w 不等；</p>
<p>缺点</p>
<p>（1）价格昂贵；</p>
<p>（2）扩展能力差；</p>
<p>小结</p>
<p>（1）一般硬件的负载均衡也要做双机高可用，因此成本会比较高。</p>
<p>（2）互联网公司一般使用开源软件，因此大部分应用采用软件负载均衡；部分采用硬件负载均衡。</p>
<p>比如某互联网公司，目前是使用几台 F5 做全局负载均衡，内部使用 Nginx 等软件负载均衡。</p>
<h2 id="5-Ngnix-负载均衡"><a href="#5-Ngnix-负载均衡" class="headerlink" title="5. Ngnix 负载均衡"></a>5. Ngnix 负载均衡</h2><p>Ngnix 是一款轻量级的 Web 服务器/反向代理服务器，工作在七层 Http 协议的负载均衡系统。具有高性能、高并发、低内存使用等特点。是一个轻量级的 Http 和反向代理服务器。Nginx 使用 epoll and kqueue 作为开发模型。能够支持高达 50,000 个并发连接数的响应。</p>
<p>操作系统：Liunx，Windows（Linux、FreeBSD、Solaris、Mac OS X、AIX 以及 Microsoft Windows）</p>
<p>开发语言：C</p>
<p>并发性能：官方支持每秒 5 万并发，实际国内一般到每秒 2 万并发，有优化到每秒 10 万并发的。具体性能看应用场景。</p>
<h3 id="5-1-Ngnix-特点"><a href="#5-1-Ngnix-特点" class="headerlink" title="5.1. Ngnix 特点"></a>5.1. Ngnix 特点</h3><p>1.模块化设计：良好的扩展性，可以通过模块方式进行功能扩展。</p>
<p>2.高可靠性：主控进程和 worker 是同步实现的，一个 worker 出现问题，会立刻启动另一个 worker。</p>
<p>3.内存消耗低：一万个长连接（keep-alive）,仅消耗 2.5MB 内存。</p>
<p>4.支持热部署：不用停止服务器，实现更新配置文件，更换日志文件、更新服务器程序版本。</p>
<p>5.并发能力强：官方数据每秒支持 5 万并发；</p>
<p>6.功能丰富：优秀的反向代理功能和灵活的负载均衡策略</p>
<h3 id="5-2-Ngnix-功能"><a href="#5-2-Ngnix-功能" class="headerlink" title="5.2. Ngnix 功能"></a>5.2. Ngnix 功能</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ul>
<li>支持静态资源的 web 服务器。</li>
<li>http,smtp,pop3 协议的反向代理服务器、缓存、负载均衡；</li>
<li>支持 FASTCGI（fpm）</li>
<li>支持模块化，过滤器（让文本可以实现压缩，节约带宽）,ssl 及图像大小调整。</li>
<li>内置的健康检查功能</li>
<li>基于名称和 ip 的虚拟主机</li>
<li>定制访问日志</li>
<li>支持平滑升级</li>
<li>支持 KEEPALIVE</li>
<li>支持 url rewrite</li>
<li>支持路径别名</li>
<li>支持基于 IP 和用户名的访问控制。</li>
<li>支持传输速率限制，支持并发数限制。</li>
</ul>
<h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>Nginx 的高并发，官方测试支持 5 万并发连接。实际生产环境能到 2-3 万并发连接数。10000 个非活跃的 HTTP keep-alive 连接仅占用约 2.5MB 内存。三万并发连接下，10 个 Nginx 进程，消耗内存 150M。淘宝 tengine 团队测试结果是“24G 内存机器上，处理并发请求可达 200 万”。</p>
<h3 id="5-3-Ngnix-架构"><a href="#5-3-Ngnix-架构" class="headerlink" title="5.3. Ngnix 架构"></a>5.3. Ngnix 架构</h3><h4 id="Nginx-的基本工作模式"><a href="#Nginx-的基本工作模式" class="headerlink" title="Nginx 的基本工作模式"></a>Nginx 的基本工作模式</h4><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227195943640-864372763.jpg"></div><br></p>
<p>一个 master 进程，生成一个或者多个 worker 进程。但是这里 master 是使用 root 身份启动的，因为 nginx 要工作在 80 端口。而只有管理员才有权限启动小于低于 1023 的端口。master 主要是负责的作用只是启动 worker，加载配置文件，负责系统的平滑升级。其它的工作是交给 worker。那么当 worker 被启动之后，也只是负责一些 web 最简单的工作，而其他的工作都是有 worker 中调用的模块来实现的。</p>
<p>模块之间是以流水线的方式实现功能的。流水线，指的是一个用户请求，由多个模块组合各自的功能依次实现完成的。比如：第一个模块只负责分析请求首部，第二个模块只负责查找数据，第三个模块只负责压缩数据，依次完成各自工作。来实现整个工作的完成。</p>
<p>他们是如何实现热部署的呢？其实是这样的，我们前面说 master 不负责具体的工作，而是调用 worker 工作，他只是负责读取配置文件，因此当一个模块修改或者配置文件发生变化，是由 master 进行读取，因此此时不会影响到 worker 工作。在 master 进行读取配置文件之后，不会立即的把修改的配置文件告知 worker。而是让被修改的 worker 继续使用老的配置文件工作，当 worker 工作完毕之后，直接当掉这个子进程，更换新的子进程，使用新的规则。</p>
<h4 id="Nginx-支持的-sendfile-机制"><a href="#Nginx-支持的-sendfile-机制" class="headerlink" title="Nginx 支持的 sendfile 机制"></a>Nginx 支持的 sendfile 机制</h4><p>Sendfile 机制，用户将请求发给内核，内核根据用户的请求调用相应用户进程，进程在处理时需要资源。此时再把请求发给内核（进程没有直接 IO 的能力），由内核加载数据。内核查找到数据之后，会把数据复制给用户进程，由用户进程对数据进行封装，之后交给内核，内核在进行 tcp/ip 首部的封装，最后再发给客户端。这个功能用户进程只是发生了一个封装报文的过程，却要绕一大圈。因此 nginx 引入了 sendfile 机制，使得内核在接受到数据之后，不再依靠用户进程给予封装，而是自己查找自己封装，减少了一个很长一段时间的浪费，这是一个提升性能的核心点。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227195957171-1801771404.jpg"></div><br></p>
<p>以上内容摘自网友发布的文章，简单一句话是资源的处理，直接通过内核层进行数据传递，避免了数据传递到应用层，应用层再传递到内核层的开销。</p>
<p>目前高并发的处理，一般都采用 sendfile 模式。通过直接操作内核层数据，减少应用与内核层数据传递。</p>
<h4 id="Nginx-通信模型（I-O-复用机制）"><a href="#Nginx-通信模型（I-O-复用机制）" class="headerlink" title="Nginx 通信模型（I/O 复用机制）"></a>Nginx 通信模型（I/O 复用机制）</h4><p>开发模型：epoll 和 kqueue。</p>
<p>支持的事件机制：kqueue、epoll、rt signals、/dev/poll 、event ports、select 以及 poll。</p>
<p>支持的 kqueue 特性包括 EV_CLEAR、EV_DISABLE、NOTE_LOWAT、EV_EOF，可用数据的数量，错误代码.</p>
<p>支持 sendfile、sendfile64 和 sendfilev;文件 AIO；DIRECTIO;支持 Accept-filters 和 TCP_DEFER_ACCEP.</p>
<p>以上概念较多，大家自行百度或谷歌，知识领域是网络通信（BIO,NIO,AIO）和多线程方面的知识。</p>
<h3 id="5-4-Ngnix-均衡策略"><a href="#5-4-Ngnix-均衡策略" class="headerlink" title="5.4. Ngnix 均衡策略"></a>5.4. Ngnix 均衡策略</h3><p>nginx 的负载均衡策略可以划分为两大类：内置策略和扩展策略。内置策略包含加权轮询和 ip hash，在默认情况下这两种策略会编译进 nginx 内核，只需在 nginx 配置中指明参数即可。扩展策略有很多，如 fair、通用 hash、consistent hash 等，默认不编译进 nginx 内核。由于在 nginx 版本升级中负载均衡的代码没有本质性的变化，因此下面将以 nginx1.0.15 稳定版为例，从源码角度分析各个策略。</p>
<h4 id="加权轮询（weighted-round-robin）"><a href="#加权轮询（weighted-round-robin）" class="headerlink" title="加权轮询（weighted round robin）"></a>加权轮询（weighted round robin）</h4><p>轮询的原理很简单，首先我们介绍一下轮询的基本流程。如下是处理一次请求的流程图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227201913984-412518987.jpg"></div><br></p>
<p>图中有两点需要注意，第一，如果可以把加权轮询算法分为先深搜索和先广搜索，那么 nginx 采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；第二，当所有后端机器都 down 掉时，nginx 会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在 timeout 的状态，从而导致整个前端被夯住。</p>
<h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip hash"></a>ip hash</h4><p>ip hash 是 nginx 内置的另一个负载均衡的策略，流程和轮询很类似，只是其中的算法和具体的策略有些变化，如下图所示：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227201851812-352858632.jpg"></div><br></p>
<h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>fair 策略是扩展策略，默认不被编译进 nginx 内核。其原理是根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流。这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此要慎用。</p>
<h4 id="通用-hash、一致性-hash"><a href="#通用-hash、一致性-hash" class="headerlink" title="通用 hash、一致性 hash"></a>通用 hash、一致性 hash</h4><p>这两种也是扩展策略，在具体的实现上有些差别，通用 hash 比较简单，可以以 nginx 内置的变量为 key 进行 hash，一致性 hash 采用了 nginx 内置的一致性 hash 环，可以支持 memcache。</p>
<h3 id="5-5-Ngnix-场景"><a href="#5-5-Ngnix-场景" class="headerlink" title="5.5. Ngnix 场景"></a>5.5. Ngnix 场景</h3><p>Ngnix 一般作为入口负载均衡或内部负载均衡，结合反向代理服务器使用。以下架构示例，仅供参考，具体使用根据场景而定。</p>
<h4 id="入口负载均衡架构"><a href="#入口负载均衡架构" class="headerlink" title="入口负载均衡架构"></a>入口负载均衡架构</h4><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202044781-2116477406.png"></div><br></p>
<p>Ngnix 服务器在用户访问的最前端。根据用户请求再转发到具体的应用服务器或二级负载均衡服务器（LVS）</p>
<h4 id="内部负载均衡架构"><a href="#内部负载均衡架构" class="headerlink" title="内部负载均衡架构"></a>内部负载均衡架构</h4><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202054421-2015542569.png"></div><br></p>
<p>LVS 作为入口负载均衡，将请求转发到二级 Ngnix 服务器，Ngnix 再根据请求转发到具体的应用服务器。</p>
<h4 id="Ngnix-高可用"><a href="#Ngnix-高可用" class="headerlink" title="Ngnix 高可用"></a>Ngnix 高可用</h4><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202100921-915093452.png"></div><br></p>
<p>分布式系统中，应用只部署一台服务器会存在单点故障，负载均衡同样有类似的问题。一般可采用主备或负载均衡设备集群的方式节约单点故障或高并发请求分流。</p>
<p>Ngnix 高可用，至少包含两个 Ngnix 服务器，一台主服务器，一台备服务器，之间使用 Keepalived 做健康监控和故障检测。开放 VIP 端口，通过防火墙进行外部映射。</p>
<p>DNS 解析公网的 IP 实际为 VIP。</p>
<h2 id="6-LVS-负载均衡"><a href="#6-LVS-负载均衡" class="headerlink" title="6. LVS 负载均衡"></a>6. LVS 负载均衡</h2><p>LVS 是一个开源的软件，由毕业于国防科技大学的章文嵩博士于 1998 年 5 月创立，用来实现 Linux 平台下的简单负载均衡。LVS 是 Linux Virtual Server 的缩写，意思是 Linux 虚拟服务器。</p>
<p>基于 IP 层的负载均衡调度技术，它在操作系统核心层上，将来自 IP 层的 TCP/UDP 请求均衡地转移到不同的 服务器，从而将一组服务器构成一个高性能、高可用的虚拟服务器。</p>
<p>操作系统：Liunx</p>
<p>开发语言：C</p>
<p>并发性能：默认 4096，可以修改但需要重新编译。</p>
<h3 id="6-1-LVS-功能"><a href="#6-1-LVS-功能" class="headerlink" title="6.1. LVS 功能"></a>6.1. LVS 功能</h3><p>LVS 的主要功能是实现 IP 层（网络层）负载均衡，有 NAT,TUN,DR 三种请求转发模式。</p>
<h4 id="LVS-NAT-方式的负载均衡集群"><a href="#LVS-NAT-方式的负载均衡集群" class="headerlink" title="LVS/NAT 方式的负载均衡集群"></a>LVS/NAT 方式的负载均衡集群</h4><p>NAT 是指 Network Address Translation，它的转发流程是：Director 机器收到外界请求，改写数据包的目标地址，按相应的调度算法将其发送到相应 Real Server 上，Real Server 处理完该请求后，将结果数据包返回到其默认网关，即 Director 机器上，Director 机器再改写数据包的源地址，最后将其返回给外界。这样就完成一次负载调度。</p>
<p>构架一个最简单的 LVS/NAT 方式的负载均衡集群 Real Server 可以是任何的操作系统，而且无需做任何特殊的设定，惟一要做的就是将其默认网关指向 Director 机器。Real Server 可以使用局域网的内部 IP(192.168.0.0/24)。Director 要有两块网卡，一块网卡绑定一个外部 IP 地址 (10.0.0.1)，另一块网卡绑定局域网的内部 IP(192.168.0.254)，作为 Real Server 的默认网关。</p>
<p>LVS/NAT 方式实现起来最为简单，而且 Real Server 使用的是内部 IP，可以节省 Real IP 的开销。但因为执行 NAT 需要重写流经 Director 的数据包，在速度上有一定延迟；</p>
<p>当用户的请求非常短，而服务器的回应非常大的情况下，会对 Director 形成很大压力，成为新的瓶颈，从而使整个系统的性能受到限制。</p>
<h4 id="LVS-TUN-方式的负载均衡集群"><a href="#LVS-TUN-方式的负载均衡集群" class="headerlink" title="LVS/TUN 方式的负载均衡集群"></a>LVS/TUN 方式的负载均衡集群</h4><p>TUN 是指 IP Tunneling，它的转发流程是：Director 机器收到外界请求，按相应的调度算法,通过 IP 隧道发送到相应 Real Server，Real Server 处理完该请求后，将结果数据包直接返回给客户。至此完成一次负载调度。</p>
<p>最简单的 LVS/TUN 方式的负载均衡集群架构使用 IP Tunneling 技术，在 Director 机器和 Real Server 机器之间架设一个 IP Tunnel，通过 IP Tunnel 将负载分配到 Real Server 机器上。Director 和 Real Server 之间的关系比较松散，可以是在同一个网络中，也可以是在不同的网络中，只要两者能够通过 IP Tunnel 相连就行。收到负载分配的 Real Server 机器处理完后会直接将反馈数据送回给客户，而不必通过 Director 机器。实际应用中，服务器必须拥有正式的 IP 地址用于与客户机直接通信，并且所有服务器必须支持 IP 隧道协议。</p>
<p>该方式中 Director 将客户请求分配到不同的 Real Server，Real Server 处理请求后直接回应给用户，这样 Director 就只处理客户机与服务器的一半连接，极大地提高了 Director 的调度处理能力，使集群系统能容纳更多的节点数。另外 TUN 方式中的 Real Server 可以在任何 LAN 或 WAN 上运行，这样可以构筑跨地域的集群，其应对灾难的能力也更强，但是服务器需要为 IP 封装付出一定的资源开销，而且后端的 Real Server 必须是支持 IP Tunneling 的操作系统。</p>
<h4 id="LVS-TUN-方式的负载均衡集群-1"><a href="#LVS-TUN-方式的负载均衡集群-1" class="headerlink" title="LVS/TUN 方式的负载均衡集群"></a>LVS/TUN 方式的负载均衡集群</h4><p>DR 是指 Direct Routing，它的转发流程是：Director 机器收到外界请求，按相应的调度算法将其直接发送到相应 Real Server，Real Server 处理完该请求后，将结果数据包直接返回给客户，完成一次负载调度。</p>
<p>构架一个最简单的 LVS/DR 方式的负载均衡集群 Real Server 和 Director 都在同一个物理网段中，Director 的网卡 IP 是 192.168.0.253，再绑定另一个 IP： 192.168.0.254 作为对外界的 virtual IP，外界客户通过该 IP 来访问整个集群系统。Real Server 在 lo 上绑定 IP：192.168.0.254，同时加入相应的路由。</p>
<p>LVS/DR 方式与前面的 LVS/TUN 方式有些类似，前台的 Director 机器也是只需要接收和调度外界的请求，而不需要负责返回这些请求的反馈结果，所以能够负载更多的 Real Server，提高 Director 的调度处理能力，使集群系统容纳更多的 Real Server。但 LVS/DR 需要改写请求报文的 MAC 地址，所以所有服务器必须在同一物理网段内。</p>
<h3 id="6-2-LVS-架构"><a href="#6-2-LVS-架构" class="headerlink" title="6.2. LVS 架构"></a>6.2. LVS 架构</h3><p>LVS 架设的服务器集群系统有三个部分组成：最前端的负载均衡层（Loader Balancer），中间的服务器群组层，用 Server Array 表示，最底层的数据共享存储层，用 Shared Storage 表示。在用户看来所有的应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。</p>
<p>LVS 的体系架构如图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227220009109-1768809526.png"></div><br></p>
<p>LVS 的各个层次的详细介绍：</p>
<p>Load Balancer 层：位于整个集群系统的最前端，有一台或者多台负载调度器（Director Server）组成，LVS 模块就安装在 Director Server 上，而 Director 的主要作用类似于一个路由器，它含有完成 LVS 功能所设定的路由表，通过这些路由表把用户的请求分发给 Server Array 层的应用服务器（Real Server）上。同时，在 Director Server 上还要安装对 Real Server 服务的监控模块 Ldirectord，此模块用于监测各个 Real Server 服务的健康状况。在 Real Server 不可用时把它从 LVS 路由表中剔除，恢复时重新加入。</p>
<p>Server Array 层：由一组实际运行应用服务的机器组成，Real Server 可以是 WEB 服务器、MAIL 服务器、FTP 服务器、DNS 服务器、视频服务器中的一个或者多个，每个 Real Server 之间通过高速的 LAN 或分布在各地的 WAN 相连接。在实际的应用中，Director Server 也可以同时兼任 Real Server 的角色。</p>
<p>Shared Storage 层：是为所有 Real Server 提供共享存储空间和内容一致性的存储区域，在物理上，一般有磁盘阵列设备组成，为了提供内容的一致性，一般可以通过 NFS 网络文件系统共享数 据，但是 NFS 在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如 Red hat 的 GFS 文件系统，oracle 提供的 OCFS2 文件系统等。</p>
<p>从整个 LVS 结构可以看出，Director Server 是整个 LVS 的核心，目前，用于 Director Server 的操作系统只能是 Linux 和 FreeBSD，linux2.6 内核不用任何设置就可以支持 LVS 功能，而 FreeBSD 作为 Director Server 的应用还不是很多，性能也不是很好。对于 Real Server，几乎可以是所有的系统平台，Linux、windows、Solaris、AIX、BSD 系列都能很好的支持。</p>
<h3 id="6-3-LVS-均衡策略"><a href="#6-3-LVS-均衡策略" class="headerlink" title="6.3. LVS 均衡策略"></a>6.3. LVS 均衡策略</h3><p>LVS 默认支持八种负载均衡策略，简述如下：</p>
<h4 id="轮询调度（Round-Robin）"><a href="#轮询调度（Round-Robin）" class="headerlink" title="轮询调度（Round Robin）"></a>轮询调度（Round Robin）</h4><p>调度器通过“轮询”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。</p>
<h4 id="加权轮询（Weighted-Round-Robin）"><a href="#加权轮询（Weighted-Round-Robin）" class="headerlink" title="加权轮询（Weighted Round Robin）"></a>加权轮询（Weighted Round Robin）</h4><p>调度器通过“加权轮询”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器能处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p>
<h4 id="最少链接（Least-Connections）"><a href="#最少链接（Least-Connections）" class="headerlink" title="最少链接（Least Connections）"></a>最少链接（Least Connections）</h4><p>调度器通过“最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用“最小连接”调度算法可以较好地均衡负载。</p>
<h4 id="加权最少链接（Weighted-Least-Connections）"><a href="#加权最少链接（Weighted-Least-Connections）" class="headerlink" title="加权最少链接（Weighted Least Connections）"></a>加权最少链接（Weighted Least Connections）</h4><p>在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p>
<h4 id="基于局部性的最少链接（Locality-Based-Least-Connections）"><a href="#基于局部性的最少链接（Locality-Based-Least-Connections）" class="headerlink" title="基于局部性的最少链接（Locality-Based Least Connections）"></a>基于局部性的最少链接（Locality-Based Least Connections）</h4><p>“基于局部性的最少链接”调度算法是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。该算法根据请求的目标 IP 地址找出该目标 IP 地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接” 的原则选出一个可用的服务器，将请求发送到该服务器。</p>
<h4 id="带复制的基于局部性最少链接（Locality-Based-Least-Connections-with-Replication）"><a href="#带复制的基于局部性最少链接（Locality-Based-Least-Connections-with-Replication）" class="headerlink" title="带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）"></a>带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）</h4><p>“带复制的基于局部性最少链接”调度算法也是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。它与 LBLC 算法的不同之处是它要维护从一个目标 IP 地址到一组服务器的映射，而 LBLC 算法维护从一个目标 IP 地址到一台服务器的映射。该算法根据请求的目标 IP 地址找出该目标 IP 地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p>
<h4 id="目标地址散列（Destination-Hashing）"><a href="#目标地址散列（Destination-Hashing）" class="headerlink" title="目标地址散列（Destination Hashing）"></a>目标地址散列（Destination Hashing）</h4><p>“目标地址散列”调度算法根据请求的目标 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>
<h4 id="源地址散列（Source-Hashing）"><a href="#源地址散列（Source-Hashing）" class="headerlink" title="源地址散列（Source Hashing）"></a>源地址散列（Source Hashing）</h4><p>“源地址散列”调度算法根据请求的源 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>
<p>除具备以上负载均衡算法外，还可以自定义均衡策略。</p>
<h3 id="6-4-LVS-场景"><a href="#6-4-LVS-场景" class="headerlink" title="6.4. LVS 场景"></a>6.4. LVS 场景</h3><p>一般作为入口负载均衡或内部负载均衡，结合反向代理服务器使用。相关架构可参考 Ngnix 场景架构。</p>
<h2 id="7-HaProxy-负载均衡"><a href="#7-HaProxy-负载均衡" class="headerlink" title="7. HaProxy 负载均衡"></a>7. HaProxy 负载均衡</h2><p>HAProxy 也是使用较多的一款负载均衡软件。HAProxy 提供高可用性、负载均衡以及基于 TCP 和 HTTP 应用的代理，支持虚拟主机，是免费、快速并且可靠的一种解决方案。特别适用于那些负载特大的 web 站点。运行模式使得它可以很简单安全的整合到当前的架构中，同时可以保护你的 web 服务器不被暴露到网络上。</p>
<h3 id="7-1-HaProxy-特点"><a href="#7-1-HaProxy-特点" class="headerlink" title="7.1. HaProxy 特点"></a>7.1. HaProxy 特点</h3><ul>
<li>支持两种代理模式：TCP（四层）和 HTTP（七层），支持虚拟主机；</li>
<li>配置简单，支持 url 检测后端服务器状态；</li>
<li>做负载均衡软件使用，在高并发情况下，处理速度高于 nginx；</li>
<li>TCP 层多用于 Mysql 从（读）服务器负载均衡。 （对 Mysql 进行负载均衡，对后端的 DB 节点进行检测和负载均衡）</li>
<li>能够补充 Nginx 的一些缺点比如 Session 的保持，Cookie 引导等工作</li>
</ul>
<h3 id="7-2-HaProxy-均衡策略"><a href="#7-2-HaProxy-均衡策略" class="headerlink" title="7.2. HaProxy 均衡策略"></a>7.2. HaProxy 均衡策略</h3><p>支持四种常用算法：</p>
<p>1.roundrobin：轮询，轮流分配到后端服务器；</p>
<p>2.static-rr：根据后端服务器性能分配；</p>
<p>3.leastconn：最小连接者优先处理；</p>
<p>4.source：根据请求源 IP，与 Nginx 的 IP_Hash 类似。</p>
<h2 id="8-资料"><a href="#8-资料" class="headerlink" title="8. 资料"></a>8. 资料</h2><ul>
<li><a href="https://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（1）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5043452.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（2）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5080743.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（3）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5080988.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（4）</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/05/programming/java/javaweb/distributed/mq/分布式消息队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/05/programming/java/javaweb/distributed/mq/分布式消息队列/" itemprop="url">分布式消息队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T00:00:00+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h1><blockquote>
<p>消息队列是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:4 -->
<ul>
<li><a href="#1-消息队列应用场景">1. 消息队列应用场景</a><ul>
<li><a href="#11-异步处理">1.1. 异步处理</a></li>
<li><a href="#12-应用解耦">1.2. 应用解耦</a></li>
<li><a href="#13-流量削锋">1.3. 流量削锋</a></li>
<li><a href="#14-日志处理">1.4. 日志处理</a></li>
<li><a href="#15-消息通讯">1.5. 消息通讯</a></li>
</ul>
</li>
<li><a href="#2-jms-消息服务">2. JMS 消息服务</a><ul>
<li><a href="#21-消息模型">2.1. 消息模型</a><ul>
<li><a href="#211-p2p-模式">2.1.1. P2P 模式</a></li>
<li><a href="#212-pubsub-模式">2.1.2. Pub/sub 模式</a></li>
</ul>
</li>
<li><a href="#22-消息消费">2.2. 消息消费</a></li>
<li><a href="#23-jms-编程模型">2.3. JMS 编程模型</a></li>
</ul>
</li>
<li><a href="#3-常用-mq-中间件">3. 常用 MQ 中间件</a><ul>
<li><a href="#31-activemq">3.1. ActiveMQ</a></li>
<li><a href="#32-rabbitmq">3.2. RabbitMQ</a></li>
<li><a href="#33-zeromq">3.3. ZeroMQ</a></li>
<li><a href="#34-kafka">3.4. Kafka</a></li>
</ul>
</li>
<li><a href="#4-mq-示例">4. MQ 示例</a><ul>
<li><a href="#41-电商系统">4.1. 电商系统</a></li>
<li><a href="#42-日志收集系统">4.2. 日志收集系统</a></li>
</ul>
</li>
<li><a href="#5-资料">5. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-消息队列应用场景"><a href="#1-消息队列应用场景" class="headerlink" title="1. 消息队列应用场景"></a>1. 消息队列应用场景</h2><h3 id="1-1-异步处理"><a href="#1-1-异步处理" class="headerlink" title="1.1. 异步处理"></a>1.1. 异步处理</h3><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式。</p>
<p>（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c60d8f5be3a7a3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-1a78d88cfbfebcd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>假设三个业务节点每个使用 50 毫秒钟，不考虑网络等其他开销，则串行方式的时间是 150 毫秒，并行的时间可能是 100 毫秒。</p>
<p>因为 CPU 在单位时间内处理的请求数是一定的，假设 CPU1 秒内吞吐量是 100 次。则串行方式 1 秒内 CPU 可处理的请求量是 7 次（1000/150）。并行方式处理的请求量是 10 次（1000/100）。</p>
<p>小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p>
<p>引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-105299d1fd6f3093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是 50 毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是 50 毫秒。因此架构改变后，系统的吞吐量提高到每秒 20 QPS。比串行提高了 3 倍，比并行提高了两倍。</p>
<h3 id="1-2-应用解耦"><a href="#1-2-应用解耦" class="headerlink" title="1.2. 应用解耦"></a>1.2. 应用解耦</h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-872f21e480fa4026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>传统模式的缺点：</p>
<p>1）  假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；</p>
<p>2）  订单系统与库存系统耦合；</p>
<p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-81e965d35df99238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<ul>
<li>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。</li>
<li>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。</li>
<li>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。</li>
</ul>
<h3 id="1-3-流量削锋"><a href="#1-3-流量削锋" class="headerlink" title="1.3. 流量削锋"></a>1.3. 流量削锋</h3><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p>
<p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</p>
<ol>
<li>可以控制活动的人数；</li>
<li>可以缓解短时间内高流量压垮应用；</li>
</ol>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-26394776da461cbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<ol>
<li>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面；</li>
<li>秒杀业务根据消息队列中的请求信息，再做后续处理。</li>
</ol>
<h3 id="1-4-日志处理"><a href="#1-4-日志处理" class="headerlink" title="1.4. 日志处理"></a>1.4. 日志处理</h3><p>日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。架构简化如下：</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-54d35d48b2fb643b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<ul>
<li>日志采集客户端，负责日志数据采集，定时写入 Kafka 队列；</li>
<li>Kafka 消息队列，负责日志数据的接收，存储和转发；</li>
<li>日志处理应用：订阅并消费 kafka 队列中的日志数据；</li>
</ul>
<p>以下是新浪 kafka 日志处理应用案例：</p>
<p>转自（<a href="http://cloud.51cto.com/art/201507/484338.htm）" target="_blank" rel="noopener">http://cloud.51cto.com/art/201507/484338.htm）</a></p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-46e0f421a0670f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<ul>
<li>Kafka - 接收用户日志的消息队列。</li>
<li>Logstash - 负责日志传输和解析，统一成 JSON 输出给 Elasticsearch。</li>
<li>Elasticsearch - 实时日志分析服务的核心技术，一个 schemaless，实时的数据存储服务，通过 index 组织数据，兼具强大的搜索和统计功能。</li>
<li>Kibana - 基于 Elasticsearch 的数据可视化组件，超强的数据可视化能力是众多公司选择 ELK stack 的重要原因。</li>
</ul>
<h3 id="1-5-消息通讯"><a href="#1-5-消息通讯" class="headerlink" title="1.5. 消息通讯"></a>1.5. 消息通讯</h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p>
<p>点对点通讯：</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-ba662aaae7331dee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>客户端 A 和客户端 B 使用同一队列，进行消息通讯。</p>
<p>聊天室通讯：</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-07ef81ffec631fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>客户端 A，客户端 B，客户端 N 订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p>
<p>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。</p>
<h2 id="2-JMS-消息服务"><a href="#2-JMS-消息服务" class="headerlink" title="2. JMS 消息服务"></a>2. JMS 消息服务</h2><p>讲消息队列就不得不提 JMS 。JMS（JAVA Message Service，java 消息服务）API 是一个消息服务的标准/规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p>在 EJB 架构中，有消息 bean 可以无缝的与 JM 消息服务集成。在 J2EE 架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p>
<h3 id="2-1-消息模型"><a href="#2-1-消息模型" class="headerlink" title="2.1. 消息模型"></a>2.1. 消息模型</h3><p>在 JMS 标准中，有两种消息模型：</p>
<ul>
<li>P2P(Point to Point)</li>
<li>Pub/Sub(Publish/Subscribe)</li>
</ul>
<h4 id="2-1-1-P2P-模式"><a href="#2-1-1-P2P-模式" class="headerlink" title="2.1.1. P2P 模式"></a>2.1.1. P2P 模式</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-2adc66e2367cd2c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>P2P 模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>
<p>P2P 的特点</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li>
<li>接收者在成功接收消息之后需向队列应答成功</li>
</ul>
<p>如果希望发送的每个消息都会被成功处理的话，那么需要 P2P 模式。</p>
<h4 id="2-1-2-Pub-sub-模式"><a href="#2-1-2-Pub-sub-模式" class="headerlink" title="2.1.2. Pub/sub 模式"></a>2.1.2. Pub/sub 模式</h4><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-12afe9581da889ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到 Topic,系统将这些消息传递给多个订阅者。</p>
<p>Pub/Sub 的特点</p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>
<li>为了消费消息，订阅者必须保持运行的状态。</li>
</ul>
<p>为了缓和这样严格的时间相关性，JMS 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p>
<p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 Pub/Sub 模型。</p>
<h3 id="2-2-消息消费"><a href="#2-2-消息消费" class="headerlink" title="2.2. 消息消费"></a>2.2. 消息消费</h3><p>在 JMS 中，消息的产生和消费都是异步的。对于消费来说，JMS 的消息者可以通过两种方式来消费消息。</p>
<p>（1）同步</p>
<p>订阅者或接收者通过 receive 方法来接收消息，receive 方法在接收到消息之前（或超时之前）将一直阻塞；</p>
<p>（2）异步</p>
<p>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的 onMessage 方法。</p>
<p>JNDI：Java 命名和目录接口,是一种标准的 Java 命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p>
<p>JNDI 在 JMS 中起到查找和访问发送目标或消息来源的作用。</p>
<h3 id="2-3-JMS-编程模型"><a href="#2-3-JMS-编程模型" class="headerlink" title="2.3. JMS 编程模型"></a>2.3. JMS 编程模型</h3><p>(1) ConnectionFactory</p>
<p>创建 Connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 QueueConnectionFactory 和 TopicConnectionFactory 两种。可以通过 JNDI 来查找 ConnectionFactory 对象。</p>
<p>(2) Destination</p>
<p>Destination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 Destination 是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的 Destination 也是某个队列或主题（即消息来源）。</p>
<p>所以，Destination 实际上就是两种类型的对象：Queue、Topic。可以通过 JNDI 来查找 Destination。</p>
<p>(3) Connection</p>
<p>Connection 表示在客户端和 JMS 系统之间建立的链接（对 TCP/IP socket 的包装）。Connection 可以产生一个或多个 Session。跟 ConnectionFactory 一样，Connection 也有两种类型：QueueConnection 和 TopicConnection。</p>
<p>(4) Session</p>
<p>Session 是操作消息的接口。可以通过 session 创建生产者、消费者、消息等。Session 提供了事务的功能。当需要使用 session 发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分 QueueSession 和 TopicSession。</p>
<p>(5) 消息的生产者</p>
<p>消息生产者由 Session 创建，并用于将消息发送到 Destination。同样，消息生产者分两种类型：QueueSender 和 TopicPublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。</p>
<p>(6) 消息消费者</p>
<p>消息消费者由 Session 创建，用于接收被发送到 Destination 的消息。两种类型：QueueReceiver 和 TopicSubscriber。可分别通过 session 的 createReceiver(Queue)或 createSubscriber(Topic)来创建。当然，也可以 session 的 creatDurableSubscriber 方法来创建持久化的订阅者。</p>
<p>(7) MessageListener</p>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onMessage 方法。EJB 中的 MDB（Message-Driven Bean）就是一种 MessageListener。</p>
<p>深入学习 JMS 对掌握 JAVA 架构，EJB 架构有很好的帮助，消息中间件也是大型分布式系统必须的组件。本次分享主要做全局性介绍，具体的深入需要大家学习，实践，总结，领会。</p>
<h2 id="3-常用-MQ-中间件"><a href="#3-常用-MQ-中间件" class="headerlink" title="3. 常用 MQ 中间件"></a>3. 常用 MQ 中间件</h2><p>一般商用的容器，比如 WebLogic，JBoss，都支持 JMS 标准，开发上很方便。但免费的比如 Tomcat，Jetty 等则需要使用第三方的消息中间件。本部分内容介绍常用的消息中间件（ActiveMQ、RabbitMQ、RocketMQ、Kafka）以及他们的特点。</p>
<h3 id="3-1-ActiveMQ"><a href="#3-1-ActiveMQ" class="headerlink" title="3.1. ActiveMQ"></a>3.1. ActiveMQ</h3><p>ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位。</p>
<p>ActiveMQ 特性如下：</p>
<p>⒈ 多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</p>
<p>⒉ 完全支持 JMS1.1 和 J2EE 1.4 规范 （持久化，XA 消息，事务)</p>
<p>⒊ 对 Spring 的支持，ActiveMQ 可以很容易内嵌到使用 Spring 的系统里面去，而且也支持 Spring2.0 的特性</p>
<p>⒋ 通过了常见 J2EE 服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过 JCA 1.5 resource adaptors 的配置，可以让 ActiveMQ 可以自动的部署到任何兼容 J2EE 1.4 商业服务器上</p>
<p>⒌ 支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</p>
<p>⒍ 支持通过 JDBC 和 journal 提供高速的消息持久化</p>
<p>⒎ 从设计上保证了高性能的集群，客户端-服务器，点对点</p>
<p>⒏ 支持 Ajax</p>
<p>⒐ 支持与 Axis 的整合</p>
<p>⒑ 可以很容易得调用内嵌 JMS provider，进行测试</p>
<h3 id="3-2-RabbitMQ"><a href="#3-2-RabbitMQ" class="headerlink" title="3.2. RabbitMQ"></a>3.2. RabbitMQ</h3><p>RabbitMQ 是流行的开源消息队列系统，用 erlang 语言开发。RabbitMQ 是 AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<p>结构图如下：</p>
<p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-1109f074e8445c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>几个重要概念：</p>
<p>Broker：简单来说就是消息队列服务器实体。</p>
<p>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</p>
<p>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</p>
<p>Binding：绑定，它的作用就是把 exchange 和 queue 按照路由规则绑定起来。</p>
<p>Routing Key：路由关键字，exchange 根据这个关键字进行消息投递。</p>
<p>vhost：虚拟主机，一个 broker 里可以开设多个 vhost，用作不同用户的权限分离。</p>
<p>producer：消息生产者，就是投递消息的程序。</p>
<p>consumer：消息消费者，就是接受消息的程序。</p>
<p>channel：消息通道，在客户端的每个连接里，可建立多个 channel，每个 channel 代表一个会话任务。</p>
<p>消息队列的使用过程，如下：</p>
<p>（1）客户端连接到消息队列服务器，打开一个 channel。</p>
<p>（2）客户端声明一个 exchange，并设置相关属性。</p>
<p>（3）客户端声明一个 queue，并设置相关属性。</p>
<p>（4）客户端使用 routing key，在 exchange 和 queue 之间建立好绑定关系。</p>
<p>（5）客户端投递消息到 exchange。</p>
<p>exchange 接收到消息后，就根据消息的 key 和已经设置的 binding，进行消息路由，将消息投递到一个或多个队列里。</p>
<h3 id="3-3-ZeroMQ"><a href="#3-3-ZeroMQ" class="headerlink" title="3.3. ZeroMQ"></a>3.3. ZeroMQ</h3><p>号称史上最快的消息队列，它实际类似于 Socket 的一系列接口，他跟 Socket 的区别是：普通的 socket 是端到端的（1:1 的关系），而 ZMQ 却是可以 N：M 的关系，人们对 BSD 套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而 ZMQ 屏蔽了这些细节，让你的网络编程更为简单。ZMQ 用于 node 与 node 间的通信，node 可以是主机或者是进程。</p>
<p>引用官方的说法： “ZMQ(以下 ZeroMQ 简称 ZMQ)是一个简单好用的传输层，像框架一样的一个 socket library，他使得 Socket 编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ 的明确目标是“成为标准网络协议栈的一部分，之后进入 Linux 内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD 套接字之上的一 层封装。ZMQ 让编写高性能网络应用程序极为简单和有趣。”</p>
<p>特点是：</p>
<ul>
<li>高性能，非持久化；</li>
<li>跨平台：支持 Linux、Windows、OS X 等。</li>
<li>多语言支持； C、C++、Java、.NET、Python 等 30 多种开发语言。</li>
<li>可单独部署或集成到应用中使用；</li>
<li>可作为 Socket 通信库使用。</li>
</ul>
<p>与 RabbitMQ 相比，ZMQ 并不像是一个传统意义上的消息队列服务器，事实上，它也根本不是一个服务器，更像一个底层的网络通讯库，在 Socket API 之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的 API 接口。支持“Request-Reply “，”Publisher-Subscriber“，”Parallel Pipeline”三种基本模型和扩展模型。</p>
<p>ZeroMQ 高性能设计要点：</p>
<p>1、无锁的队列模型</p>
<p>对于跨线程间的交互（用户端和 session）之间的数据交换通道 pipe，采用无锁的队列算法 CAS；在 pipe 两端注册有异步事件，在读或者写消息到 pipe 的时，会自动触发读写事件。</p>
<p>2、批量处理的算法</p>
<p>对于传统的消息处理，每个消息在发送和接收的时候，都需要系统的调用，这样对于大量的消息，系统的开销比较大，zeroMQ 对于批量的消息，进行了适应性的优化，可以批量的接收和发送消息。</p>
<p>3、多核下的线程绑定，无须 CPU 切换</p>
<p>区别于传统的多线程并发模式，信号量或者临界区， zeroMQ 充分利用多核的优势，每个核绑定运行一个工作者线程，避免多线程之间的 CPU 切换开销。</p>
<h3 id="3-4-Kafka"><a href="#3-4-Kafka" class="headerlink" title="3.4. Kafka"></a>3.4. Kafka</h3><p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像 Hadoop 的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka 的目的是通过 Hadoop 的并行加载机制来统一线上和离线的消息处理，也是为了通过集群机来提供实时的消费。</p>
<p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，有如下特性：</p>
<ul>
<li>通过 O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以 TB 的消息存储也能够保持长时间的稳定性能。（文件追加的方式写入数据，过期的数据定期删除）</li>
<li>高吞吐量：即使是非常普通的硬件 Kafka 也可以支持每秒数百万的消息。</li>
<li>支持通过 Kafka 服务器和消费机集群来分区消息。</li>
<li>支持 Hadoop 并行数据加载。</li>
</ul>
<p>Kafka 相关概念</p>
<ul>
<li>Broker</li>
</ul>
<p>Kafka 集群包含一个或多个服务器，这种服务器被称为 broker[5]</p>
<ul>
<li>Topic</li>
</ul>
<p>每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）</p>
<ul>
<li>Partition</li>
</ul>
<p>Parition 是物理上的概念，每个 Topic 包含一个或多个 Partition.</p>
<ul>
<li>Producer</li>
</ul>
<p>负责发布消息到 Kafka broker</p>
<ul>
<li>Consumer</li>
</ul>
<p>消息消费者，向 Kafka broker 读取消息的客户端。</p>
<ul>
<li>Consumer Group</li>
</ul>
<p>每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</p>
<p>一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用。</p>
<h2 id="4-MQ-示例"><a href="#4-MQ-示例" class="headerlink" title="4. MQ 示例"></a>4. MQ 示例</h2><h3 id="4-1-电商系统"><a href="#4-1-电商系统" class="headerlink" title="4.1. 电商系统"></a>4.1. 电商系统</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-1bbed6d1a2274ba1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>消息队列采用高可用，可持久化的消息中间件。比如 Active MQ，Rabbit MQ，Rocket Mq。</p>
<p>（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）</p>
<p>（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。</p>
<p>（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</p>
<h3 id="4-2-日志收集系统"><a href="#4-2-日志收集系统" class="headerlink" title="4.2. 日志收集系统"></a>4.2. 日志收集系统</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-4275c9f0e9c8c463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p>
<p>分为 Zookeeper 注册中心，日志收集客户端，Kafka 集群和 Storm 集群（OtherApp）四部分组成。</p>
<ul>
<li>Zookeeper 注册中心，提出负载均衡和地址查找服务；</li>
<li>日志收集客户端，用于采集应用系统的日志，并将数据推送到 kafka 队列；</li>
<li>Kafka 集群：接收，路由，存储，转发等消息处理；</li>
</ul>
<p>Storm 集群：与 OtherApp 处于同一级别，采用拉的方式消费队列中的数据；</p>
<h2 id="5-资料"><a href="#5-资料" class="headerlink" title="5. 资料"></a>5. 资料</h2><ul>
<li><a href="https://www.cnblogs.com/itfly8/p/5155983.html" target="_blank" rel="noopener">大型网站架构系列：分布式消息队列（一）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5156155.html" target="_blank" rel="noopener">大型网站架构系列：消息队列（二）</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></li>
<li><a href="https://juejin.im/entry/5a0abfb5f265da43062a4a91" target="_blank" rel="noopener">阿里 RocketMQ 优势对比</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/05/programming/java/javaweb/architecture/大型分布式网站架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/05/programming/java/javaweb/architecture/大型分布式网站架构/" itemprop="url">大型分布式网站架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T00:00:00+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="大型分布式网站架构"><a href="#大型分布式网站架构" class="headerlink" title="大型分布式网站架构"></a>大型分布式网站架构</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-大型分布式网站架构概述">1. 大型分布式网站架构概述</a><ul>
<li><a href="#11-大型网站的特点">1.1. 大型网站的特点</a></li>
<li><a href="#12-大型网站架构目标">1.2. 大型网站架构目标</a></li>
<li><a href="#13-大型网站架构模式">1.3. 大型网站架构模式</a></li>
<li><a href="#14-高性能架构">1.4. 高性能架构</a></li>
<li><a href="#15-高可用架构">1.5. 高可用架构</a></li>
<li><a href="#16-可伸缩架构">1.6. 可伸缩架构</a></li>
<li><a href="#17-可扩展架构">1.7. 可扩展架构</a></li>
<li><a href="#18-安全架构">1.8. 安全架构</a></li>
<li><a href="#19-敏捷性">1.9. 敏捷性</a></li>
<li><a href="#110-大型架构举例">1.10. 大型架构举例</a></li>
</ul>
</li>
<li><a href="#2-电商网站架构案例">2. 电商网站架构案例</a><ul>
<li><a href="#21-网站初级架构">2.1. 网站初级架构</a></li>
<li><a href="#22-系统容量预估">2.2. 系统容量预估</a></li>
<li><a href="#23-网站架构分析">2.3. 网站架构分析</a></li>
<li><a href="#24-网站架构优化">2.4. 网站架构优化</a></li>
<li><a href="#25-架构总结">2.5. 架构总结</a></li>
</ul>
</li>
<li><a href="#3-资料">3. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-大型分布式网站架构概述"><a href="#1-大型分布式网站架构概述" class="headerlink" title="1. 大型分布式网站架构概述"></a>1. 大型分布式网站架构概述</h2><h3 id="1-1-大型网站的特点"><a href="#1-1-大型网站的特点" class="headerlink" title="1.1. 大型网站的特点"></a>1.1. 大型网站的特点</h3><ul>
<li>用户多，分布广泛</li>
<li>大流量，高并发</li>
<li>海量数据，服务高可用</li>
<li>安全环境恶劣，易受网络攻击</li>
<li>功能多，变更快，频繁发布</li>
<li>从小到大，渐进发展</li>
<li>以用户为中心</li>
<li>免费服务，付费体验</li>
</ul>
<h3 id="1-2-大型网站架构目标"><a href="#1-2-大型网站架构目标" class="headerlink" title="1.2. 大型网站架构目标"></a>1.2. 大型网站架构目标</h3><ul>
<li>高性能：提供快速的访问体验。</li>
<li>高可用：网站服务一直可以正常访问。</li>
<li>可伸缩：通过硬件增加/减少，提高/降低处理能力。</li>
<li>安全性：提供网站安全访问和数据加密，安全存储等策略。</li>
<li>扩展性：方便的通过新增/移除方式，增加/减少新的功能/模块。</li>
<li>敏捷性：随需应变，快速响应；</li>
</ul>
<h3 id="1-3-大型网站架构模式"><a href="#1-3-大型网站架构模式" class="headerlink" title="1.3. 大型网站架构模式"></a>1.3. 大型网站架构模式</h3><ul>
<li>分层：一般可分为，应用层，服务层，数据层，管理层，分析层；</li>
<li>分割：一般按照业务/模块/功能特点进行划分，比如应用层分为首页，用户中心。</li>
<li>分布式：将应用分开部署（比如多台物理机），通过远程调用协同工作。</li>
<li>集群：一个应用/模块/功能部署多份（如：多台物理机），通过负载均衡共同提供对外访问。</li>
<li>缓存：将数据放在距离应用或用户最近的位置，加快访问速度。</li>
<li>异步：将同步的操作异步化。客户端发出请求，不等待服务端响应，等服务端处理完毕后，使用通知或轮询的方式告知请求方。一般指：请求——响应——通知 模式。</li>
<li>冗余：增加副本，提高可用性，安全性，性能。</li>
<li>安全：对已知问题有有效的解决方案，对未知/潜在问题建立发现和防御机制。</li>
<li>自动化：将重复的，不需要人工参与的事情，通过工具的方式，使用机器完成。</li>
<li>敏捷性：积极接受需求变更，快速响应业务发展需求。</li>
</ul>
<h3 id="1-4-高性能架构"><a href="#1-4-高性能架构" class="headerlink" title="1.4. 高性能架构"></a>1.4. 高性能架构</h3><p>以用户为中心，提供快速的网页访问体验。主要参数有较短的响应时间，较大的并发处理能力，较高的吞吐量，稳定的性能参数。</p>
<p>可分为前端优化，应用层优化，代码层优化，存储层优化。</p>
<p>前端优化：网站业务逻辑之前的部分；</p>
<p>浏览器优化：减少 Http 请求数，使用浏览器缓存，启用压缩，Css Js 位置，Js 异步，减少 Cookie 传输；</p>
<p>CDN 加速，反向代理；</p>
<p>应用层优化：处理网站业务的服务器。使用缓存，异步，集群</p>
<p>代码优化：合理的架构，多线程，资源复用（对象池，线程池等），良好的数据结构，JVM 调优，单例，Cache 等；</p>
<p>存储优化：缓存，固态硬盘，光纤传输，优化读写，磁盘冗余，分布式存储（HDFS），NOSQL 等；</p>
<h3 id="1-5-高可用架构"><a href="#1-5-高可用架构" class="headerlink" title="1.5. 高可用架构"></a>1.5. 高可用架构</h3><p>大型网站应该在任何时候都可以正常访问。正常提供对外服务。因为大型网站的复杂性，分布式，廉价服务器，开源数据库，操作系统等特点。要保证高可用是很困难的，也就是说网站的故障是不可避免的。</p>
<p>如何提高可用性，就是需要迫切解决的问题。首先，需要从架构级别，在规划的时候，就考虑可用性。行业内一般用几个 9 表示可用性指标。比如四个 9（99.99），一年内允许的不可用时间是 53 分钟。</p>
<p>不同层级使用的策略不同，一般采用冗余备份和失效转移解决高可用问题。</p>
<p>应用层：一般设计为无状态的，对于每次请求，使用哪一台服务器处理是没有影响的。一般使用负载均衡技术（需要解决 Session 同步问题），实现高可用。</p>
<p>服务层：负载均衡，分级管理，快速失败（超时设置），异步调用，服务降级，幂等设计等。</p>
<p>数据层：冗余备份（冷，热备[同步，异步]，温备），失效转移（确认，转移，恢复）。数据高可用方面著名的理论基础是 CAP 理论（持久性，可用性，数据一致性[强一致，用户一致，最终一致]）</p>
<h3 id="1-6-可伸缩架构"><a href="#1-6-可伸缩架构" class="headerlink" title="1.6. 可伸缩架构"></a>1.6. 可伸缩架构</h3><p>伸缩性是指在不改变原有架构设计的基础上，通过添加/减少硬件（服务器）的方式，提高/降低系统的处理能力。</p>
<p>应用层：对应用进行垂直或水平切分。然后针对单一功能进行负载均衡（DNS,HTTP[反向代理],IP,链路层）。</p>
<p>服务层：与应用层类似；</p>
<p>数据层：分库，分表，NOSQL 等；常用算法 Hash，一致性 Hash。</p>
<h3 id="1-7-可扩展架构"><a href="#1-7-可扩展架构" class="headerlink" title="1.7. 可扩展架构"></a>1.7. 可扩展架构</h3><p>可以方便的进行功能模块的新增/移除，提供代码/模块级别良好的可扩展性。</p>
<p>模块化，组件化：高内聚，内耦合，提高复用性，扩展性。</p>
<p>稳定接口：定义稳定的接口，在接口不变的情况下，内部结构可以“随意”变化。</p>
<p>设计模式：应用面向对象思想，原则，使用设计模式，进行代码层面的设计。</p>
<p>消息队列：模块化的系统，通过消息队列进行交互，使模块之间的依赖解耦。</p>
<p>分布式服务：公用模块服务化，提供其他系统使用，提高可重用性，扩展性。</p>
<h3 id="1-8-安全架构"><a href="#1-8-安全架构" class="headerlink" title="1.8. 安全架构"></a>1.8. 安全架构</h3><p>对已知问题有有效的解决方案，对未知/潜在问题建立发现和防御机制。对于安全问题，首先要提高安全意识，建立一个安全的有效机制，从政策层面，组织层面进行保障。比如服务器密码不能泄露，密码每月更新，并且三次内不能重复；每周安全扫描等。以制度化的方式，加强安全体系的建设。同时，需要注意与安全有关的各个环节。安全问题不容忽视。包括基础设施安全，应用系统安全，数据保密安全等。</p>
<p>基础设施安全：硬件采购，操作系统，网络环境方面的安全。一般采用，正规渠道购买高质量的产品，选择安全的操作系统，及时修补漏洞，安装杀毒软件防火墙。防范病毒，后门。设置防火墙策略，建立 DDOS 防御系统，使用攻击检测系统，进行 子网隔离等手段。</p>
<p>​ 应用系统安全：在程序开发时，对已知常用问题，使用正确的方式，在代码层面解决掉。防止跨站脚本攻击（XSS），注入攻击，跨站请求伪造（CSRF），错误信息，HTML 注释，文件上传，路径遍历等。还可以使用 Web 应用防火墙（比如：ModSecurity），进行安全漏洞扫描等措施，加强应用级别的安全。</p>
<p>​ 数据保密安全：存储安全（存在在可靠的设备，实时，定时备份），保存安全（重要的信息加密保存，选择合适的人员复杂保存和检测等），传输安全（防止数据窃取和数据篡改）；</p>
<p>​ 常用的加解密算法（单项散列加密[MD5,SHA]，对称加密[DES,3DES,RC]），非对称加密[RSA]等。</p>
<h3 id="1-9-敏捷性"><a href="#1-9-敏捷性" class="headerlink" title="1.9. 敏捷性"></a>1.9. 敏捷性</h3><p>网站的架构设计，运维管理要适应变化，提供高伸缩性，高扩展性。方便的应对快速的业务发展，突增高流量访问等要求。</p>
<p>除上面介绍的架构要素外，还需要引入敏捷管理，敏捷开发的思想。使业务，产品，技术，运维统一起来，随需应变，快速响应。</p>
<h3 id="1-10-大型架构举例"><a href="#1-10-大型架构举例" class="headerlink" title="1.10. 大型架构举例"></a>1.10. 大型架构举例</h3><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151116062211858-1998556963.png"></div><br></p>
<p>以上采用七层逻辑架构，第一层客户层，第二层前端优化层，第三层应用层，第四层服务层，第五层数据存储层，第六层大数据存储层，第七层大数据处理层。</p>
<p>客户层：支持 PC 浏览器和手机 APP。差别是手机 APP 可以直接访问通过 IP 访问，反向代理服务器。</p>
<p>前端层：使用 DNS 负载均衡，CDN 本地加速以及反向代理服务；</p>
<p>应用层：网站应用集群；按照业务进行垂直拆分，比如商品应用，会员中心等；</p>
<p>服务层：提供公用服务，比如用户服务，订单服务，支付服务等；</p>
<p>数据层：支持关系型数据库集群（支持读写分离），NOSQL 集群，分布式文件系统集群；以及分布式 Cache；</p>
<p>大数据存储层：支持应用层和服务层的日志数据收集，关系数据库和 NOSQL 数据库的结构化和半结构化数据收集；</p>
<p>大数据处理层：通过 Mapreduce 进行离线数据分析或 Storm 实时数据分析，并将处理后的数据存入关系型数据库。（实际使用中，离线数据和实时数据会按照业务要求进行分类处理，并存入不同的数据库中，供应用层或服务层使用）。</p>
<h2 id="2-电商网站架构案例"><a href="#2-电商网站架构案例" class="headerlink" title="2. 电商网站架构案例"></a>2. 电商网站架构案例</h2><h3 id="2-1-网站初级架构"><a href="#2-1-网站初级架构" class="headerlink" title="2.1. 网站初级架构"></a>2.1. 网站初级架构</h3><p>一般网站，刚开始的做法，是三台服务器，一台部署应用，一台部署数据库，一台部署 NFS 文件系统。</p>
<p>这是前几年比较传统的做法，之前见到一个网站 10 万多会员，垂直服装设计门户，N 多图片。使用了一台服务器部署了应用，数据库以及图片存储。出现了很多性能问题。</p>
<p>如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151130071801546-1010554271.png"></div><br></p>
<p>但是，目前主流的网站架构已经发生了翻天覆地的变化。一般都会采用集群的方式，进行高可用设计。至少是下面这个样子。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151130071816093-197013108.png"></div><br></p>
<p>（1） 使用集群对应用服务器进行冗余，实现高可用；（负载均衡设备可与应用一块部署）</p>
<p>使用数据库主备模式，实现数据备份和高可用；</p>
<h3 id="2-2-系统容量预估"><a href="#2-2-系统容量预估" class="headerlink" title="2.2. 系统容量预估"></a>2.2. 系统容量预估</h3><p>预估步骤：</p>
<p>（1） 注册用户数-日均 UV 量-每日的 PV 量-每天的并发量；</p>
<p>（2） 峰值预估：平常量的 2~3 倍；</p>
<p>（3） 根据并发量（并发，事务数），存储容量计算系统容量。</p>
<p>客户需求：3~5 年用户数达到 1000 万注册用户；</p>
<p>每秒并发数预估：</p>
<p>（1） 每天的 UV 为 200 万（二八原则）；</p>
<p>（2） 每日每天点击浏览 30 次；</p>
<p>（3） PV 量：200*30=6000 万；</p>
<p>（4） 集中访问量：24<em>0.2=4.8 小时会有 6000 万</em>0.8=4800 万（二八原则）；</p>
<p>（5） 每分并发量：4.8*60=288 分钟，每分钟访问 4800/288=16.7 万（约等于）；</p>
<p>（6） 每秒并发量：16.7 万/60=2780（约等于）；</p>
<p>（7） 假设：高峰期为平常值的三倍，则每秒的并发数可以达到 8340 次。</p>
<p>（8） 1 毫秒=1.3 次访问；</p>
<p>没好好学数学后悔了吧？！（不知道以上算是否有错误，呵呵~~）</p>
<p>服务器预估：（以 tomcat 服务器举例）</p>
<p>（1） 按一台 web 服务器，支持每秒 300 个并发计算。平常需要 10 台服务器（约等于）；[tomcat 默认配置是 150]</p>
<p>（2） 高峰期：需要 30 台服务器；</p>
<p>容量预估：70/90 原则</p>
<p>系统 CPU 一般维持在 70%左右的水平，高峰期达到 90%的水平，是不浪费资源，并比较稳定的。内存，IO 类似。</p>
<p>以上预估仅供参考，因为服务器配置，业务逻辑复杂度等都有影响。在此 CPU，硬盘，网络等不再进行评估。</p>
<h3 id="2-3-网站架构分析"><a href="#2-3-网站架构分析" class="headerlink" title="2.3. 网站架构分析"></a>2.3. 网站架构分析</h3><p>根据以上预估，有几个问题：</p>
<ul>
<li>需要部署大量的服务器，高峰期计算，可能要部署 30 台 Web 服务器。并且这三十台服务器，只有秒杀，活动时才会用到，存在大量的浪费。</li>
<li>所有的应用部署在同一台服务器，应用之间耦合严重。需要进行垂直切分和水平切分。</li>
<li>大量应用存在冗余代码</li>
<li>服务器 SESSION 同步耗费大量内存和网络带宽</li>
<li>数据需要频繁访问数据库，数据库访问压力巨大。</li>
</ul>
<p>大型网站一般需要做以下架构优化（优化是架构设计时，就要考虑的，一般从架构/代码级别解决，调优主要是简单参数的调整，比如 JVM 调优；如果调优涉及大量代码改造，就不是调优了，属于重构）：</p>
<ul>
<li>业务拆分</li>
<li>应用集群部署（分布式部署，集群部署和负载均衡）</li>
<li>多级缓存</li>
<li>单点登录（分布式 Session）</li>
<li>数据库集群（读写分离，分库分表）</li>
<li>服务化</li>
<li>消息队列</li>
<li>其他技术</li>
</ul>
<h3 id="2-4-网站架构优化"><a href="#2-4-网站架构优化" class="headerlink" title="2.4. 网站架构优化"></a>2.4. 网站架构优化</h3><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><p>根据业务属性进行垂直切分，划分为产品子系统，购物子系统，支付子系统，评论子系统，客服子系统，接口子系统（对接如进销存，短信等外部系统）。</p>
<p>根据业务子系统进行等级定义，可分为核心系统和非核心系统。核心系统：产品子系统，购物子系统，支付子系统；非核心：评论子系统，客服子系统，接口子系统。</p>
<p>业务拆分作用：提升为子系统可由专门的团队和部门负责，专业的人做专业的事，解决模块之间耦合以及扩展性问题；每个子系统单独部署，避免集中部署导致一个应用挂了，全部应用不可用的问题。</p>
<p>等级定义作用：用于流量突发时，对关键应用进行保护，实现优雅降级；保护关键应用不受到影响。</p>
<p>拆分后的架构图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151130073032968-1952416935.png"></div><br></p>
<p>参考部署方案 2<br><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151130073047530-940494801.png"></div><br></p>
<p>（1） 如上图每个应用单独部署</p>
<p>（2） 核心系统和非核心系统组合部署</p>
<h4 id="应用集群部署（分布式，集群，负载均衡）"><a href="#应用集群部署（分布式，集群，负载均衡）" class="headerlink" title="应用集群部署（分布式，集群，负载均衡）"></a>应用集群部署（分布式，集群，负载均衡）</h4><p>​ 分布式部署：将业务拆分后的应用单独部署，应用直接通过 RPC 进行远程通信；</p>
<p>​ 集群部署：电商网站的高可用要求，每个应用至少部署两台服务器进行集群部署；</p>
<p>​ 负载均衡：是高可用系统必须的，一般应用通过负载均衡实现高可用，分布式服务通过内置的负载均衡实现高可用，关系型数据库通过主备方式实现高可用。</p>
<p>集群部署后架构图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151130073058983-1408763899.png"></div><br></p>
<h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><p>缓存按照存放的位置一般可分为两类：本地缓存和分布式缓存。本案例采用二级缓存的方式，进行缓存的设计。一级缓存为本地缓存，二级缓存为分布式缓存。（还有页面缓存，片段缓存等，那是更细粒度的划分）</p>
<p>一级缓存，缓存数据字典，和常用热点数据等基本不可变/有规则变化的信息，二级缓存缓存需要的所有缓存。当一级缓存过期或不可用时，访问二级缓存的数据。如果二级缓存也没有，则访问数据库。</p>
<p>缓存的比例，一般 1:4，即可考虑使用缓存。（理论上是 1:2 即可）。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151130073113483-523713370.png"></div><br></p>
<p>​ 根据业务特性可使用以下缓存过期策略：</p>
<p>（1） 缓存自动过期；</p>
<p>（2） 缓存触发过期；</p>
<h4 id="单点登录（分布式-Session）"><a href="#单点登录（分布式-Session）" class="headerlink" title="单点登录（分布式 Session）"></a>单点登录（分布式 Session）</h4><p>系统分割为多个子系统，独立部署后，不可避免的会遇到会话管理的问题。一般可采用 Session 同步，Cookies，分布式 Session 方式。电商网站一般采用分布式 Session 实现。</p>
<p>再进一步可以根据分布式 Session，建立完善的单点登录或账户管理系统。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201511/820332-20151130073125015-707498377.png"></div><br></p>
<p>​ 流程说明</p>
<p>（1） 用户第一次登录时，将会话信息（用户 Id 和用户信息），比如以用户 Id 为 Key，写入分布式 Session；</p>
<p>（2） 用户再次登录时，获取分布式 Session，是否有会话信息，如果没有则调到登录页；</p>
<p>（3） 一般采用 Cache 中间件实现，建议使用 Redis，因为它有持久化功能，方便分布式 Session 宕机后，可以从持久化存储中加载会话信息；</p>
<p>（4） 存入会话时，可以设置会话保持的时间，比如 15 分钟，超过后自动超时；</p>
<p>结合 Cache 中间件，实现的分布式 Session，可以很好的模拟 Session 会话。</p>
<h4 id="数据库集群（读写分离，分库分表）"><a href="#数据库集群（读写分离，分库分表）" class="headerlink" title="数据库集群（读写分离，分库分表）"></a>数据库集群（读写分离，分库分表）</h4><p>大型网站需要存储海量的数据，为达到海量数据存储，高可用，高性能一般采用冗余的方式进行系统设计。一般有两种方式读写分离和分库分表。</p>
<p>读写分离：一般解决读比例远大于写比例的场景，可采用一主一备，一主多备或多主多备方式。</p>
<p>本案例在业务拆分的基础上，结合分库分表和读写分离。如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151201062903515-1864482914.png"></div><br></p>
<p>（1） 业务拆分后：每个子系统需要单独的库；</p>
<p>（2） 如果单独的库太大，可以根据业务特性，进行再次分库，比如商品分类库，产品库；</p>
<p>（3） 分库后，如果表中有数据量很大的，则进行分表，一般可以按照 Id，时间等进行分表；（高级的用法是一致性 Hash）</p>
<p>（4） 在分库，分表的基础上，进行读写分离；</p>
<p>相关中间件可参考 Cobar（阿里，目前已不在维护），TDDL（阿里），Atlas（奇虎 360），MyCat（在 Cobar 基础上，国内很多牛人，号称国内第一开源项目）。</p>
<p>分库分表后序列的问题，JOIN，事务的问题，会在分库分表主题分享中，介绍。</p>
<h4 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h4><p>​将多个子系统公用的功能/模块，进行抽取，作为公用服务使用。比如本案例的会员子系统就可以抽取为公用的服务。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151201062916952-1233076938.png"></div><br></p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>​ 消息队列可以解决子系统/模块之间的耦合，实现异步，高可用，高性能的系统。是分布式系统的标准配置。本案例中，消息队列主要应用在购物，配送环节。</p>
<p>（1） 用户下单后，写入消息队列，后直接返回客户端；</p>
<p>（2） 库存子系统：读取消息队列信息，完成减库存；</p>
<p>（3） 配送子系统：读取消息队列信息，进行配送；</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151201062938155-1893082140.png"></div><br></p>
<p>目前使用较多的 MQ 有 Active MQ,Rabbit MQ,Zero MQ，MS MQ 等，需要根据具体的业务场景进行选择。建议可以研究下 Rabbit MQ。</p>
<h4 id="其他架构（技术）"><a href="#其他架构（技术）" class="headerlink" title="其他架构（技术）"></a>其他架构（技术）</h4><p>除了以上介绍的业务拆分，应用集群，多级缓存，单点登录，数据库集群，服务化，消息队列外。还有 CDN，反向代理，分布式文件系统，大数据处理等系统。</p>
<p>此处不详细介绍，大家可以问度娘/Google，有机会的话也可以分享给大家。</p>
<h3 id="2-5-架构总结"><a href="#2-5-架构总结" class="headerlink" title="2.5. 架构总结"></a>2.5. 架构总结</h3><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151201062949187-431217543.png"></div><br></p>
<p>以上是本次分享的架构总结，其中细节可参考前面分享的内容。其中还有很多可以优化和细化的地方，因为是案例分享，主要针对重要部分做了介绍，工作中需要大家根据具体的业务场景进行架构设计。</p>
<p>以上是电商网站架构案例的分享一共有三篇，从电商网站的需求，到单机架构，逐步演变为常用的，可供参考的分布式架构的原型。除具备功能需求外，还具备一定的高性能，高可用，可伸缩，可扩展等非功能质量需求（架构目标）。</p>
<h2 id="3-资料"><a href="#3-资料" class="headerlink" title="3. 资料"></a>3. 资料</h2><p><a href="https://www.cnblogs.com/itfly8/p/4967966.html" target="_blank" rel="noopener">大型分布式网站架构技术总结</a></p>
<p><a href="https://www.cnblogs.com/itfly8/p/5006197.html" target="_blank" rel="noopener">大型网站架构系列：电商网站架构案例(1)</a></p>
<p><a href="https://www.cnblogs.com/itfly8/p/5006200.html" target="_blank" rel="noopener">大型网站架构系列：电商网站架构案例(2)</a></p>
<p><a href="https://www.cnblogs.com/itfly8/p/5009005.html" target="_blank" rel="noopener">大型网站架构系列：电商网站架构案例(3)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/05/programming/java/javaweb/distributed/cache/分布式缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/05/programming/java/javaweb/distributed/cache/分布式缓存/" itemprop="url">分布式缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T00:00:00+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-缓存概述">1. 缓存概述</a><ul>
<li><a href="#11-缓存的原理">1.1. 缓存的原理</a></li>
<li><a href="#12-缓存分类">1.2. 缓存分类</a></li>
<li><a href="#13-缓存媒介">1.3. 缓存媒介</a></li>
<li><a href="#14-缓存设计">1.4. 缓存设计</a></li>
</ul>
</li>
<li><a href="#2-cdn-缓存">2. CDN 缓存</a><ul>
<li><a href="#21-cdn-原理">2.1. CDN 原理</a></li>
<li><a href="#22-cdn-优缺点">2.2. CDN 优缺点</a></li>
<li><a href="#23-cnd-架构参考">2.3. CND 架构参考</a></li>
<li><a href="#24-cnd-技术实践">2.4. CND 技术实践</a></li>
</ul>
</li>
<li><a href="#3-反向代理缓存">3. 反向代理缓存</a><ul>
<li><a href="#31-缓存原理">3.1. 缓存原理</a></li>
<li><a href="#32-squid-示例">3.2. Squid 示例</a></li>
<li><a href="#33-代理缓存比较">3.3. 代理缓存比较</a></li>
</ul>
</li>
<li><a href="#4-分布式缓存">4. 分布式缓存</a><ul>
<li><a href="#41-memcache">4.1. Memcache</a></li>
<li><a href="#42-memcache-工作原理">4.2. Memcache 工作原理</a></li>
<li><a href="#43-memcache-集群">4.3. Memcache 集群</a></li>
<li><a href="#44-redis">4.4. Redis</a></li>
<li><a href="#45-redis-常用数据类型">4.5. Redis 常用数据类型</a></li>
<li><a href="#46-redis-集群">4.6. Redis 集群</a></li>
<li><a href="#47-memcache-与-redis-的比较">4.7. Memcache 与 Redis 的比较</a></li>
</ul>
</li>
<li><a href="#5-本地缓存">5. 本地缓存</a><ul>
<li><a href="#51-硬盘缓存">5.1. 硬盘缓存</a></li>
<li><a href="#52-内存缓存">5.2. 内存缓存</a></li>
</ul>
</li>
<li><a href="#6-缓存架构示例">6. 缓存架构示例</a></li>
<li><a href="#7-数据一致性">7. 数据一致性</a><ul>
<li><a href="#71-场景介绍">7.1. 场景介绍</a></li>
<li><a href="#72-解决方法">7.2. 解决方法</a></li>
<li><a href="#73-其他方法">7.3. 其他方法</a></li>
</ul>
</li>
<li><a href="#8-缓存高可用">8. 缓存高可用</a><ul>
<li><a href="#81-解决方法">8.1. 解决方法</a></li>
<li><a href="#82-其他方法">8.2. 其他方法</a></li>
</ul>
</li>
<li><a href="#9-缓存问题">9. 缓存问题</a><ul>
<li><a href="#91-缓存雪崩">9.1. 缓存雪崩</a></li>
<li><a href="#92-缓存穿透">9.2. 缓存穿透</a></li>
<li><a href="#93-缓存预热">9.3. 缓存预热</a></li>
<li><a href="#94-缓存更新">9.4. 缓存更新</a></li>
<li><a href="#95-缓存降级">9.5. 缓存降级</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-缓存概述"><a href="#1-缓存概述" class="headerlink" title="1. 缓存概述"></a>1. 缓存概述</h2><p>缓存是分布式系统中的重要组件，主要解决高并发，大数据场景下，热点数据访问的性能问题。提供高性能的数据快速访问。</p>
<h3 id="1-1-缓存的原理"><a href="#1-1-缓存的原理" class="headerlink" title="1.1. 缓存的原理"></a>1.1. 缓存的原理</h3><ol>
<li>将数据写入/读取速度更快的存储（设备）；</li>
<li>将数据缓存到离应用最近的位置；</li>
<li>将数据缓存到离用户最近的位置。</li>
</ol>
<h3 id="1-2-缓存分类"><a href="#1-2-缓存分类" class="headerlink" title="1.2. 缓存分类"></a>1.2. 缓存分类</h3><p>在分布式系统中，缓存的应用非常广泛，从部署角度有以下几个方面的缓存应用。</p>
<ol>
<li>CDN 缓存；</li>
<li>反向代理缓存；</li>
<li>分布式 Cache；</li>
<li>本地应用缓存；</li>
</ol>
<h3 id="1-3-缓存媒介"><a href="#1-3-缓存媒介" class="headerlink" title="1.3. 缓存媒介"></a>1.3. 缓存媒介</h3><ul>
<li>常用中间件：Varnish，Ngnix，Squid，Memcache，Redis，Ehcache 等；</li>
<li>缓存的内容：文件，数据，对象；</li>
<li>缓存的介质：CPU，内存（本地，分布式），磁盘（本地，分布式）</li>
</ul>
<h3 id="1-4-缓存设计"><a href="#1-4-缓存设计" class="headerlink" title="1.4. 缓存设计"></a>1.4. 缓存设计</h3><p>缓存设计需要解决以下几个问题：</p>
<p>（1）缓存什么？</p>
<p>哪些数据需要缓存：热点数据、静态资源</p>
<p>（2）缓存的位置？</p>
<p>CDN，反向代理，分布式缓存服务器，本机（内存，硬盘）</p>
<p>（3）如何缓存的问题？</p>
<ul>
<li>过期策略<ul>
<li>固定时间：比如指定缓存的时间是 30 分钟；</li>
<li>相对时间：比如最近 10 分钟内没有访问的数据；</li>
</ul>
</li>
<li>同步机制<ul>
<li>实时写入；（推）</li>
<li>异步刷新；（推拉）</li>
</ul>
</li>
</ul>
<h2 id="2-CDN-缓存"><a href="#2-CDN-缓存" class="headerlink" title="2. CDN 缓存"></a>2. CDN 缓存</h2><p>CDN 主要解决将数据缓存到离用户最近的位置，一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<h3 id="2-1-CDN-原理"><a href="#2-1-CDN-原理" class="headerlink" title="2.1. CDN 原理"></a>2.1. CDN 原理</h3><p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>（1）未部署 CDN 应用前</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062828308-319014468.png"></div><br></p>
<p>网络路径：</p>
<ul>
<li>请求：本机网络（局域网）——》运营商网络——》应用服务器机房</li>
<li>响应：应用服务器机房——》运营商网络——》本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。</p>
<p>（2）部署 CDN 应用后</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062837558-517040681.png"></div><br></p>
<p>网络路径：</p>
<ul>
<li>请求：本机网络（局域网）——》运营商网络</li>
<li>响应：运营商网络——》本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。</p>
<p>与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高的系统的响应速度。</p>
<h3 id="2-2-CDN-优缺点"><a href="#2-2-CDN-优缺点" class="headerlink" title="2.2. CDN 优缺点"></a>2.2. CDN 优缺点</h3><p>（1）优点（摘自百度百科）</p>
<ul>
<li>本地 Cache 加速：提升访问速度，尤其含有大量图片和静态页面站点；</li>
<li>镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；</li>
<li>远程加速：远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；</li>
<li>带宽优化：自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li>
<li>集群抗攻击：广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。</li>
</ul>
<p>（2）缺点</p>
<p>a. 动态资源缓存，需要注意实时性；</p>
<p>解决：主要缓存静态资源，动态资源建立多级缓存或准实时同步；</p>
<p>b. 如何保证数据的一致性和实时性需要权衡考虑；</p>
<p>解决：</p>
<ol>
<li>设置缓存失效时间（1 个小时，最终一致性）；</li>
<li>数据版本号；</li>
</ol>
<h3 id="2-3-CND-架构参考"><a href="#2-3-CND-架构参考" class="headerlink" title="2.3. CND 架构参考"></a>2.3. CND 架构参考</h3><p>摘自《云宙视频 CDN 系统》</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062848590-1014999706.jpg"></div><br></p>
<h3 id="2-4-CND-技术实践"><a href="#2-4-CND-技术实践" class="headerlink" title="2.4. CND 技术实践"></a>2.4. CND 技术实践</h3><p>​ 目前，中小型互联网公司，综合成本考虑，一般租用第三方 CDN 服务，大型互联网公司，采用自建或第三方结合的方式。比如淘宝刚开始使用第三方的，当流量很大后，第三方公司无法支撑其 CDN 流量，淘宝最后采用自建 CDN 的方式实现。</p>
<p>淘宝 CDN，如下图（来自网络）：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062859808-1261244246.png"></div><br></p>
<h2 id="3-反向代理缓存"><a href="#3-反向代理缓存" class="headerlink" title="3. 反向代理缓存"></a>3. 反向代理缓存</h2><p>反向代理是指在网站服务器机房部署代理服务器，实现负载均衡，数据缓存，安全控制等功能。</p>
<h3 id="3-1-缓存原理"><a href="#3-1-缓存原理" class="headerlink" title="3.1. 缓存原理"></a>3.1. 缓存原理</h3><p>反向代理位于应用服务器机房，处理所有对 WEB 服务器的请求。如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062912886-1223701582.png"></div><br></p>
<p>​ 反向代理一般缓存静态资源，动态资源转发到应用服务器处理。常用的缓存应用服务器有 Varnish，Ngnix，Squid。</p>
<h3 id="3-2-Squid-示例"><a href="#3-2-Squid-示例" class="headerlink" title="3.2. Squid 示例"></a>3.2. Squid 示例</h3><p>Squid 反向代理一般只缓存静态资源，动态程序默认不缓存。根据从 WEB 服务器返回的 HTTP 头标记来缓冲静态页面。有四个最重要 HTTP 头标记：</p>
<ul>
<li>Last-Modified: 告诉反向代理页面什么时间被修改</li>
<li>Expires: 告诉反向代理页面什么时间应该从缓冲区中删除</li>
<li>Cache-Control: 告诉反向代理页面是否应该被缓冲</li>
<li>Pragma: 用来包含实现特定的指令，最常用的是 Pragma:no-cache</li>
</ul>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062921683-1401924233.jpg"></div><br></p>
<p>Squid 反向代理加速网站实例</p>
<ol>
<li>通过 DNS 的轮询技术，将客户端的请求分发给其中一台 Squid 反向代理服务器处理；</li>
<li>如果这台 Squid 缓存了用户的请求资源，则将请求的资源直接返回给用户；</li>
<li>否则这台 Squid 将没有缓存的请求根据配置的规则发送给邻居 Squid 和后台的 WEB 服务器处理；</li>
<li>这样既减轻后台 WEB 服务器的负载，又提高整个网站的性能和安全性。</li>
</ol>
<h3 id="3-3-代理缓存比较"><a href="#3-3-代理缓存比较" class="headerlink" title="3.3. 代理缓存比较"></a>3.3. 代理缓存比较</h3><p>常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：</p>
<ol>
<li>Varnish 和 squid 是专业的 cache 服务，nginx 需要第三方模块支持；</li>
<li>Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；</li>
<li>Varnish 由于是内存 cache，所以对小文件如 css,js,小图片啥的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；</li>
<li>Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 nginx 做负载均衡跑多个实例；</li>
<li>Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 varnish，一般作为反向代理使用，可以实现简单的缓存。</li>
</ol>
<h2 id="4-分布式缓存"><a href="#4-分布式缓存" class="headerlink" title="4. 分布式缓存"></a>4. 分布式缓存</h2><p>CDN、反向代理缓存，主要解决静态文件，或用户请求资源的缓存，数据源一般为静态文件或动态生成的文件（有缓存头标识）。</p>
<p>分布式缓存，主要指缓存用户经常访问数据的缓存，数据源为数据库。一般起到热点数据访问和减轻数据库压力的作用。</p>
<p>目前分布式缓存设计，在大型网站架构中是必备的架构要素。常用的中间件有 Memcache，Redis。</p>
<h3 id="4-1-Memcache"><a href="#4-1-Memcache" class="headerlink" title="4.1. Memcache"></a>4.1. Memcache</h3><p>Memcache 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。</p>
<p>Memcache 特性：</p>
<ul>
<li>使用物理内存作为缓存区，可独立运行在服务器上。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcache 进程（不同端口）或者使用分布式 Memcache 进行缓存，将数据缓存到不同的物理机或者虚拟机上。</li>
<li>使用 key-value 的方式来存储数据，这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。</li>
<li>协议简单：基于文本行的协议，直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；</li>
<li>基于 libevent 高性能通信：Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。</li>
<li>内置的内存管理方式：所有数据都保存在内存中，存取数据比硬盘快，当内存满后，通过 LRU 算法自动删除不使用的缓存，但没有考虑数据的容灾问题，重启服务，所有数据会丢失。</li>
<li>分布式：各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcache 客户端。</li>
<li>缓存策略：Memcached 的缓存策略是 LRU（最近最少使用）到期失效策略。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。</li>
</ul>
<h3 id="4-2-Memcache-工作原理"><a href="#4-2-Memcache-工作原理" class="headerlink" title="4.2. Memcache 工作原理"></a>4.2. Memcache 工作原理</h3><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064023621-1066632858.png"></div><br></p>
<p>Memcache 的工作流程如下：</p>
<ol>
<li>先检查客户端的请求数据是否在 Memcached 中，如有，直接把请求数据返回，不再对数据库进行任何操作；</li>
<li>如果请求的数据不在 Memcached 中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到 Memcached 中（Memcached 客户端不负责，需要程序实现）；</li>
<li>每次更新数据库的同时更新 Memcached 中的数据，保证一致性；</li>
<li>当分配给 Memcached 内存空间用完之后，会使用 LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。</li>
</ol>
<h3 id="4-3-Memcache-集群"><a href="#4-3-Memcache-集群" class="headerlink" title="4.3. Memcache 集群"></a>4.3. Memcache 集群</h3><p>Memcached 虽然称为 “ 分布式 ” 缓存服务器，但服务器端并没有 “ 分布式 ” 功能。每个服务器都是完全独立和隔离的服务。 Memcached 的分布式，是由客户端程序实现的。</p>
<p>当向 Memcached 集群存入/取出 key value 时，Memcached 客户端程序根据一定的算法计算存入哪台服务器，然后再把 key value 值存到此服务器中。</p>
<p>存取数据分二步走，第一步，选择服务器，第二步存取数据。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064101183-532365936.png"></div><br></p>
<p><strong>分布式算法(Consistent Hashing)：</strong></p>
<p>选择服务器算法有两种，一种是根据余数来计算分布，另一种是根据散列算法来计算分布。</p>
<ul>
<li>余数算法：<br>先求得键的整数散列值，再除以服务器台数，根据余数确定存取服务器。<ul>
<li>优点：计算简单，高效；</li>
<li>缺点：在 Memcached 服务器增加或减少时，几乎所有的缓存都会失效。</li>
</ul>
</li>
<li>散列算法：（一致性 Hash）<br>先算出 Memcached 服务器的散列值，并将其分布到 0 到 2 的 32 次方的圆上，然后用同样的方法算出存储数据的键的散列值并映射至圆上，最后从数据映射到的位置开始顺时针查找，将数据保存到查找到的第一个服务器上，如果超过 2 的 32 次方，依然找不到服务器，就将数据保存到第一台 Memcached 服务器上。</li>
</ul>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064109965-1633058692.jpg"></div><br></p>
<p>如果添加了一台 Memcached 服务器，只在圆上增加服务器的逆时针方向的第一台服务器上的键会受到影响。</p>
<p>一致性 Hash 算法：解决了余数算法增加节点命中大幅额度降低的问题，理论上，插入一个实体节点，平均会影响到：虚拟节点数 /2 的节点数据的命中。</p>
<h3 id="4-4-Redis"><a href="#4-4-Redis" class="headerlink" title="4.4. Redis"></a>4.4. Redis</h3><p>Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。 支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。</p>
<p>内置了 复制（replication），LUA 脚本（Lua scripting）， LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p>
<h3 id="4-5-Redis-常用数据类型"><a href="#4-5-Redis-常用数据类型" class="headerlink" title="4.5. Redis 常用数据类型"></a>4.5. Redis 常用数据类型</h3><p>1、String</p>
<p>常用命令：set,get,decr,incr,mget 。</p>
<p>应用场景：String 是最常用的一种数据类型，与 Memcache 的 key value 存储方式类似。</p>
<p>实现方式：String 在 Redis 内部存储默认就是一个字符串，被 RedisObject 所引用，当遇到 incr,decr 等操作时会转成数值型进行计算，此时 RedisObject 的 encoding 字段为 int。</p>
<p>2、Hash</p>
<p>常用命令：hget,hset,hgetall 。</p>
<p>应用场景：以存储一个用户信息对象数据，为例：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064128371-891992227.png"></div><br></p>
<p>实现方式：</p>
<p>Redis Hash 对应的 Value，内部实际就是一个 HashMap，实际这里会有 2 种不同实现。</p>
<p>（1） Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数 组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 value RedisObject 的 encoding 为 zipmap；</p>
<p>（2） 当成员数量增大时会自动转成真正的 HashMap,此时 encoding 为 ht。</p>
<p>3、List</p>
<p>常用命令：lpush,rpush,lpop,rpop,lrange。</p>
<p>应用场景：</p>
<p>Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 list 结构来实现。</p>
<p>实现方式：</p>
<p>Redis list 的实现为一个双向链表，可以支持反向查找和遍历，方便操作。不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
<p>4、Set</p>
<p>常用命令：sadd,spop,smembers,sunion。</p>
<p>应用场景：</p>
<p>Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p>
<p>实现方式：</p>
<p>set 的内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因。</p>
<p>5、Sorted set</p>
<p>常用命令：zadd,zrange,zrem,zcard；</p>
<p>使用场景：</p>
<p>Redis sorted set 的使用场景与 set 类似，区别是 set 不是自动有序的，而 sorted set 可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，可以选择 sorted set 数据结构，比如 twitter 的 public timeline 可以以发表时间作为 score 来存储，这样获取时就是自动按时间排好序的。</p>
<p>实现方式：</p>
<p>Redis sorted set 的内部使用 HashMap 和跳跃表(SkipList)来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的 是所有的成员，排序依据是 HashMap 里存的 score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<h3 id="4-6-Redis-集群"><a href="#4-6-Redis-集群" class="headerlink" title="4.6. Redis 集群"></a>4.6. Redis 集群</h3><p>（1）通过 keepalived 实现的高可用方案</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064149465-1648287265.png"></div><br></p>
<p>切换流程：</p>
<ol>
<li>当 Master 挂了后，VIP 漂移到 Slave；Slave 上 keepalived 通知 Redis 执行：slaveof no one ,开始提供业务</li>
<li>当 Master 起来后，VIP 地址不变，Master 的 keepalived 通知 Redis 执行 slaveof slave IP host ，开始作为从同步数据</li>
<li>依次类推</li>
</ol>
<p>主从同时 Down 机情况：</p>
<ul>
<li>非计划性，不做考虑，一般也不会存在这种问题</li>
<li>计划性重启，重启之前通过运维手段 SAVE DUMP 主库数据；需要注意顺序：<ol>
<li>关闭其中一台机器上所有 Redis，使得 master 全部切到另外一台机器（多实例部署，单机上既有主又有从的情况）；并关闭机器。</li>
<li>依次 dump 主上 Redis 服务</li>
<li>关闭主</li>
<li>启动主，并等待数据 load 完毕</li>
<li>启动从</li>
<li>删除 DUMP 文件（避免重启加载慢）</li>
</ol>
</li>
</ul>
<p>（2）使用 Twemproxy 实现集群方案</p>
<p>由 twitter 开源的 c 版本 proxy，同时支持 Memcache 和 Redis，目前最新版本为：0.2.4，持续开发中;<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">https://github.com/twitter/twemproxy</a> .twitter 用它主要减少前端与缓存服务间网络连接数。</p>
<p>特点：快、轻量级、减少后端 Cache Server 连接数、易配置、支持 ketama、modula、random、常用 hash 分片算法。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064241496-1034024146.png"></div><br></p>
<p>这里使用 keepalived 实现高可用主备方案，解决 proxy 单点问题；</p>
<p>优点：</p>
<ul>
<li>对于客户端而言，Redis 集群是透明的，客户端简单，遍于动态扩容</li>
<li>Proxy 为单点、处理一致性 hash 时，集群节点可用性检测不存在脑裂问题</li>
<li>高性能，CPU 密集型，而 Redis 节点集群多 CPU 资源冗余，可部署在 Redis 节点集群上，不需要额外设备</li>
</ul>
<h3 id="4-7-Memcache-与-Redis-的比较"><a href="#4-7-Memcache-与-Redis-的比较" class="headerlink" title="4.7. Memcache 与 Redis 的比较"></a>4.7. Memcache 与 Redis 的比较</h3><ul>
<li>数据结构：Memcache 只支持 key value 存储方式，Redis 支持更多的数据类型，比如 Key value，hash，list，set，zset；</li>
<li>多线程：Memcache 支持多线程，Redis 支持单线程；CPU 利用方面 Memcache 优于 Redis；</li>
<li>持久化：Memcache 不支持持久化，Redis 支持持久化；</li>
<li>内存利用率：Memcache 高，Redis 低（采用压缩的情况下比 Memcache 高）；</li>
<li>过期策略：Memcache 过期后，不删除缓存，会导致下次取数据数据的问题，Redis 有专门线程，清除缓存数据；</li>
</ul>
<h2 id="5-本地缓存"><a href="#5-本地缓存" class="headerlink" title="5. 本地缓存"></a>5. 本地缓存</h2><p>本地缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。</p>
<h3 id="5-1-硬盘缓存"><a href="#5-1-硬盘缓存" class="headerlink" title="5.1. 硬盘缓存"></a>5.1. 硬盘缓存</h3><p>​ 将数据缓存到硬盘到，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。</p>
<h3 id="5-2-内存缓存"><a href="#5-2-内存缓存" class="headerlink" title="5.2. 内存缓存"></a>5.2. 内存缓存</h3><p>直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。</p>
<h2 id="6-缓存架构示例"><a href="#6-缓存架构示例" class="headerlink" title="6. 缓存架构示例"></a>6. 缓存架构示例</h2><p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064322168-810312242.png"></div><br></p>
<p>职责划分：</p>
<ul>
<li>CDN：存放 HTML,CSS,JS 等静态资源；</li>
<li>反向代理：动静分离，只缓存用户请求的静态资源；</li>
<li>分布式缓存：缓存数据库中的热点数据；</li>
<li>本地缓存：缓存应用字典等常用数据；</li>
</ul>
<p>请求过程：</p>
<ol>
<li>浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；</li>
<li>如果 CDN 无缓存，则访问反向代理服务器；</li>
<li>如果反向代理服务器有缓存则直接返回；</li>
<li>如果反向代理服务器无缓存或动态请求，则访问应用服务器；</li>
<li>应用服务器访问本地缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）</li>
<li>如果本地缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；</li>
<li>如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；</li>
</ol>
<h2 id="7-数据一致性"><a href="#7-数据一致性" class="headerlink" title="7. 数据一致性"></a>7. 数据一致性</h2><p>缓存是在数据持久化之前的一个节点，主要是将热点数据放到离用户最近或访问速度更快的介质中，加快数据的访问，减小响应时间。</p>
<p>因为缓存属于持久化数据的一个副本，因此不可避免的会出现数据不一致问题。导致脏读或读不到数据的情况。数据不一致，一般是因为网络不稳定或节点故障导致。根据数据的操作顺序，主要有以下几种情况。</p>
<h3 id="7-1-场景介绍"><a href="#7-1-场景介绍" class="headerlink" title="7.1. 场景介绍"></a>7.1. 场景介绍</h3><p>（1）先写缓存，再写数据库</p>
<p>​ 如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110523914-514476589.jpg"></div><br></p>
<p>假如缓存写成功，但写数据库失败或响应延迟，则下次读取（并发读）缓存时，就出现脏读；</p>
<p>（2）先写数据库，再写缓存</p>
<p>​ 如下图：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110532039-1008665032.jpg"></div><br></p>
<p>​ 假如写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据；</p>
<p>（3）缓存异步刷新</p>
<p>​ 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候。</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110540555-889329617.jpg"></div><br></p>
<p>​ 此种情况，主要考虑数据写入和缓存刷新的时效性。比如多久内刷新缓存，不影响用户对数据的访问。</p>
<h3 id="7-2-解决方法"><a href="#7-2-解决方法" class="headerlink" title="7.2. 解决方法"></a>7.2. 解决方法</h3><p>第一个场景：</p>
<p>这个写缓存的方式，本身就是错误的，需要改为先写持久化介质，再写缓存的方式。</p>
<p>第二个场景：</p>
<p>（1）根据写入缓存的响应来进行判断，如果缓存写入失败，则回滚数据库操作；此种方法增加了程序的复杂度，不建议采用；</p>
<p>（2）缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现。</p>
<p>第三个场景：</p>
<p>（1）首先确定，哪些数据适合此类场景；</p>
<p>（2）根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔；</p>
<h3 id="7-3-其他方法"><a href="#7-3-其他方法" class="headerlink" title="7.3. 其他方法"></a>7.3. 其他方法</h3><ul>
<li>超时：设置合理的超时时间；</li>
<li>刷新：定时刷新一定范围内（根据时间，版本号）的数据；</li>
</ul>
<p>​ 以上是简化数据读写场景，实际中会分为：</p>
<ul>
<li>缓存与数据库之间的一致性；</li>
<li>多级缓存之间的一致性；</li>
<li>缓存副本之间的一致性。</li>
</ul>
<h2 id="8-缓存高可用"><a href="#8-缓存高可用" class="headerlink" title="8. 缓存高可用"></a>8. 缓存高可用</h2><p>业界有两种理论，第一套缓存就是缓存，临时存储数据的，不需要高可用。第二种缓存逐步演化为重要的存储介质，需要做高可用。</p>
<p>本人的看法是，缓存是否高可用，需要根据实际的场景而定。临界点是：是否对后端的数据库造成影响。</p>
<p>具体的决策依据需要根据，集群的规模（数据，缓存），成本（服务器，运维），系统性能（并发量，吞吐量，响应时间）等方面综合评价。</p>
<h3 id="8-1-解决方法"><a href="#8-1-解决方法" class="headerlink" title="8.1. 解决方法"></a>8.1. 解决方法</h3><p>​ 缓存的高可用，一般通过分布式和复制实现。分布式实现数据的海量缓存，复制实现缓存数据节点的高可用。架构图如下：</p>
<p><br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110556336-2133732642.jpg"></div><br></p>
<p>​ 其中，分布式采用一致性 Hash 算法，复制采用异步复制。</p>
<h3 id="8-2-其他方法"><a href="#8-2-其他方法" class="headerlink" title="8.2. 其他方法"></a>8.2. 其他方法</h3><ol>
<li>复制双写：缓存节点的复制，由异步改为双写，只有两份都写成功，才算成功。</li>
<li>虚拟层：一致性 Hash 存在，假如其中一个 HASH 环不可用，数据会写入临近的环，当 HASH 可用时，数据又写入正常的 HASH 环，会导致数据偏移问题。这种情况，可以考虑在 HASH 环前面加一个虚拟层实现。</li>
<li>多级缓存：比如一级使用本地缓存，二级采用分布式 Cahce，三级采用分布式 Cache+本地持久化；</li>
</ol>
<p>​ 方式很多，需要根据业务场景灵活选择。</p>
<h2 id="9-缓存问题"><a href="#9-缓存问题" class="headerlink" title="9. 缓存问题"></a>9. 缓存问题</h2><h3 id="9-1-缓存雪崩"><a href="#9-1-缓存雪崩" class="headerlink" title="9.1. 缓存雪崩"></a>9.1. 缓存雪崩</h3><p>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>解决方案：</p>
<ol>
<li>合理规划缓存的失效时间；</li>
<li>合理评估数据库的负载压力；</li>
<li>对数据库进行过载保护或应用层限流；</li>
<li>多级缓存设计，缓存高可用；</li>
</ol>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<h3 id="9-2-缓存穿透"><a href="#9-2-缓存穿透" class="headerlink" title="9.2. 缓存穿透"></a>9.2. 缓存穿透</h3><p>​ 缓存一般是 Key，value 方式存在，当某一个 Key 不存在时会查询数据库，假如这个 Key，一直不存在，则会频繁的请求数据库，对数据库造成访问压力。</p>
<p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p>
<p>解决方法：</p>
<ol>
<li>对结果为空的数据也进行缓存，当此 key 有数据后，清理缓存；</li>
<li>一定不存在的 key，采用布隆过滤器，建立一个大的 Bitmap 中，查询时通过该 bitmap 过滤；</li>
</ol>
<h3 id="9-3-缓存预热"><a href="#9-3-缓存预热" class="headerlink" title="9.3. 缓存预热"></a>9.3. 缓存预热</h3><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="9-4-缓存更新"><a href="#9-4-缓存更新" class="headerlink" title="9.4. 缓存更新"></a>9.4. 缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="9-5-缓存降级"><a href="#9-5-缓存降级" class="headerlink" title="9.5. 缓存降级"></a>9.5. 缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/02/programming/java/javaweb/standalone/mvc/spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/02/programming/java/javaweb/standalone/mvc/spring/" itemprop="url">Spring面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T00:00:00+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javaweb/" itemprop="url" rel="index">
                    <span itemprop="name">javaweb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-面试题"><a href="#Spring-面试题" class="headerlink" title="Spring 面试题"></a>Spring 面试题</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#ioc">IoC</a><ul>
<li><a href="#什么是控制反转ioc什么是依赖注入">什么是控制反转(IoC)？什么是依赖注入？</a></li>
<li><a href="#spring-中的-ioc">Spring 中的 IoC</a></li>
<li><a href="#beanfactory-和-applicationcontext-有什么区别">BeanFactory 和 ApplicationContext 有什么区别？</a></li>
<li><a href="#spring-有几种配置方式">Spring 有几种配置方式</a></li>
<li><a href="#spring-bean-的生命周期">Spring Bean 的生命周期</a></li>
<li><a href="#spring-bean-的作用域">Spring Bean 的作用域</a></li>
<li><a href="#spring-框架中的单例-beans-是线程安全的么">Spring 框架中的单例 Beans 是线程安全的么？</a></li>
<li><a href="#spring-中注入一个-java-collection">Spring 中注入一个 Java Collection？</a></li>
<li><a href="#自动装配模式">自动装配模式</a></li>
</ul>
</li>
<li><a href="#aop">AOP</a><ul>
<li><a href="#什么是-aop">什么是 AOP</a></li>
<li><a href="#aop-的原理">AOP 的原理</a></li>
<li><a href="#动态代理">动态代理</a></li>
<li><a href="#静态代理">静态代理</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="什么是控制反转-IoC-？什么是依赖注入？"><a href="#什么是控制反转-IoC-？什么是依赖注入？" class="headerlink" title="什么是控制反转(IoC)？什么是依赖注入？"></a>什么是控制反转(IoC)？什么是依赖注入？</h3><p>IoC，是 Inversion of Control 的缩写，即控制反转。</p>
<ul>
<li>上层模块不应该依赖于下层模块，它们共同依赖于一个抽象</li>
<li>抽象不能依赖于具体实现，具体实现依赖于抽象。</li>
</ul>
<p>注：又称为依赖倒置原则。这是设计模式六大原则之一。</p>
<p>DI，是 Dependency Injection 的缩写，即依赖注入。</p>
<ul>
<li>依赖注入是 IoC 的最常见形式。</li>
<li>容器全权负责的组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造函数传递给需要的对象。</li>
</ul>
<p>依赖注入三种形式：</p>
<ol>
<li>构造器注入</li>
<li>Setter 方法注入</li>
<li>接口注入</li>
</ol>
<h3 id="Spring-中的-IoC"><a href="#Spring-中的-IoC" class="headerlink" title="Spring 中的 IoC"></a>Spring 中的 IoC</h3><p>BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。</p>
<p>BeanFactory 接口是 Spring IoC 容器的核心接口。</p>
<p>IOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。</p>
<h3 id="BeanFactory-和-ApplicationContext-有什么区别？"><a href="#BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext 有什么区别？"></a>BeanFactory 和 ApplicationContext 有什么区别？</h3><p>BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。</p>
<p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。</p>
<p>BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p>
<p>ApplicationContext 扩展了 BeanFactory：</p>
<ol>
<li>提供了支持国际化的文本消息</li>
<li>统一的资源文件读取方式</li>
<li>已在监听器中注册的 bean 的事件</li>
</ol>
<p>三种较常见的 ApplicationContext 实现：</p>
<ol>
<li>ClassPathXmlApplicationContext - 从 classpath 的 XML 配置文件中读取上下文。</li>
<li>FileSystemXmlApplicationContext - 由文件系统中的 XML 配置文件读取上下文。</li>
<li>XmlWebApplicationContext - 由 Web 应用的 XML 文件读取上下文。</li>
</ol>
<h3 id="Spring-有几种配置方式"><a href="#Spring-有几种配置方式" class="headerlink" title="Spring 有几种配置方式"></a>Spring 有几种配置方式</h3><ol>
<li>基于 XML 的配置</li>
<li>基于注解的配置</li>
<li>基于 Java 的配置</li>
</ol>
<h4 id="xml-配置方式"><a href="#xml-配置方式" class="headerlink" title="xml 配置方式"></a>xml 配置方式</h4><p>在 <code>&lt;beans&gt;</code> 元素下指定 schema 命令空间，如：context、beans、jdbc、tx、aop、mvc 等。</p>
<p>然后声明 bean 或命名空间下提供的能力。</p>
<h4 id="Java-配置方式"><a href="#Java-配置方式" class="headerlink" title="Java 配置方式"></a>Java 配置方式</h4><p>使用 @Configuration</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 AnnotationConfigApplicationContext 类进行实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);  </span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);  </span><br><span class="line">    myService.doStuff();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注解方式配置"><a href="#注解方式配置" class="headerlink" title="注解方式配置"></a>注解方式配置</h4><p>开启注解扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- bean definitions go here --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入 JavaBean 的注解</p>
<ul>
<li>@Required - 该注解应用于设值方法。</li>
<li>@Autowired - 该注解应用于有值设值方法、非设值方法、构造方法和变量。</li>
<li>@Qualifier - 该注解和@Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。</li>
<li>JSR-250 Annotations - Spring 支持基于 JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy</li>
</ul>
<h3 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h3><p>BeanFactory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。</p>
<ol>
<li>初始化之后调用的回调方法。</li>
<li>销毁之前调用的回调方法。</li>
</ol>
<p>Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：</p>
<ol>
<li>InitializingBean 和 DisposableBean 回调接口</li>
<li>针对特殊行为的其他 Aware 接口</li>
<li>Bean 配置文件中的 Custom init()方法和 destroy()方法</li>
<li>@PostConstruct 和@PreDestroy 注解方式</li>
</ol>
<h3 id="Spring-Bean-的作用域"><a href="#Spring-Bean-的作用域" class="headerlink" title="Spring Bean 的作用域"></a>Spring Bean 的作用域</h3><ul>
<li>singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，单例的模式由 bean factory 自身来维护。</li>
<li>prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。</li>
<li>request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。</li>
<li>Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。</li>
<li>global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。</li>
</ul>
<h3 id="Spring-框架中的单例-Beans-是线程安全的么？"><a href="#Spring-框架中的单例-Beans-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Beans 是线程安全的么？"></a>Spring 框架中的单例 Beans 是线程安全的么？</h3><p>Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。</p>
<p>最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。</p>
<h3 id="Spring-中注入一个-Java-Collection？"><a href="#Spring-中注入一个-Java-Collection？" class="headerlink" title="Spring 中注入一个 Java Collection？"></a>Spring 中注入一个 Java Collection？</h3><p>Spring 提供了以下四种集合类的配置元素：</p>
<ol>
<li><code>&lt;list&gt;</code> - 该标签用来装配可重复的 list 值。</li>
<li><code>&lt;set&gt;</code> - 该标签用来装配没有重复的 set 值。</li>
<li><code>&lt;map&gt;</code> - 该标签可用来注入键和值可以为任何类型的键值对。</li>
<li><code>&lt;props&gt;</code> - 该标签支持注入键和值都是字符串类型的键值对。</li>
</ol>
<h3 id="自动装配模式"><a href="#自动装配模式" class="headerlink" title="自动装配模式"></a>自动装配模式</h3><ul>
<li>no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean 定义中用标签明确的设置依赖关系。</li>
<li>byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li>
<li>byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li>
<li>constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的 bean，如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。</li>
<li>autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byTpe 的自动装配方式。</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p>AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。</p>
<p>Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如 Avanade 公司的高级方案构架师 Adam Magee 所说，AOP 的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<h3 id="AOP-的原理"><a href="#AOP-的原理" class="headerlink" title="AOP 的原理"></a>AOP 的原理</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ol>
<li>采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>
</ol>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>需要实现 InvocationHandler 接口。</p>
<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I want wo sell this house"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IPerson iPerson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(PersonProxy.class);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iPerson = iPerson;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Before Proxy"</span>);</span><br><span class="line">        iPerson.doSomething();</span><br><span class="line">        logger.info(<span class="string">"After Proxy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonProxy personProxy = <span class="keyword">new</span> PersonProxy(<span class="keyword">new</span> Person());</span><br><span class="line">        personProxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/01/programming/java/javacore/io/Java常用IO类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/01/programming/java/javacore/io/Java常用IO类/" itemprop="url">Java 常用 IO 类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javacore/" itemprop="url" rel="index">
                    <span itemprop="name">javacore</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-常用-IO-类"><a href="#Java-常用-IO-类" class="headerlink" title="Java 常用 IO 类"></a>Java 常用 IO 类</h1><blockquote>
<p>关键词：<code>File</code>、<code>RandomAccessFile</code>、<code>System</code>、<code>Scanner</code></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#1-file">1. File</a></li>
<li><a href="#2-randomaccessfile">2. RandomAccessFile</a></li>
<li><a href="#3-system">3. System</a></li>
<li><a href="#4-scanner">4. Scanner</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-File"><a href="#1-File" class="headerlink" title="1. File"></a>1. File</h2><p><code>File</code> 类是 <code>java.io</code> 包中唯一对文件本身进行操作的类。它可以对文件、目录进行增删查操作。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="createNewFille"><a href="#createNewFille" class="headerlink" title="createNewFille"></a>createNewFille</h4><p>可以使用 <code>createNewFille()</code> 方法创建一个新文件。</p>
<p>注：</p>
<p>Windows 中使用反斜杠表示目录的分隔符 <code>\</code>。</p>
<p>Linux 中使用正斜杠表示目录的分隔符 <code>/</code>。</p>
<p>最好的做法是使用 <code>File.separator</code> 静态常量，可以根据所在操作系统选取对应的分隔符。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(filename);</span><br><span class="line"><span class="keyword">boolean</span> flag = f.createNewFile();</span><br></pre></td></tr></table></figure>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>可以使用 <code>mkdir()</code> 来创建文件夹，但是如果要创建的目录的父路径不存在，则无法创建成功。</p>
<p>如果要解决这个问题，可以使用 <code>mkdirs()</code>，当父路径不存在时，会连同上级目录都一并创建。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(filename);</span><br><span class="line"><span class="keyword">boolean</span> flag = f.mkdir();</span><br></pre></td></tr></table></figure>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>可以使用 <code>delete()</code> 来删除文件或目录。</p>
<p>需要注意的是，如果删除的是目录，且目录不为空，直接用 <code>delete()</code> 删除会失败。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(filename);</span><br><span class="line"><span class="keyword">boolean</span> flag = f.delete();</span><br></pre></td></tr></table></figure>
<h4 id="list-和-listFiles"><a href="#list-和-listFiles" class="headerlink" title="list 和 listFiles"></a>list 和 listFiles</h4><p><code>File</code> 中给出了两种列出文件夹内容的方法：</p>
<ul>
<li><code>list()</code>: 列出全部名称，返回一个字符串数组。</li>
<li><code>listFiles()</code>: 列出完整的路径，返回一个 File 对象数组。</li>
</ul>
<p><code>list()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(filename);</span><br><span class="line">String str[] = f.list();</span><br></pre></td></tr></table></figure>
<p><code>listFiles()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(filename);</span><br><span class="line">File files[] = f.listFiles();</span><br></pre></td></tr></table></figure>
<h2 id="2-RandomAccessFile"><a href="#2-RandomAccessFile" class="headerlink" title="2. RandomAccessFile"></a>2. RandomAccessFile</h2><blockquote>
<p>注：<code>RandomAccessFile</code> 类虽然可以实现对文件内容的读写操作，但是比较复杂。所以一般操作文件内容往往会使用字节流或字符流方式。</p>
</blockquote>
<p><code>RandomAccessFile</code> 类是随机读取类，它是一个完全独立的类。</p>
<p>它适用于由大小已知的记录组成的文件，所以我们可以使用 <code>seek()</code> 将记录从一处转移到另一处，然后读取或者修改记录。</p>
<p>文件中记录的大小不一定都相同，只要能够确定哪些记录有多大以及它们在文件中的位置即可。</p>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>当用 <code>rw</code> 方式声明 <code>RandomAccessFile</code> 对象时，如果要写入的文件不存在，系统将自行创建。</p>
<p><code>r</code> 为只读；<code>w</code> 为只写；<code>rw</code> 为读写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>); <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        RandomAccessFile rdf = <span class="keyword">null</span>; <span class="comment">// 声明RandomAccessFile类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> RandomAccessFile(f, <span class="string">"rw"</span>);<span class="comment">// 读写模式，如果文件不存在，会自动创建</span></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        name = <span class="string">"zhangsan"</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">30</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">"lisi    "</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">31</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">"wangwu  "</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">32</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        rdf.close(); <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>读取是直接使用 <code>r</code> 的模式即可，以只读的方式打开文件。</p>
<p>读取时所有的字符串只能按照 byte 数组方式读取出来，而且长度必须和写入时的固定大小相匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);    <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        RandomAccessFile rdf = <span class="keyword">null</span>;        <span class="comment">// 声明RandomAccessFile类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> RandomAccessFile(f, <span class="string">"r"</span>);<span class="comment">// 以只读的方式打开文件</span></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];    <span class="comment">// 开辟byte数组</span></span><br><span class="line">        <span class="comment">// 读取第二个人的信息，意味着要空出第一个人的信息</span></span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);        <span class="comment">// 跳过第一个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> String(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">"第二个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age);</span><br><span class="line">        <span class="comment">// 读取第一个人的信息</span></span><br><span class="line">        rdf.seek(<span class="number">0</span>);    <span class="comment">// 指针回到文件的开头</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> String(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">"第一个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age);</span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);    <span class="comment">// 空出第二个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> String(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">"第三个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age);</span><br><span class="line">        rdf.close();                <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-System"><a href="#3-System" class="headerlink" title="3. System"></a>3. System</h2><p>System 中提供了三个常用于 IO 的静态成员：</p>
<ul>
<li>System.out</li>
<li>System.err</li>
<li>System.in</li>
</ul>
<p>示例：重定向 System.out 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemOutDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\test.txt"</span>);</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">"人生若只如初见，何事秋风悲画扇"</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：重定向 System.err 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemErrDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();        <span class="comment">// 实例化</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(bos);        <span class="comment">// 实例化</span></span><br><span class="line">        System.setErr(ps);    <span class="comment">// 输出重定向</span></span><br><span class="line">        System.err.print(<span class="string">"此处有误"</span>);</span><br><span class="line">        System.out.println(bos);    <span class="comment">// 输出内存中的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：接受控制台输入信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemInDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream input = System.in;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.print(<span class="string">"请输入内容："</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) temp;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输入的内容为："</span> + buf);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Scanner"><a href="#4-Scanner" class="headerlink" title="4. Scanner"></a>4. Scanner</h2><p>Scanner 可以完成输入数据操作，并对数据进行验证。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);    <span class="comment">// 从键盘接收数据</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">        System.out.print(<span class="string">"输入整数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextInt()) &#123;    <span class="comment">// 判断输入的是否是整数</span></span><br><span class="line">            i = scan.nextInt();    <span class="comment">// 接收整数</span></span><br><span class="line">            System.out.println(<span class="string">"整数数据："</span> + i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是整数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输入小数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat()) &#123;    <span class="comment">// 判断输入的是否是小数</span></span><br><span class="line">            f = scan.nextFloat();    <span class="comment">// 接收小数</span></span><br><span class="line">            System.out.println(<span class="string">"小数数据："</span> + f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是小数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.print(<span class="string">"输入日期（yyyy-MM-dd）："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext(<span class="string">"^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$"</span>)) &#123;    <span class="comment">// 判断</span></span><br><span class="line">            str = scan.next(<span class="string">"^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$"</span>);    <span class="comment">// 接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                date = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).parse(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的日期格式错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/01/programming/java/javacore/io/Java流操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/01/programming/java/javacore/io/Java流操作/" itemprop="url">Java 流操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javacore/" itemprop="url" rel="index">
                    <span itemprop="name">javacore</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-流操作"><a href="#Java-流操作" class="headerlink" title="Java 流操作"></a>Java 流操作</h1><blockquote>
<p>关键词：<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#1-字符流和字节流">1. 字符流和字节流</a></li>
<li><a href="#2-filereader-和-filewriter">2. FileReader 和 FileWriter</a></li>
<li><a href="#3-inputstreamreader-和-outputstreamwriter">3. InputStreamReader 和 OutputStreamWriter</a></li>
<li><a href="#4-bufferedreader">4. BufferedReader</a></li>
<li><a href="#5-printstream">5. PrintStream</a></li>
<li><a href="#6-fileinputstream-和-fileoutputstream">6. FileInputStream 和 FileOutputStream</a></li>
<li><a href="#7-bytearrayinputstream-和-bytearrayoutputstream">7. ByteArrayInputStream 和 ByteArrayOutputStream</a></li>
<li><a href="#8-pipedinputstream-和-pipedoutputstream">8. PipedInputStream 和 PipedOutputStream</a></li>
<li><a href="#9-datainputstream-和-dataoutputstream">9. DataInputStream 和 DataOutputStream</a></li>
<li><a href="#10-zipinputstream-和-zipoutputstream">10. ZipInputStream 和 ZipOutputStream</a></li>
<li><a href="#11-objectinputstream-和-objectoutputstream">11. ObjectInputStream 和 ObjectOutputStream</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-字符流和字节流"><a href="#1-字符流和字节流" class="headerlink" title="1. 字符流和字节流"></a>1. 字符流和字节流</h2><p>JAVA IO 中的流操作分为两类：</p>
<ul>
<li><strong>字节流主要操作字节类型数据（byte）。主要类是 <code>InputStream</code>（输入） 和 <code>OutputStream</code>（输出）。</strong></li>
<li><strong>字符流主要操作字符类型数据，一个字符占两个字节。主要类是 <code>Reader</code>（输入） 和 <code>Writer</code>（输出）。</strong></li>
</ul>
<p>JAVA IO 中的流操作类，常常是以输入、输出两种形式成对提供。</p>
<p>在 JAVA IO 中，流操作的一般流程如下：</p>
<ol>
<li>使用 File 类绑定一个文件。</li>
<li>把 File 对象绑定到流对象上。</li>
<li>进行读或写操作。</li>
<li>关闭流</li>
</ol>
<h3 id="字符流和字节流的区别"><a href="#字符流和字节流的区别" class="headerlink" title="字符流和字节流的区别"></a>字符流和字节流的区别</h3><ul>
<li>字节流主要操作字节类型数据（byte）；字符流主要操作字符类型数据，一个字符占两个字节。</li>
<li>字节流在操作时本身不会用到缓冲区（内存），而是对文件本身直接操作的；字符流在操作时使用了缓冲区，通过缓冲区再操作文件。</li>
</ul>
<h2 id="2-FileReader-和-FileWriter"><a href="#2-FileReader-和-FileWriter" class="headerlink" title="2. FileReader 和 FileWriter"></a>2. FileReader 和 FileWriter</h2><p><strong>FileReader 和 FileWriter 用于输入输出文本文件。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderAndWriterDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        Writer out = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">        <span class="comment">// Writer out = new FileWriter(f, true); // 追加内容方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        String str = <span class="string">"Hello World!!!\r\n"</span>;</span><br><span class="line">        out.write(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        <span class="comment">// 字符流操作时使用了缓冲区，并在关闭字符流时会强制将缓冲区内容输出</span></span><br><span class="line">        <span class="comment">// 如果不关闭流，则缓冲区的内容是无法输出的</span></span><br><span class="line">        <span class="comment">// 如果想在不关闭流时，将缓冲区内容输出，可以使用 flush 强制清空缓冲区</span></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] input(String filepath) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        Reader input = <span class="keyword">new</span> FileReader(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 接收每一个内容</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 读取内容</span></span><br><span class="line">        <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不是-1就表示还有内容，可以继续读取</span></span><br><span class="line">            c[len] = (<span class="keyword">char</span>) temp;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件字符数为："</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        input.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String filepath = <span class="string">"d:\\test.txt"</span>;</span><br><span class="line"></span><br><span class="line">        output(filepath);</span><br><span class="line">        System.out.println(<span class="string">"内容为："</span> + <span class="keyword">new</span> String(input(filepath)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-InputStreamReader-和-OutputStreamWriter"><a href="#3-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="3. InputStreamReader 和 OutputStreamWriter"></a>3. InputStreamReader 和 OutputStreamWriter</h2><p><strong>InputStreamReader 和 OutputStreamWriter 可以将 InputStream 和 OutputStream 分别转换为 Reader 和 Writer。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        Writer out = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(f));</span><br><span class="line">        out.write(<span class="string">"hello world!!"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(f));</span><br><span class="line">        <span class="keyword">char</span> c[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = reader.read(c);</span><br><span class="line">        reader.close();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(c, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-BufferedReader"><a href="#4-BufferedReader" class="headerlink" title="4. BufferedReader"></a>4. BufferedReader</h2><p>BufferedReader 类用于从缓冲区中读取内容，所有的输入字节数据都放在缓冲区中。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader buf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"请输入内容："</span>);</span><br><span class="line">            String str = buf.readLine();</span><br><span class="line">            <span class="keyword">if</span> (str.equalsIgnoreCase(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">                System.out.print(<span class="string">"退出"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"输入的内容为："</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-PrintStream"><a href="#5-PrintStream" class="headerlink" title="5. PrintStream"></a>5. PrintStream</h2><p>PrintStream 提供了非常方便的打印功能。</p>
<p>事实上，我们常用的 System 中提供的静态成员 System.out 和 System.err 就是 PrintStream 对象。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String filepath = <span class="string">"d:\\test.txt"</span>;</span><br><span class="line">        <span class="comment">// 如果现在是使用 FileOuputStream 实例化，意味着所有的数据都会输出到文件中</span></span><br><span class="line">        OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filepath));</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        ps.print(<span class="string">"Hello "</span>);</span><br><span class="line">        ps.println(<span class="string">"World!!!"</span>);</span><br><span class="line">        ps.printf(<span class="string">"姓名：%s；年龄：%d"</span>, <span class="string">"张三"</span>, <span class="number">18</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-FileInputStream-和-FileOutputStream"><a href="#6-FileInputStream-和-FileOutputStream" class="headerlink" title="6. FileInputStream 和 FileOutputStream"></a>6. FileInputStream 和 FileOutputStream</h2><p><strong>FileInputStream 和 FileOutputStream 用于输入、输出文件。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILEPATH = <span class="string">"d:\\test.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象</span></span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        <span class="comment">// 实例化时，默认为覆盖原文件内容方式；如果添加true参数，则变为对原文件追加内容的方式。</span></span><br><span class="line">        <span class="comment">// OutputStream out = new FileOutputStream(f, true);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行写操作</span></span><br><span class="line">        String str = <span class="string">"Hello World\r\n"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        out.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象</span></span><br><span class="line">        InputStream input = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行读操作</span></span><br><span class="line">        <span class="comment">// 有三种读取方式，体会其差异</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">        <span class="keyword">int</span> len = input.read(bytes); <span class="comment">// 读取内容</span></span><br><span class="line">        System.out.println(<span class="string">"读入数据的长度："</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输入流</span></span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(<span class="string">"内容为：\n"</span> + <span class="keyword">new</span> String(bytes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        output(FILEPATH);</span><br><span class="line">        input(FILEPATH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-ByteArrayInputStream-和-ByteArrayOutputStream"><a href="#7-ByteArrayInputStream-和-ByteArrayOutputStream" class="headerlink" title="7. ByteArrayInputStream 和 ByteArrayOutputStream"></a>7. ByteArrayInputStream 和 ByteArrayOutputStream</h2><p><strong>ByteArrayInputStream 和 ByteArrayOutputStream 用于在内存中输入、输出数据。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayStreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"HELLOWORLD"</span>; <span class="comment">// 定义一个字符串，全部由大写字母组成</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// 准备从内存ByteArrayInputStream中读取内容</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) temp;    <span class="comment">// 读取的数字变为字符</span></span><br><span class="line">            bos.write(Character.toLowerCase(c));    <span class="comment">// 将字符变为小写</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有的数据就全部都在ByteArrayOutputStream中</span></span><br><span class="line">        String newStr = bos.toString();    <span class="comment">// 取出内容</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(newStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-PipedInputStream-和-PipedOutputStream"><a href="#8-PipedInputStream-和-PipedOutputStream" class="headerlink" title="8. PipedInputStream 和 PipedOutputStream"></a>8. PipedInputStream 和 PipedOutputStream</h2><p><strong>PipedInputStream 和 PipedOutputStream 可以在两个线程间进行通信。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> PipedOutputStream pos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Send() &#123;</span><br><span class="line">            pos = <span class="keyword">new</span> PipedOutputStream();    <span class="comment">// 实例化输出流</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String str = <span class="string">"Hello World!!!"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pos.write(str.getBytes());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 得到此线程的管道输出流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">PipedOutputStream <span class="title">getPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Receive</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> PipedInputStream pis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Receive() &#123;</span><br><span class="line">            pis = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                len = pis.read(b);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"接收的内容为："</span> + <span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 得到此线程的管道输入流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">PipedInputStream <span class="title">getPis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Send s = <span class="keyword">new</span> Send();</span><br><span class="line">        Receive r = <span class="keyword">new</span> Receive();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.getPos().connect(r.getPis());    <span class="comment">// 连接管道</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(s).start();    <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();    <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-DataInputStream-和-DataOutputStream"><a href="#9-DataInputStream-和-DataOutputStream" class="headerlink" title="9. DataInputStream 和 DataOutputStream"></a>9. DataInputStream 和 DataOutputStream</h2><p>DataInputStream 和 DataOutputStream 会一定格式将数据输入、输出。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataStreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILEPATH = <span class="string">"d:\\order.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(f));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        String names[] = &#123;<span class="string">"衬衣"</span>, <span class="string">"手套"</span>, <span class="string">"围巾"</span>&#125;;</span><br><span class="line">        <span class="keyword">float</span> prices[] = &#123;<span class="number">98.3f</span>, <span class="number">30.3f</span>, <span class="number">50.5f</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            dos.writeChars(names[i]);</span><br><span class="line">            dos.writeChar(<span class="string">'\t'</span>);</span><br><span class="line">            dos.writeFloat(prices[i]);</span><br><span class="line">            dos.writeChar(<span class="string">'\t'</span>);</span><br><span class="line">            dos.writeInt(nums[i]);</span><br><span class="line">            dos.writeChar(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(f));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        String name = <span class="keyword">null</span>;    <span class="comment">// 接收名称</span></span><br><span class="line">        <span class="keyword">float</span> price = <span class="number">0.0f</span>;    <span class="comment">// 接收价格</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;    <span class="comment">// 接收数量</span></span><br><span class="line">        <span class="keyword">char</span> temp[] = <span class="keyword">null</span>;    <span class="comment">// 接收商品名称</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;    <span class="comment">// 保存读取数据的个数</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0</span>;    <span class="comment">// '\u0000'</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">200</span>];    <span class="comment">// 开辟空间</span></span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((c = dis.readChar()) != <span class="string">'\t'</span>) &#123;    <span class="comment">// 接收内容</span></span><br><span class="line">                    temp[len] = c;</span><br><span class="line">                    len++;    <span class="comment">// 读取长度加1</span></span><br><span class="line">                &#125;</span><br><span class="line">                name = <span class="keyword">new</span> String(temp, <span class="number">0</span>, len);    <span class="comment">// 将字符数组变为String</span></span><br><span class="line">                price = dis.readFloat();    <span class="comment">// 读取价格</span></span><br><span class="line">                dis.readChar();    <span class="comment">// 读取\t</span></span><br><span class="line">                num = dis.readInt();    <span class="comment">// 读取int</span></span><br><span class="line">                dis.readChar();    <span class="comment">// 读取\n</span></span><br><span class="line">                System.out.printf(<span class="string">"名称：%s；价格：%5.2f；数量：%d\n"</span>, name, price, num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        dis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output(FILEPATH);</span><br><span class="line">        input(FILEPATH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-ZipInputStream-和-ZipOutputStream"><a href="#10-ZipInputStream-和-ZipOutputStream" class="headerlink" title="10. ZipInputStream 和 ZipOutputStream"></a>10. ZipInputStream 和 ZipOutputStream</h2><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipStreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_FILE_PATH = <span class="string">"d:\\zipdemo.zip"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">(String zipfilepath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(zipfilepath);</span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">        ZipEntry entry = zipFile.getEntry(<span class="string">"mldn.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"压缩文件的名称："</span> + zipFile.getName());</span><br><span class="line"></span><br><span class="line">        File outputFile = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"mldn_unzip.txt"</span>);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(outputFile); <span class="comment">// 实例化输出流</span></span><br><span class="line">        InputStream input = zipFile.getInputStream(entry);    <span class="comment">// 得到一个压缩实体的输入流</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();    <span class="comment">// 关闭输入流</span></span><br><span class="line">        out.close();    <span class="comment">// 关闭输出流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩一个文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output1</span><span class="params">(String filepath, String zipfilepath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        <span class="comment">// 定义要压缩的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(filepath);</span><br><span class="line">        <span class="comment">// 定义压缩文件名称</span></span><br><span class="line">        File zipFile = <span class="keyword">new</span> File(zipfilepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        InputStream input = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        ZipOutputStream zipOut = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        zipOut.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">        zipOut.setComment(<span class="string">"This is a zip file."</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;    <span class="comment">// 读取内容</span></span><br><span class="line">            zipOut.write(temp);    <span class="comment">// 压缩输出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        input.close();</span><br><span class="line">        zipOut.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取实体为一个文件的压缩包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input1</span><span class="params">(String zipfilepath, String filepath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File zipFile = <span class="keyword">new</span> File(zipfilepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        ZipInputStream input = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(zipFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        ZipEntry entry = input.getNextEntry();    <span class="comment">// 得到一个压缩实体</span></span><br><span class="line">        System.out.println(<span class="string">"压缩实体名称："</span> + entry.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩一个目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output2</span><span class="params">(String dirpath, String zipfilepath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        <span class="comment">// 定义要压缩的文件夹</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(dirpath);</span><br><span class="line">        <span class="comment">// 定义压缩文件名称</span></span><br><span class="line">        File zipFile = <span class="keyword">new</span> File(zipfilepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        ZipOutputStream zipOut = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFile));</span><br><span class="line">        zipOut.setComment(<span class="string">"This is zip folder."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;    <span class="comment">// 判断是否是文件夹</span></span><br><span class="line">            File lists[] = file.listFiles();    <span class="comment">// 列出全部文件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">                InputStream input = <span class="keyword">new</span> FileInputStream(lists[i]);</span><br><span class="line">                <span class="comment">// 设置ZipEntry对象</span></span><br><span class="line">                zipOut.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName() + File.separator + lists[i].getName()));</span><br><span class="line">                <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    zipOut.write(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                input.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        zipOut.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压实体为一个目录的压缩包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input2</span><span class="params">(String zipfilepath, String dirpath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(zipfilepath);</span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        ZipInputStream zis = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        ZipEntry entry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((entry = zis.getNextEntry()) != <span class="keyword">null</span>) &#123;    <span class="comment">// 得到一个压缩实体</span></span><br><span class="line">            System.out.println(<span class="string">"解压缩"</span> + entry.getName() + <span class="string">"文件。"</span>);</span><br><span class="line">            <span class="comment">// 定义输出的文件路径</span></span><br><span class="line">            File outFile = <span class="keyword">new</span> File(dirpath + File.separator + entry.getName());</span><br><span class="line">            <span class="keyword">if</span> (!outFile.getParentFile().exists()) &#123;    <span class="comment">// 如果输出文件夹不存在</span></span><br><span class="line">                outFile.getParentFile().mkdirs();    <span class="comment">// 创建文件夹</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!outFile.exists()) &#123;    <span class="comment">// 判断输出文件是否存在</span></span><br><span class="line">                outFile.createNewFile();    <span class="comment">// 创建文件</span></span><br><span class="line">            &#125;</span><br><span class="line">            InputStream input = zipFile.getInputStream(entry);    <span class="comment">// 得到每一个实体的输入流</span></span><br><span class="line">            OutputStream out = <span class="keyword">new</span> FileOutputStream(outFile);    <span class="comment">// 实例化文件输出流</span></span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            input.close();        <span class="comment">// 关闭输入流</span></span><br><span class="line">            out.close();    <span class="comment">// 关闭输出流</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        zis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String filepath = <span class="string">"d:\\demo.txt"</span>;</span><br><span class="line">        <span class="keyword">final</span> String zipfilepath = <span class="string">"d:\\demo.zip"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String dirpath = <span class="string">"d:\\demo2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String dirpath2 = <span class="string">"d:\\new"</span>;</span><br><span class="line">        <span class="keyword">final</span> String zipfilepath2 = <span class="string">"d:\\demo2.zip"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        demo01(ZIP_FILE_PATH);</span></span><br><span class="line">        output1(filepath, zipfilepath);</span><br><span class="line">        input1(zipfilepath, filepath);</span><br><span class="line"></span><br><span class="line">        output2(dirpath, zipfilepath2);</span><br><span class="line">        input2(zipfilepath2, dirpath2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-ObjectInputStream-和-ObjectOutputStream"><a href="#11-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="11. ObjectInputStream 和 ObjectOutputStream"></a>11. ObjectInputStream 和 ObjectOutputStream</h2><p><strong>ObjectInputStream 和 ObjectOutputStream 是对象输入输出流，一般用于对象序列化。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"；年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(String filepath, Object obj[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object[] readObject(String filepath) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.使用 File 类绑定一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把 File 对象绑定到流对象上</span></span><br><span class="line">        InputStream input = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行读或写操作</span></span><br><span class="line">        Object[] objects = (Object[]) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String filepath = <span class="string">"d:\\object.txt"</span>;</span><br><span class="line">        Person per[] = &#123;<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">31</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">32</span>)&#125;;</span><br><span class="line">        writeObject(filepath, per);</span><br><span class="line">        Object o[] = readObject(filepath);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; o.length; i++) &#123;</span><br><span class="line">            Person p = (Person) o[i];</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/06/29/programming/java/javacore/container/Queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/29/programming/java/javacore/container/Queue/" itemprop="url">Java 容器之 Queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T00:00:00+08:00">
                2018-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/javacore/" itemprop="url" rel="index">
                    <span itemprop="name">javacore</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-容器之-Queue"><a href="#Java-容器之-Queue" class="headerlink" title="Java 容器之 Queue"></a>Java 容器之 Queue</h1><!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#queue-架构">Queue 架构</a></li>
<li><a href="#queue-接口">Queue 接口</a></li>
<li><a href="#blockingqueue-接口">BlockingQueue 接口</a></li>
<li><a href="#abstractqueue-抽象类">AbstractQueue 抽象类</a></li>
<li><a href="#priorityqueue-类">PriorityQueue 类</a></li>
<li><a href="#priorityblockingqueue-类">PriorityBlockingQueue 类</a></li>
<li><a href="#linkedblockingqueue-类">LinkedBlockingQueue 类</a></li>
<li><a href="#arrayblockingqueue-类">ArrayBlockingQueue 类</a></li>
<li><a href="#synchronousqueue">SynchronousQueue</a></li>
<li><a href="#资料">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="Queue-架构"><a href="#Queue-架构" class="headerlink" title="Queue 架构"></a>Queue 架构</h2><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/container/Queue-diagrams.png"><br></div>

<h2 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h2><p>Queue 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BlockingQueue-接口"><a href="#BlockingQueue-接口" class="headerlink" title="BlockingQueue 接口"></a>BlockingQueue 接口</h2><p>BlockingQueue 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>BlockingQueue 顾名思义，是一个阻塞队列。</p>
<p>在 BlockingQueue 中，如果获取队列元素但是队列为空时，会阻塞，等待队列中有元素再返回；如果添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p>
<p>BlockingQueue 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：</p>
<ol>
<li>抛出异常；</li>
<li>返回特殊值（null 或 true/false，取决于具体的操作）；</li>
<li>阻塞等待此操作，直到这个操作成功；</li>
<li>阻塞等待此操作，直到成功或者超时指定时间。</li>
</ol>
<p>总结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th><em>Throws exception</em></th>
<th><em>Special value</em></th>
<th><em>Blocks</em></th>
<th><em>Times out</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td><em>not applicable</em></td>
<td><em>not applicable</em></td>
</tr>
</tbody>
</table>
<p>BlockingQueue 的各个实现类都遵循了这些规则。</p>
<p>BlockingQueue 不接受 null 值元素。</p>
<h2 id="AbstractQueue-抽象类"><a href="#AbstractQueue-抽象类" class="headerlink" title="AbstractQueue 抽象类"></a>AbstractQueue 抽象类</h2><p>AbstractQueue 抽象类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueue 类提供 Queue 接口的骨干实现，以最大限度地减少实现 Queue 接口所需的工作。</p>
<h2 id="PriorityQueue-类"><a href="#PriorityQueue-类" class="headerlink" title="PriorityQueue 类"></a>PriorityQueue 类</h2><p>PriorityQueue 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PriorityQueue-要点"><a href="#PriorityQueue-要点" class="headerlink" title="PriorityQueue 要点"></a>PriorityQueue 要点</h3><ol>
<li>PriorityQueue 实现了 Serializable，支持序列化。</li>
<li>PriorityQueue 类是基于优先级堆实现的无界优先级队列。</li>
<li>PriorityQueue 中的元素根据自然顺序或 Comparator 提供的顺序排序。</li>
<li>PriorityQueue 不接受 null 值元素。</li>
<li>PriorityQueue 不是线程安全的。</li>
</ol>
<h2 id="PriorityBlockingQueue-类"><a href="#PriorityBlockingQueue-类" class="headerlink" title="PriorityBlockingQueue 类"></a>PriorityBlockingQueue 类</h2><p>PriorityBlockingQueue 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PriorityBlockingQueue-要点"><a href="#PriorityBlockingQueue-要点" class="headerlink" title="PriorityBlockingQueue 要点"></a>PriorityBlockingQueue 要点</h3><ol>
<li>PriorityBlockingQueue 实现了 BlockingQueue，也是一个阻塞队列。</li>
<li>PriorityBlockingQueue 实现了 Serializable，支持序列化。</li>
<li>PriorityBlockingQueue 可以视为 PriorityQueue 的线程安全版本。</li>
<li>PriorityBlockingQueue 不接受 null 值元素。</li>
<li>PriorityBlockingQueue 的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</li>
</ol>
<h3 id="PriorityBlockingQueue-原理"><a href="#PriorityBlockingQueue-原理" class="headerlink" title="PriorityBlockingQueue 原理"></a>PriorityBlockingQueue 原理</h3><p>PriorityBlockingQueue 有两个重要成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br></pre></td></tr></table></figure>
<ul>
<li>queue 是一个 Object 数组，用于保存 PriorityBlockingQueue 的元素。</li>
<li>而可重入锁 lock 则用于在执行插入、删除操作时，保证这个方法在当前线程释放锁之前，其他线程不能访问。</li>
</ul>
<p>PriorityBlockingQueue 的容量虽然有初始化大小，但是不限制大小，如果当前容量已满，插入新元素时会自动扩容。</p>
<h2 id="LinkedBlockingQueue-类"><a href="#LinkedBlockingQueue-类" class="headerlink" title="LinkedBlockingQueue 类"></a>LinkedBlockingQueue 类</h2><p>LinkedBlockingQueue 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LinkedBlockingQueue-要点"><a href="#LinkedBlockingQueue-要点" class="headerlink" title="LinkedBlockingQueue 要点"></a>LinkedBlockingQueue 要点</h3><ol>
<li>LinkedBlockingQueue 实现了 BlockingQueue，也是一个阻塞队列。</li>
<li>LinkedBlockingQueue 实现了 Serializable，支持序列化。</li>
<li>LinkedBlockingQueue 是基于单链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。</li>
<li>LinkedBlockingQueue 中元素按照插入顺序保存（FIFO）。</li>
</ol>
<h3 id="LinkedBlockingQueue-原理"><a href="#LinkedBlockingQueue-原理" class="headerlink" title="LinkedBlockingQueue 原理"></a>LinkedBlockingQueue 原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take, poll, peek 等读操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果读操作的时候队列是空的，那么等待 notEmpty 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put, offer 等写操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果写操作的时候队列是满的，那么等待 notFull 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<p>这里用了两个锁，两个 Condition，简单介绍如下：</p>
<ul>
<li>takeLock 和 notEmpty 搭配：如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）。</li>
<li>putLock 需要和 notFull 搭配：如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）。</li>
</ul>
<h2 id="ArrayBlockingQueue-类"><a href="#ArrayBlockingQueue-类" class="headerlink" title="ArrayBlockingQueue 类"></a>ArrayBlockingQueue 类</h2><p>ArrayBlockingQueue 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayBlockingQueue-要点"><a href="#ArrayBlockingQueue-要点" class="headerlink" title="ArrayBlockingQueue 要点"></a>ArrayBlockingQueue 要点</h3><ol>
<li>ArrayBlockingQueue 实现了 BlockingQueue，也是一个阻塞队列。</li>
<li>ArrayBlockingQueue 实现了 Serializable，支持序列化。</li>
<li>ArrayBlockingQueue 是基于数组实现的无界阻塞队列。</li>
</ol>
<h3 id="ArrayBlockingQueue-原理"><a href="#ArrayBlockingQueue-原理" class="headerlink" title="ArrayBlockingQueue 原理"></a>ArrayBlockingQueue 原理</h3><p>ArrayBlockingQueue 的重要成员如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一次读取操作的位置</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一次写入操作的位置</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几个就是控制并发用的同步器</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>
<p>ArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。</p>
<ul>
<li>如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。</li>
<li>如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除，然后唤醒写线程队列的第一个等待线程。</li>
</ul>
<p>对于 ArrayBlockingQueue，我们可以在构造的时候指定以下三个参数：</p>
<ol>
<li>队列容量，其限制了队列中最多允许的元素个数；</li>
<li>指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；</li>
<li>可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。</li>
</ol>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue 定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>SynchronousQueue 这个类，不过它在线程池的实现类 ScheduledThreadPoolExecutor 中得到了应用。</li>
<li>SynchronousQueue 的队列其实是虚的，其不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。</li>
<li>SynchronousQueue 中不能使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 SynchronousQueue 的特征的。</li>
<li>SynchronousQueue 也不能被迭代，因为根本就没有元素可以拿来迭代的。</li>
<li>虽然 SynchronousQueue 间接地实现了 Collection 接口，但是如果你将其当做 Collection 来用的话，那么集合是空的。</li>
<li>当然，SynchronousQueue 也不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。</li>
</ol>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://www.importnew.com/28053.html" target="_blank" rel="noopener">解读 Java 并发队列 BlockingQueue</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/26/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/blog/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/28/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">381</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">76</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dunwu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:forbreak@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
