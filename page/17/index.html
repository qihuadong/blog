<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="张鹏的博客">
<meta property="og:url" content="http://yoursite.com/page/17/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张鹏的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/17/">





  <title>张鹏的博客 - 大道至简，知易行难</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/os/docker/basics/docker-container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/os/docker/basics/docker-container/" itemprop="url">Docker 容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#启动容器">启动容器</a><ul>
<li><a href="#新建并启动">新建并启动</a></li>
<li><a href="#启动已终止容器">启动已终止容器</a></li>
</ul>
</li>
<li><a href="#后台运行">后台运行</a></li>
<li><a href="#终止容器">终止容器</a></li>
<li><a href="#进入容器">进入容器</a><ul>
<li><a href="#attach-命令"><code>attach</code> 命令</a></li>
<li><a href="#exec-命令"><code>exec</code> 命令</a></li>
</ul>
</li>
<li><a href="#导出和导入容器">导出和导入容器</a><ul>
<li><a href="#导出容器">导出容器</a></li>
<li><a href="#导入容器快照">导入容器快照</a></li>
</ul>
</li>
<li><a href="#删除容器">删除容器</a></li>
<li><a href="#清理所有处于终止状态的容器">清理所有处于终止状态的容器</a></li>
</ul>
<!-- /TOC -->
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>-t</code> 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/<span class="comment"># ls</span></span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:/<span class="comment"># ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   11 ?        00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure>
<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &apos;while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></pre></td></tr></table></figure>
<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:14.04             <span class="string">"/bin/bash"</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   <span class="string">"python app.py"</span>        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure>
<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h3><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">$ docker attach 243c</span><br><span class="line">root@243c32535da7:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h3><h4 id="i-t-参数"><a href="#i-t-参数" class="headerlink" title="-i -t 参数"></a>-i -t 参数</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p>
<h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:14.04        <span class="string">"/bin/bash"</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>这样将导出容器快照到本地文件。</p>
<h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p><em>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm  trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>
<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<h2 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h2><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/programming/java/javacore/concurrent/Java并发面试题集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/programming/java/javacore/concurrent/Java并发面试题集/" itemprop="url">Java 并发面试题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-并发面试题总结"><a href="#Java-并发面试题总结" class="headerlink" title="Java 并发面试题总结"></a>Java 并发面试题总结</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-并发简介">1. 并发简介</a><ul>
<li><a href="#11-什么是进程什么是线程进程和线程的区别">1.1. 什么是进程？什么是线程？进程和线程的区别？</a></li>
<li><a href="#12-多线程编程的好处是什么">1.2. 多线程编程的好处是什么？</a></li>
<li><a href="#13-如何让正在运行的线程暂停一段时间">1.3. 如何让正在运行的线程暂停一段时间？</a></li>
<li><a href="#14-什么是线程调度器thread-scheduler和时间分片time-slicing">1.4. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</a></li>
<li><a href="#15-在多线程中什么是上下文切换context-switching">1.5. 在多线程中，什么是上下文切换(context-switching)？</a></li>
<li><a href="#16-如何确保线程安全">1.6. 如何确保线程安全？</a></li>
<li><a href="#17-什么是死锁deadlock如何分析和避免死锁">1.7. 什么是死锁(Deadlock)？如何分析和避免死锁？</a></li>
</ul>
</li>
<li><a href="#2-线程基础">2. 线程基础</a><ul>
<li><a href="#21-java-线程生命周期中有哪些状态各状态之间如何切换">2.1. Java 线程生命周期中有哪些状态？各状态之间如何切换？</a></li>
<li><a href="#22-创建线程有哪些方式这些方法各自利弊是什么">2.2. 创建线程有哪些方式？这些方法各自利弊是什么？</a></li>
<li><a href="#23-什么是-callable-和-future什么是-futuretask">2.3. 什么是 <code>Callable</code> 和 <code>Future</code>？什么是 <code>FutureTask</code>？</a></li>
<li><a href="#24-start-和-run-有什么区别可以直接调用-thread-类的-run-方法么">2.4. <code>start()</code> 和 <code>run()</code> 有什么区别？可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法么？</a></li>
<li><a href="#25-sleepyieldjoin-方法有什么区别为什么-sleep-和-yield-方法是静态static的">2.5. <code>sleep()</code>、<code>yield()</code>、<code>join()</code> 方法有什么区别？为什么 <code>sleep()</code> 和 <code>yield()</code> 方法是静态（static）的？</a></li>
<li><a href="#26-java-的线程优先级如何控制高优先级的-java-线程一定先执行吗">2.6. Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？</a></li>
<li><a href="#27-什么是守护线程为什么要用守护线程如何创建守护线程">2.7. 什么是守护线程？为什么要用守护线程？如何创建守护线程？</a></li>
<li><a href="#28-线程间是如何通信的">2.8. 线程间是如何通信的？</a></li>
<li><a href="#29-为什么线程通信的方法-wait-notify-和-notifyall-被定义在-object-类里">2.9. 为什么线程通信的方法 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 被定义在 Object 类里？</a></li>
<li><a href="#210-为什么-wait-notify-和-notifyall-必须在同步方法或者同步块中被调用">2.10. 为什么 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 必须在同步方法或者同步块中被调用？</a></li>
</ul>
</li>
<li><a href="#3-并发机制的底层实现">3. 并发机制的底层实现</a><ul>
<li><a href="#31-volatile-有什么作用它的实现原理是什么">3.1. <code>volatile</code> 有什么作用？它的实现原理是什么？</a></li>
<li><a href="#32-synchronized-有什么作用它的实现原理是什么同步方法和同步块哪个更好">3.2. <code>synchronized</code> 有什么作用？它的实现原理是什么？同步方法和同步块，哪个更好？</a></li>
<li><a href="#33-volatile-和-synchronized-的区别">3.3. <code>volatile</code> 和 <code>synchronized</code> 的区别？</a></li>
<li><a href="#34-threadlocal-有什么作用threadlocal-的实现原理是什么">3.4. <code>ThreadLocal</code> 有什么作用？<code>ThreadLocal</code> 的实现原理是什么？</a></li>
</ul>
</li>
<li><a href="#4-内存模型">4. 内存模型</a><ul>
<li><a href="#41-什么是-java-内存模型">4.1. 什么是 Java 内存模型</a></li>
</ul>
</li>
<li><a href="#5-同步容器和并发容器">5. 同步容器和并发容器</a><ul>
<li><a href="#51-什么是同步容器有哪些常见同步容器它们是如何实现线程安全的同步容器真的线程安全吗">5.1. 什么是同步容器？有哪些常见同步容器？它们是如何实现线程安全的？同步容器真的线程安全吗？</a></li>
<li><a href="#52-什么是并发容器的实现">5.2. 什么是并发容器的实现？</a></li>
</ul>
</li>
<li><a href="#6-锁">6. 锁</a><ul>
<li><a href="#61-lock-接口lock-interface是什么对比同步它有什么优势">6.1. Lock 接口(Lock interface)是什么？对比同步它有什么优势？</a></li>
<li><a href="#62-什么是阻塞队列如何使用阻塞队列来实现生产者-消费者模型">6.2. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</a></li>
</ul>
</li>
<li><a href="#7-原子变量类">7. 原子变量类</a><ul>
<li><a href="#71-什么是原子操作有哪些原子类原子类的实现原理是什么">7.1. 什么是原子操作？有哪些原子类？原子类的实现原理是什么？</a></li>
</ul>
</li>
<li><a href="#8-并发工具类">8. 并发工具类</a><ul>
<li><a href="#81-cyclicbarrier-和-countdownlatch-有什么不同">8.1. CyclicBarrier 和 CountDownLatch 有什么不同？</a></li>
</ul>
</li>
<li><a href="#9-线程池">9. 线程池</a><ul>
<li><a href="#91-什么是线程池如何创建一个-java-线程池">9.1. 什么是线程池？如何创建一个 Java 线程池？</a></li>
<li><a href="#92-什么是-executors-框架">9.2. 什么是 Executors 框架？</a></li>
<li><a href="#93-executors-类是什么">9.3. Executors 类是什么？</a></li>
<li><a href="#threadpoolexecutor-有哪些参数各自有什么用">ThreadPoolExecutor 有哪些参数，各自有什么用？</a></li>
</ul>
</li>
<li><a href="#10-资料">10. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-并发简介"><a href="#1-并发简介" class="headerlink" title="1. 并发简介"></a>1. 并发简介</h2><h3 id="1-1-什么是进程？什么是线程？进程和线程的区别？"><a href="#1-1-什么是进程？什么是线程？进程和线程的区别？" class="headerlink" title="1.1. 什么是进程？什么是线程？进程和线程的区别？"></a>1.1. 什么是进程？什么是线程？进程和线程的区别？</h3><ul>
<li>什么是进程<ul>
<li>简言之，进程可视为一个正在运行的程序。</li>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。</li>
</ul>
</li>
<li>什么是线程<ul>
<li>线程是操作系统进行调度的基本单位。</li>
</ul>
</li>
<li>进程 vs. 线程<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程比进程划分更细，所以执行开销更小，并发性更高。</li>
<li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li>
</ul>
</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="https://blog.csdn.net/yaosiming2011/article/details/44280797" target="_blank" rel="noopener">进程和线程关系及区别</a></p>
</blockquote>
<h3 id="1-2-多线程编程的好处是什么？"><a href="#1-2-多线程编程的好处是什么？" class="headerlink" title="1.2. 多线程编程的好处是什么？"></a>1.2. 多线程编程的好处是什么？</h3><ul>
<li>更有效率的利用多处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="1-3-如何让正在运行的线程暂停一段时间？"><a href="#1-3-如何让正在运行的线程暂停一段时间？" class="headerlink" title="1.3. 如何让正在运行的线程暂停一段时间？"></a>1.3. 如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用 <code>Thread</code> 类的 Sleep() 方法让线程暂停一段时间。</p>
<p>需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。</p>
<h3 id="1-4-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#1-4-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="1.4. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>1.4. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h3><p>线程调度器是一个操作系统服务，它负责为 <code>Runnable</code> 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</p>
<p>时间分片是指将可用的 CPU 时间分配给可用的 <code>Runnable</code> 线程的过程。</p>
<p>分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<h3 id="1-5-在多线程中，什么是上下文切换-context-switching-？"><a href="#1-5-在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="1.5. 在多线程中，什么是上下文切换(context-switching)？"></a>1.5. 在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h3 id="1-6-如何确保线程安全？"><a href="#1-6-如何确保线程安全？" class="headerlink" title="1.6. 如何确保线程安全？"></a>1.6. 如何确保线程安全？</h3><ul>
<li>原子类(atomic concurrent classes)</li>
<li>锁</li>
<li><code>volatile</code> 关键字</li>
<li>不变类和线程安全类</li>
</ul>
<h3 id="1-7-什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#1-7-什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="1.7. 什么是死锁(Deadlock)？如何分析和避免死锁？"></a>1.7. 什么是死锁(Deadlock)？如何分析和避免死锁？</h3><p>死锁是指两个以上的线程永远相互阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。</p>
<p>分析死锁，我们需要查看 Java 应用程序的线程转储。我们需要找出那些状态为 BLOCKED 的线程和他们等待的资源。每个资源都有一个唯一的 id，用这个 id 我们可以找出哪些线程已经拥有了它的对象锁。</p>
<p>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p>
<h2 id="2-线程基础"><a href="#2-线程基础" class="headerlink" title="2. 线程基础"></a>2. 线程基础</h2><h3 id="2-1-Java-线程生命周期中有哪些状态？各状态之间如何切换？"><a href="#2-1-Java-线程生命周期中有哪些状态？各状态之间如何切换？" class="headerlink" title="2.1. Java 线程生命周期中有哪些状态？各状态之间如何切换？"></a>2.1. Java 线程生命周期中有哪些状态？各状态之间如何切换？</h3><p align="center"><br>  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/thread-state.png"><br></p>

<p><code>java.lang.Thread.State</code> 中定义了 <strong>6</strong> 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。</p>
<p>以下是各状态的说明，以及状态间的联系：</p>
<ul>
<li><strong>开始（New）</strong> - 还没有调用 <code>start()</code> 方法的线程处于此状态。</li>
<li><strong>可运行（Runnable）</strong> - 已经调用了 <code>start()</code> 方法的线程状态。此状态意味着，线程已经准备好了，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。</li>
<li><strong>阻塞（Blocked）</strong> - 阻塞状态。线程阻塞的线程状态等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定，以便在调用 <code>Object.wait()</code> 之后输入同步块/方法或重新输入同步块/方法。</li>
<li><strong>等待（Waiting）</strong> - 等待状态。一个线程处于等待状态，是由于执行了 3 个方法中的任意方法：<ul>
<li><code>Object.wait()</code></li>
<li><code>Thread.join()</code></li>
<li><code>LockSupport.park()</code></li>
</ul>
</li>
<li><strong>定时等待（Timed waiting）</strong> - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：<ul>
<li><code>Thread.sleep(sleeptime)</code></li>
<li><code>Object.wait(timeout)</code></li>
<li><code>Thread.join(timeout)</code></li>
<li><code>LockSupport.parkNanos(timeout)</code></li>
<li><code>LockSupport.parkUntil(timeout)</code></li>
</ul>
</li>
<li><strong>终止(Terminated)</strong> - 线程 <code>run()</code> 方法执行结束，或者因异常退出了 <code>run()</code> 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="https://www.w3resource.com/java-tutorial/java-threadclass-methods-and-threadstates.php" target="_blank" rel="noopener">Java <code>Thread</code> Methods and <code>Thread</code> States</a><br>:point_right: 参考阅读：<a href="https://blog.csdn.net/pange1991/article/details/53860651" target="_blank" rel="noopener">Java 线程的 5 种状态及切换(透彻讲解)</a></p>
</blockquote>
<h3 id="2-2-创建线程有哪些方式？这些方法各自利弊是什么？"><a href="#2-2-创建线程有哪些方式？这些方法各自利弊是什么？" class="headerlink" title="2.2. 创建线程有哪些方式？这些方法各自利弊是什么？"></a>2.2. 创建线程有哪些方式？这些方法各自利弊是什么？</h3><p>创建线程主要有三种方式：</p>
<p><strong>1. 继承 <code>Thread</code> 类</strong></p>
<ul>
<li>定义 <code>Thread</code> 类的子类，并重写该类的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体就代表了线程要完成的任务。因此把 <code>run()</code> 方法称为执行体。</li>
<li>创建 <code>Thread</code> 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li>
</ul>
<p><strong>2. 实现 <code>Runnable</code> 接口</strong></p>
<ul>
<li>定义 <code>Runnable</code> 接口的实现类，并重写该接口的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体同样是该线程的线程执行体。</li>
<li>创建 <code>Runnable</code> 实现类的实例，并以此实例作为 <code>Thread</code> 对象，该 <code>Thread</code> 对象才是真正的线程对象。</li>
<li>调用线程对象的 start() 方法来启动该线程。</li>
</ul>
<p><strong>3. 通过 <code>Callable</code> 接口和 <code>Future</code> 接口</strong></p>
<ul>
<li>创建 <code>Callable</code> 接口的实现类，并实现 <code>call()</code> 方法，该 <code>call()</code> 方法将作为线程执行体，并且有返回值。</li>
<li>创建 <code>Callable</code> 实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了该 <code>Callable</code> 对象的 <code>call()</code> 方法的返回值。</li>
<li>使用 <code>FutureTask</code> 对象作为 <code>Thread</code> 对象的 target 创建并启动新线程。</li>
<li>调用 <code>FutureTask</code> 对象的 <code>get()</code> 方法来获得子线程执行结束后的返回值</li>
</ul>
<p>三种创建线程方式对比</p>
<ul>
<li>实现 <code>Runnable</code> 接口优于继承 <code>Thread</code> 类，因为根据开放封闭原则——实现接口更便于扩展；</li>
<li>实现 <code>Runnable</code> 接口的线程没有返回值；而使用 <code>Callable</code> / <code>Future</code> 方式可以让线程有返回值。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="https://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="noopener">java 创建线程的三种方式及其对比</a></p>
</blockquote>
<h3 id="2-3-什么是-Callable-和-Future？什么是-FutureTask？"><a href="#2-3-什么是-Callable-和-Future？什么是-FutureTask？" class="headerlink" title="2.3. 什么是 Callable 和 Future？什么是 FutureTask？"></a>2.3. 什么是 <code>Callable</code> 和 <code>Future</code>？什么是 <code>FutureTask</code>？</h3><p><strong>什么是 <code>Callable</code> 和 <code>Future</code>？</strong></p>
<p>Java 5 在 concurrency 包中引入了 <code>Callable</code> 接口，它和 <code>Runnable</code> 接口很相似，但它可以返回一个对象或者抛出一个异常。</p>
<p><code>Callable</code> 接口使用泛型去定义它的返回类型。<code>Executors</code> 类提供了一些有用的方法去在线程池中执行 <code>Callable</code> 内的任务。由于 <code>Callable</code> 任务是并行的，我们必须等待它返回的结果。<code>Future</code> 对象为我们解决了这个问题。在线程池提交 <code>Callable</code> 任务后返回了一个 <code>Future</code> 对象，使用它我们可以知道 <code>Callable</code> 任务的状态和得到 <code>Callable</code> 返回的执行结果。<code>Future</code> 提供了 <code>get()</code> 方法让我们可以等待 <code>Callable</code> 结束并获取它的执行结果。</p>
<p><strong>什么是 <code>FutureTask</code>？</strong></p>
<p><code>FutureTask</code> 是 <code>Future</code> 的一个基础实现，我们可以将它同 <code>Executors</code> 使用处理异步任务。通常我们不需要使用 <code>FutureTask</code> 类，单当我们打算重写 <code>Future</code> 接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读 Java <code>FutureTask</code> 例子，学习如何使用它。</p>
<blockquote>
<p>:point_right: 参考阅读：<a href="http://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java 并发编程：Callable、Future 和 FutureTask</a></p>
</blockquote>
<h3 id="2-4-start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？"><a href="#2-4-start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？" class="headerlink" title="2.4. start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？"></a>2.4. <code>start()</code> 和 <code>run()</code> 有什么区别？可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法么？</h3><ul>
<li><code>run()</code> 方法是线程的执行体。</li>
<li><code>start()</code> 方法负责启动线程，然后 JVM 会让这个线程去执行 <code>run()</code> 方法。</li>
</ul>
<p>可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法么？</p>
<ul>
<li>可以。但是如果直接调用 <code>Thread</code> 的 <code>run()</code> 方法，它的行为就会和普通的方法一样。</li>
<li>为了在新的线程中执行我们的代码，必须使用 <code>start()</code> 方法。</li>
</ul>
<h3 id="2-5-sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？"><a href="#2-5-sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？" class="headerlink" title="2.5. sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？"></a>2.5. <code>sleep()</code>、<code>yield()</code>、<code>join()</code> 方法有什么区别？为什么 <code>sleep()</code> 和 <code>yield()</code> 方法是静态（static）的？</h3><p><strong><code>yield()</code></strong></p>
<ul>
<li><code>yield()</code> 方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从 <strong>Running</strong> 状态转入 <code>Runnable</code> 状态。</li>
<li>当某个线程调用了 <code>yield()</code> 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。</li>
</ul>
<p><strong><code>sleep()</code></strong></p>
<ul>
<li><code>sleep()</code> 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 <strong>Blocked</strong> 状态。</li>
<li>该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。</li>
<li>但是，<code>sleep()</code> 方法不会释放“锁标志”，也就是说如果有 <code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。</li>
</ul>
<p><strong><code>join()</code></strong></p>
<ul>
<li><code>join()</code> 方法会使当前线程转入 <strong>Blocked</strong> 状态，等待调用 <code>join()</code> 方法的线程结束后才能继续执行。</li>
</ul>
<p><strong>为什么 <code>sleep()</code> 和 <code>yield()</code> 方法是静态（static）的？</strong></p>
<ul>
<li><code>Thread</code> 类的 <code>sleep()</code> 和 <code>yield()</code> 方法将处理 <strong>Running</strong> 状态的线程。所以在其他处于非 <strong>Running</strong> 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="http://www.importnew.com/14958.html" target="_blank" rel="noopener">Java 线程中 yield 与 join 方法的区别</a><br>:point_right: 参考阅读：<a href="https://blog.csdn.net/xiangwanpeng/article/details/54972952" target="_blank" rel="noopener">sleep()，wait()，yield()和 join()方法的区别</a></p>
</blockquote>
<h3 id="2-6-Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？"><a href="#2-6-Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？" class="headerlink" title="2.6. Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？"></a>2.6. Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？</h3><p><strong>Java 中的线程优先级如何控制</strong></p>
<ul>
<li>Java 中的线程优先级的范围是 <code>[1,10]</code>，一般来说，高优先级的线程在运行时会具有优先权。可以通过 <code>thread.setPriority(Thread.MAX_PRIORITY)</code> 的方式设置，默认优先级为 <code>5</code>。</li>
</ul>
<p><strong>高优先级的 Java 线程一定先执行吗</strong></p>
<ul>
<li>即使设置了线程的优先级，也<strong>无法保证高优先级的线程一定先执行</strong>。</li>
<li>原因：这是因为 <strong>Java 线程优先级依赖于操作系统的支持</strong>，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。</li>
<li>结论：Java 线程优先级控制并不可靠。</li>
</ul>
<h3 id="2-7-什么是守护线程？为什么要用守护线程？如何创建守护线程？"><a href="#2-7-什么是守护线程？为什么要用守护线程？如何创建守护线程？" class="headerlink" title="2.7. 什么是守护线程？为什么要用守护线程？如何创建守护线程？"></a>2.7. 什么是守护线程？为什么要用守护线程？如何创建守护线程？</h3><p><strong>什么是守护线程</strong></p>
<ul>
<li>守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程。</li>
<li>与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。</li>
</ul>
<p><strong>为什么要用守护线程</strong></p>
<ul>
<li>守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。</li>
</ul>
<p><strong>如何创建守护线程</strong></p>
<ul>
<li>使用 <code>thread.setDaemon(true)</code> 可以设置 thread 线程为守护线程。</li>
<li>注意点：<ul>
<li>正在运行的用户线程无法设置为守护线程，所以 <code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则会抛出 <code>llegalThreadStateException</code> 异常；</li>
<li>一个守护线程创建的子线程依然是守护线程。</li>
<li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li>
</ul>
</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="https://blog.csdn.net/shimiso/article/details/8964414" target="_blank" rel="noopener">Java 中守护线程的总结</a></p>
</blockquote>
<h3 id="2-8-线程间是如何通信的？"><a href="#2-8-线程间是如何通信的？" class="headerlink" title="2.8. 线程间是如何通信的？"></a>2.8. 线程间是如何通信的？</h3><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。<code>Object</code> 类中 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 方法可以用于线程间通信关于资源的锁的状态。</p>
<blockquote>
<p>:point_right: 参考阅读：<a href="http://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="noopener">Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition</a></p>
</blockquote>
<h3 id="2-9-为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#2-9-为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="2.9. 为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？"></a>2.9. 为什么线程通信的方法 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 被定义在 Object 类里？</h3><p>Java 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 <code>wait()</code>、<code>notify()</code> 等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 Java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 Object 类的一部分，这样 Java 的每一个类都有用于线程间通信的基本方法</p>
<h3 id="2-10-为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#2-10-为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="2.10. 为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？"></a>2.10. 为什么 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 必须在同步方法或者同步块中被调用？</h3><p>当一个线程需要调用对象的 <code>wait()</code> 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 <code>notify()</code> 方法。同样的，当一个线程需要调用对象的 <code>notify()</code> 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。</p>
<p>由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>
<h2 id="3-并发机制的底层实现"><a href="#3-并发机制的底层实现" class="headerlink" title="3. 并发机制的底层实现"></a>3. 并发机制的底层实现</h2><h3 id="3-1-volatile-有什么作用？它的实现原理是什么？"><a href="#3-1-volatile-有什么作用？它的实现原理是什么？" class="headerlink" title="3.1. volatile 有什么作用？它的实现原理是什么？"></a>3.1. <code>volatile</code> 有什么作用？它的实现原理是什么？</h3><p>作用：</p>
<ul>
<li>被 <code>volatile</code> 关键字修饰的变量有两层含义：<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ul>
</li>
</ul>
<p>原理：</p>
<ul>
<li>观察加入 <code>volatile</code> 关键字和没有加入 <code>volatile</code> 关键字时所生成的汇编代码发现，加入 <code>volatile</code> 关键字时，会多出一个 lock 前缀指令。lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li>
</ul>
</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java 并发编程：<code>volatile</code> 关键字解析</a></p>
</blockquote>
<h3 id="3-2-synchronized-有什么作用？它的实现原理是什么？同步方法和同步块，哪个更好？"><a href="#3-2-synchronized-有什么作用？它的实现原理是什么？同步方法和同步块，哪个更好？" class="headerlink" title="3.2. synchronized 有什么作用？它的实现原理是什么？同步方法和同步块，哪个更好？"></a>3.2. <code>synchronized</code> 有什么作用？它的实现原理是什么？同步方法和同步块，哪个更好？</h3><p>作用：</p>
<ul>
<li>使用 <code>synchronized</code> 关键字来标记一个方法或者代码块，当某个线程调用该对象的 <code>synchronized</code> 方法或者访问 <code>synchronized</code> 代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</li>
</ul>
<p>原理：</p>
<ul>
<li><code>synchronized</code> 关键字会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被 <code>synchronized</code> 关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized 还会创建一个内存屏障，内存屏障指令保证了所有 CPU 操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都 happens-before 于随后获得这个锁的线程的操作。</li>
</ul>
<p>同步方法和同步块，哪个更好？</p>
<ul>
<li>同步块是更好的选择。</li>
<li>因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="http://www.cnblogs.com/dolphin0520/p/3923737.html" target="_blank" rel="noopener">Java 并发编程：synchronized</a></p>
</blockquote>
<h3 id="3-3-volatile-和-synchronized-的区别？"><a href="#3-3-volatile-和-synchronized-的区别？" class="headerlink" title="3.3. volatile 和 synchronized 的区别？"></a>3.3. <code>volatile</code> 和 <code>synchronized</code> 的区别？</h3><ul>
<li><code>volatile</code> 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； <code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性</li>
<li><code>volatile</code> 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：<a href="https://blog.csdn.net/suifeng3051/article/details/52611233" target="_blank" rel="noopener">volatile 和 <code>synchronized</code> 的区别</a></p>
</blockquote>
<h3 id="3-4-ThreadLocal-有什么作用？ThreadLocal-的实现原理是什么？"><a href="#3-4-ThreadLocal-有什么作用？ThreadLocal-的实现原理是什么？" class="headerlink" title="3.4. ThreadLocal 有什么作用？ThreadLocal 的实现原理是什么？"></a>3.4. <code>ThreadLocal</code> 有什么作用？<code>ThreadLocal</code> 的实现原理是什么？</h3><p><strong>ThreadLocal 有什么作用？</strong></p>
<p><code>ThreadLocal</code> 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p><strong>ThreadLocal 的实现原理是什么？</strong></p>
<p>首先，在每个线程 <code>Thread</code> 内部有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储实际的变量副本的，key 为当前 <code>ThreadLocal</code> 变量，value 为变量副本（即 T 类型的变量）。</p>
<p>初始时，在 <code>Thread</code> 里面，threadLocals 为空。当通过 <code>ThreadLocal</code> 变量调用 <code>get()</code> 方法或者 <code>set()</code> 方法，就会对 <code>Thread</code> 类中的 threadLocals 进行初始化，并且以当前 <code>ThreadLocal</code> 变量为键值，以 <code>ThreadLocal</code> 要保存的副本变量为 value，存到 threadLocals。</p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过 get 方法在 threadLocals 里面查找。</p>
<p>需要注意的是：<code>ThreadLocalMap.Entry</code> 继承了 <code>WeakReference</code>。ThreadLocalMap 使用它的目的是：当 threadLocal 实例可以被 GC 回收时，系统可以检测到该 threadLocal 对应的 Entry 是否已经过期（根据 <code>reference.get() == null</code> 来判断，如果为 true 则表示过期，程序内部称为 stale slots）来自动做一些清除工作，否则如果不清除的话容易产生内存无法释放的问题：value 对应的对象即使不再使用，但由于被 threadLocalMap 所引用导致无法被 GC 回收。实际代码中，ThreadLocalMap 会在 set，get 以及 resize 等方法中对 stale slots 做自动删除（set 以及 get 不保证所有过期 slots 会在操作中会被删除，而 resize 则会删除 threadLocalMap 中所有的过期 slots）。当然将 threadLocal 对象设置为 null 并不能完全避免内存泄露对象，最安全的办法仍然是调用 ThreadLocal 的 remove 方法，来彻底避免可能的内存泄露。</p>
<blockquote>
<p>:point_right: 参考阅读：<a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java 并发编程：深入剖析 ThreadLocal</a></p>
</blockquote>
<h2 id="4-内存模型"><a href="#4-内存模型" class="headerlink" title="4. 内存模型"></a>4. 内存模型</h2><h3 id="4-1-什么是-Java-内存模型"><a href="#4-1-什么是-Java-内存模型" class="headerlink" title="4.1. 什么是 Java 内存模型"></a>4.1. 什么是 Java 内存模型</h3><ul>
<li>Java 内存模型即 Java Memory Model，简称 JMM。JMM 定义了 JVM 在计算机内存(RAM)中的工作方式。JMM 是隶属于 JVM 的。</li>
<li>并发编程领域两个关键问题：线程间通信和线程间同步</li>
<li>线程间通信机制<ul>
<li>共享内存 - 线程间通过写-读内存中的公共状态来隐式进行通信。</li>
<li>消息传递 - java 中典型的消息传递方式就是 wait()和 notify()。</li>
</ul>
</li>
<li>线程间同步机制<ul>
<li>在共享内存模型中，必须显示指定某个方法或某段代码在线程间互斥地执行。</li>
<li>在消息传递模型中，由于发送消息必须在接收消息之前，因此同步是隐式进行的。</li>
</ul>
</li>
<li>Java 的并发采用的是共享内存模型</li>
<li>JMM 决定一个线程对共享变量的写入何时对另一个线程可见。</li>
<li>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</li>
<li>JMM 把内存分成了两部分：线程栈区和堆区<ul>
<li>线程栈<ul>
<li>JVM 中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。</li>
<li>线程栈还包含了当前方法的所有本地变量信息。线程中的本地变量对其它线程是不可见的。</li>
</ul>
</li>
<li>堆区<ul>
<li>堆区包含了 Java 应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如 Byte、Integer、Long 等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</li>
</ul>
</li>
<li>一个本地变量如果是原始类型，那么它会被完全存储到栈区。</li>
<li>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</li>
<li>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。</li>
<li>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</li>
</ul>
</li>
</ul>
<p align="center"><br>  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/jmm-model.png" alt="thread-states"><br></p>

<blockquote>
<p>:point_right: 参考阅读：<a href="https://blog.csdn.net/suifeng3051/article/details/52611310" target="_blank" rel="noopener">全面理解 Java 内存模型</a></p>
</blockquote>
<h2 id="5-同步容器和并发容器"><a href="#5-同步容器和并发容器" class="headerlink" title="5. 同步容器和并发容器"></a>5. 同步容器和并发容器</h2><h3 id="5-1-什么是同步容器？有哪些常见同步容器？它们是如何实现线程安全的？同步容器真的线程安全吗？"><a href="#5-1-什么是同步容器？有哪些常见同步容器？它们是如何实现线程安全的？同步容器真的线程安全吗？" class="headerlink" title="5.1. 什么是同步容器？有哪些常见同步容器？它们是如何实现线程安全的？同步容器真的线程安全吗？"></a>5.1. 什么是同步容器？有哪些常见同步容器？它们是如何实现线程安全的？同步容器真的线程安全吗？</h3><ul>
<li>同步容器是指 Java 中使用 <code>synchronized</code> 关键字修饰方法以保证方法线程安全的容器。</li>
<li>常见的同步容器有 Vector、HashTable、Stack，与之相对应的 ArrayList、HashMap、LinkedList 则是非线程安全的。</li>
<li>同步容器之所以说是线程安全的，是因为它们的方法被 <code>synchronized</code> 关键字修饰，从而保证了当有一个线程执行方法时，其他线程被阻塞。</li>
<li>同步容器中的所有自带方法都是线程安全的。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。<ul>
<li>典型场景：使用同步容器做迭代操作时，如果不对外部做同步，就可能出现 ConcurrentModificationException 异常。</li>
<li>结论：由于同步容器不能彻底保证线程安全，且性能不高，所以不建议使用。如果想使用线程安全的容器，可以考虑 juc 包中提供的 ConcurrentHashMap 等并发容器。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vector.size();i++)</span><br><span class="line">    vector.remove(i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>:point_right: 参考阅读：<a href="https://www.cnblogs.com/dolphin0520/p/3933404.html" target="_blank" rel="noopener">Java 并发编程：同步容器</a></p>
</blockquote>
<h3 id="5-2-什么是并发容器的实现？"><a href="#5-2-什么是并发容器的实现？" class="headerlink" title="5.2. 什么是并发容器的实现？"></a>5.2. 什么是并发容器的实现？</h3><p>Java 集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的 next()方法将抛出 ConcurrentModificationException 异常。</p>
<p>并发容器支持并发的遍历和并发的更新。</p>
<p>主要的类有 ConcurrentHashMap, CopyOnWriteArrayList 和 CopyOnWriteArraySet，阅读这篇文章了解如何避免 ConcurrentModificationException。</p>
<h2 id="6-锁"><a href="#6-锁" class="headerlink" title="6. 锁"></a>6. 锁</h2><h3 id="6-1-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#6-1-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="6.1. Lock 接口(Lock interface)是什么？对比同步它有什么优势？"></a>6.1. Lock 接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>可以使锁更公平可以使线程在等待锁的时候响应中断可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间可以在不同的范围，以不同的顺序获取和释放锁阅读更多关于锁的例子</p>
<h3 id="6-2-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#6-2-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="6.2. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"></a>6.2. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>java.util.concurrent.BlockingQueue 的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。</p>
<p>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出 NullPointerException。</p>
<p>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。</p>
<p>BlockingQueue 接口是 java collections 框架的一部分，它主要用于实现生产者-消费者问题。</p>
<p>阅读这篇文章了解如何使用阻塞队列实现生产者-消费者问题。</p>
<h2 id="7-原子变量类"><a href="#7-原子变量类" class="headerlink" title="7. 原子变量类"></a>7. 原子变量类</h2><h3 id="7-1-什么是原子操作？有哪些原子类？原子类的实现原理是什么？"><a href="#7-1-什么是原子操作？有哪些原子类？原子类的实现原理是什么？" class="headerlink" title="7.1. 什么是原子操作？有哪些原子类？原子类的实现原理是什么？"></a>7.1. 什么是原子操作？有哪些原子类？原子类的实现原理是什么？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和 long 类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。可以阅读这篇文章来了解 Java 的 atomic 类。</p>
<h2 id="8-并发工具类"><a href="#8-并发工具类" class="headerlink" title="8. 并发工具类"></a>8. 并发工具类</h2><h3 id="8-1-CyclicBarrier-和-CountDownLatch-有什么不同？"><a href="#8-1-CyclicBarrier-和-CountDownLatch-有什么不同？" class="headerlink" title="8.1. CyclicBarrier 和 CountDownLatch 有什么不同？"></a>8.1. CyclicBarrier 和 CountDownLatch 有什么不同？</h3><p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重用。</p>
<blockquote>
<p>:point_right: 参考阅读：<a href="http://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="noopener">Java 并发编程：CountDownLatch、CyclicBarrier 和 Semaphore</a></p>
</blockquote>
<h2 id="9-线程池"><a href="#9-线程池" class="headerlink" title="9. 线程池"></a>9. 线程池</h2><h3 id="9-1-什么是线程池？如何创建一个-Java-线程池？"><a href="#9-1-什么是线程池？如何创建一个-Java-线程池？" class="headerlink" title="9.1. 什么是线程池？如何创建一个 Java 线程池？"></a>9.1. 什么是线程池？如何创建一个 Java 线程池？</h3><p>一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。</p>
<p>java.util.concurrent.Executors 提供了一个 java.util.concurrent.Executor 接口的实现用于创建线程池。线程池例子展现了如何创建和使用线程池，或者阅读 ScheduledThreadPoolExecutor 例子，了解如何创建一个周期任务。</p>
<blockquote>
<p>:point_right: 参考阅读：<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java 并发编程：线程池的使用</a></p>
</blockquote>
<h3 id="9-2-什么是-Executors-框架？"><a href="#9-2-什么是-Executors-框架？" class="headerlink" title="9.2. 什么是 Executors 框架？"></a>9.2. 什么是 Executors 框架？</h3><p>Executor 框架同 java.util.concurrent.Executor 接口在 Java 5 中被引入。Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executors 框架可以非常方便的创建一个线程池，阅读这篇文章可以了解如何使用 Executor 框架创建一个线程池。</p>
<h3 id="9-3-Executors-类是什么？"><a href="#9-3-Executors-类是什么？" class="headerlink" title="9.3. Executors 类是什么？"></a>9.3. Executors 类是什么？</h3><p>Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 <code>Callable</code> 类提供了一些工具方法。</p>
<p>Executors 可以用于方便的创建线程池。</p>
<h3 id="ThreadPoolExecutor-有哪些参数，各自有什么用？"><a href="#ThreadPoolExecutor-有哪些参数，各自有什么用？" class="headerlink" title="ThreadPoolExecutor 有哪些参数，各自有什么用？"></a>ThreadPoolExecutor 有哪些参数，各自有什么用？</h3><p><code>java.uitl.concurrent.ThreadPoolExecutor</code> 类是 Executor 框架中最核心的一个类。</p>
<p>ThreadPoolExecutor 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li><code>corePoolSize</code>：默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中。</li>
<li><code>maximumPoolSize</code>：线程池允许创建的最大线程数。如果缓存队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li>
<li><code>keepAliveTime</code>：线程活动保持时间。线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li><code>unit</code>：参数 keepAliveTime 的时间单位，有 7 种取值。可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
<li><code>workQueue</code>：任务队列。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li><code>threadFactory</code>：创建线程的工厂。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li><code>handler</code>：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略。<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
</ul>
<h2 id="10-资料"><a href="#10-资料" class="headerlink" title="10. 资料"></a>10. 资料</h2><ul>
<li><a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener">Java 线程面试题 Top 50</a></li>
<li><a href="http://ifeve.com/java-multi-threading-concurrency-interview-questions-with-answers/" target="_blank" rel="noopener">JAVA 多线程和并发基础面试问答</a></li>
<li><a href="https://blog.csdn.net/yaosiming2011/article/details/44280797" target="_blank" rel="noopener">进程和线程关系及区别</a></li>
<li><a href="https://www.w3resource.com/java-tutorial/java-threadclass-methods-and-threadstates.php" target="_blank" rel="noopener">Java Thread Methods and Thread States</a></li>
<li><a href="https://blog.csdn.net/pange1991/article/details/53860651" target="_blank" rel="noopener">Java 线程的 5 种状态及切换(透彻讲解)</a></li>
<li><a href="https://blog.csdn.net/shimiso/article/details/8964414" target="_blank" rel="noopener">Java 中守护线程的总结</a></li>
<li><a href="https://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="noopener">java 创建线程的三种方式及其对比</a></li>
<li><a href="https://blog.csdn.net/pange1991/article/details/53860651" target="_blank" rel="noopener">Java 线程的 5 种状态及切换(透彻讲解)</a></li>
<li><a href="https://www.cnblogs.com/lcplcpjava/p/6896904.html" target="_blank" rel="noopener">java 线程方法 join 的简单总结</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="noopener">Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java 并发编程：volatile 关键字解析</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java 并发编程：Callable、Future 和 FutureTask</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java 并发编程：线程池的使用</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/design/UML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/design/UML/" itemprop="url">UML 教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UML-教程"><a href="#UML-教程" class="headerlink" title="UML 教程"></a>UML 教程</h1><blockquote>
<p>关键词：<code>部署图</code>, <code>组件图</code>, <code>包图</code>, <code>类图</code>, <code>复合结构图</code>, <code>对象图</code>, <code>活动图</code>, <code>状态机图</code>, <code>用例图</code>, <code>通信图</code>, <code>交互概述图</code>, <code>时序图</code>, <code>时间图</code></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#部署图">部署图</a></li>
<li><a href="#组件图">组件图</a></li>
<li><a href="#包图">包图</a></li>
<li><a href="#类图">类图</a></li>
<li><a href="#复合结构图">复合结构图</a></li>
<li><a href="#对象图">对象图</a></li>
<li><a href="#活动图">活动图</a></li>
<li><a href="#状态机图">状态机图</a></li>
<li><a href="#用例图">用例图</a></li>
<li><a href="#通信图">通信图</a></li>
<li><a href="#交互概述图">交互概述图</a></li>
<li><a href="#时序图">时序图</a></li>
<li><a href="#时间图">时间图</a></li>
<li><a href="#uml-工具">UML 工具</a></li>
<li><a href="#更多内容">更多内容</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="UML-图类型"><a href="#UML-图类型" class="headerlink" title="UML 图类型"></a>UML 图类型</h3><p>UML 图类型如下图所示：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-diagrams.png"></div><br></p>
<h4 id="结构式建模图"><a href="#结构式建模图" class="headerlink" title="结构式建模图"></a><a href="UML结构建模图.md">结构式建模图</a></h4><blockquote>
<p>结构式建模图（Structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素’建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。</p>
</blockquote>
<ul>
<li><a href="#类图">类图</a></li>
<li><a href="#对象图">对象图</a></li>
<li><a href="#包图">包图</a></li>
<li><a href="#组件图">组件图</a></li>
<li><a href="#部署图">部署图</a></li>
<li><a href="#复合结构图">复合结构图</a></li>
</ul>
<h4 id="行为式建模图"><a href="#行为式建模图" class="headerlink" title="行为式建模图"></a><a href="UML行为建模图.md">行为式建模图</a></h4><blockquote>
<p>行为式建模图（Behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。</p>
</blockquote>
<ul>
<li><a href="UML行为建模图.md#活动图">活动图</a></li>
<li><a href="UML行为建模图.md#状态图">状态图</a></li>
<li><a href="UML行为建模图.md#用例图">用例图</a></li>
<li><a href="UML行为建模图.md#通信图">通信图</a></li>
<li><a href="UML行为建模图.md#交互概述图">交互概述图</a></li>
<li><a href="UML行为建模图.md#时序图">时序图</a></li>
<li><a href="UML行为建模图.md#时间图">时间图</a></li>
</ul>
<h3 id="UML-概念"><a href="#UML-概念" class="headerlink" title="UML 概念"></a>UML 概念</h3><p>UML 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。</p>
<ul>
<li>对于结构而言 - 执行者，属性，类，元件，接口，对象，包。</li>
<li>对于行为而言 - 活动（UML），事件（UML），消息（UML），方法（UML），操作（UML），状态（UML），用例（UML）。</li>
<li>对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。</li>
<li>其他概念<ul>
<li>构造型—这规范符号应用到的模型</li>
<li>多重性—多重性标记法与资料库建模基数对应，例如：<code>1, 0..1, 1..*</code></li>
</ul>
</li>
</ul>
<h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><blockquote>
<p><strong>部署图（Deployment Diagram）用于对系统的物理结构建模</strong>。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。</p>
</blockquote>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-deployment-diagram-example.png"></div><br></p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-node.gif"></div><br></p>
<h3 id="节点实例"><a href="#节点实例" class="headerlink" title="节点实例"></a>节点实例</h3><p>图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-node-instance.gif"></div><br></p>
<h3 id="节点构造型"><a href="#节点构造型" class="headerlink" title="节点构造型"></a>节点构造型</h3><p>为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-node-stereotype.gif"></div><br></p>
<h3 id="工件"><a href="#工件" class="headerlink" title="工件"></a>工件</h3><p>工件是<a href="http://www.sparxsystems.cn/platforms/software_development.html" target="_blank" rel="noopener">软件开发</a>过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。</p>
<p>工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-artifact.gif"></div><br></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-network-model.gif"></div><br></p>
<h3 id="作为容器的节点"><a href="#作为容器的节点" class="headerlink" title="作为容器的节点"></a>作为容器的节点</h3><p>节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-embedded-model.gif"></div><br></p>
<h2 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h2><blockquote>
<p><strong>组件图（Component Diagram）描绘了组成一个软件系统的模块和嵌入控件</strong>。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。</p>
</blockquote>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-component-diagram.gif"></div><br></p>
<p>上图演示了一些组件和它们的内部关系。装配连接器（Assembly connectors）“连接”由”Product”和”Customer”的提供接口到由 “Order”指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“Order”需要的 “Payment”需求接口。</p>
<p>实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。</p>
<h3 id="表现组件"><a href="#表现组件" class="headerlink" title="表现组件"></a>表现组件</h3><p>组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-representing-components.gif"></div><br></p>
<h3 id="装配连接器"><a href="#装配连接器" class="headerlink" title="装配连接器"></a>装配连接器</h3><p>装配连接器在组件 “Component1”的需求接口和另一个组件 “Component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-required-interfaces.gif"></div><br></p>
<h3 id="带端口组件"><a href="#带端口组件" class="headerlink" title="带端口组件"></a>带端口组件</h3><p>使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-component-with-ports.gif"></div><br></p>
<h2 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h2><blockquote>
<p><strong>包图（Package Diagram）用来表现包和它所包含元素的组织</strong>。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 UML 元素。</p>
</blockquote>
<p>下面是一个包图的例子。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-package-diagram.gif"></div><br></p>
<p>包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。</p>
<p>包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-package.gif"></div><br></p>
<p>在 UML2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。</p>
<ul>
<li><strong>包的合并</strong> - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。</li>
<li><strong>包的导入</strong> - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。</li>
<li><strong>嵌套连接符</strong> - 源包和目标包间的嵌套连接符说明目标包完全包含源包。</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><blockquote>
<p><strong>类图（Class Diagram）展示了面向对象系统的构造模块</strong>。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（Generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。</p>
</blockquote>
<p>下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 “Account” 使用 “AddressBook”，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，”Contact” 和 “ContactGroup”值被包含在 “AddressBook”中。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-class-diagram.png"></div><br></p>
<h3 id="类（Classes）"><a href="#类（Classes）" class="headerlink" title="类（Classes）"></a>类（Classes）</h3><p>类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。</p>
<h3 id="类的标柱（Class-Notation）"><a href="#类的标柱（Class-Notation）" class="headerlink" title="类的标柱（Class Notation）"></a>类的标柱（Class Notation）</h3><p>类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。</p>
<p>在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如：”center” 属性显示初始化的值。最后面的分栏显示操作，如： setWidth，setLength 和 setPosition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 “+”号，这个属性或操作是公共的 ; “-“ 号则代表这个属性或操作是私有的。 “#”号是这个属性或操作被定义为保护的，” ~“ 号代表包的可见性。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-class.gif"></div><br></p>
<h3 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h3><p>接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-class-interface.gif"></div><br></p>
<p>接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-interface.gif"></div><br></p>
<h3 id="表（Tables）"><a href="#表（Tables）" class="headerlink" title="表（Tables）"></a>表（Tables）</h3><p>表尽管不是基本 UML 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«PK»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«FK»。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-table.gif"></div><br></p>
<h3 id="关联（Associations）"><a href="#关联（Associations）" class="headerlink" title="关联（Associations）"></a>关联（Associations）</h3><p>关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 “playsFor” 将变成”Player”类中的实例变量。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-associations.gif"></div><br></p>
<h3 id="泛化（Generalizations）"><a href="#泛化（Generalizations）" class="headerlink" title="泛化（Generalizations）"></a>泛化（Generalizations）</h3><p>泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“Circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 “Shape” 是抽象的，类名显示为斜体。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-generalizations.gif"></div><br></p>
<p>下图显示了与上图相同信息的视图。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-generalizations-02.gif"></div><br></p>
<h3 id="聚合（Aggregations）"><a href="#聚合（Aggregations）" class="headerlink" title="聚合（Aggregations）"></a>聚合（Aggregations）</h3><p>聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。</p>
<p>聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。</p>
<p>下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-aggregations.gif"></div><br></p>
<h3 id="关联类（Association-Classes）"><a href="#关联类（Association-Classes）" class="headerlink" title="关联类（Association Classes）"></a>关联类（Association Classes）</h3><p>关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-association-classes.gif"></div><br></p>
<h3 id="依赖（Dependencies）"><a href="#依赖（Dependencies）" class="headerlink" title="依赖（Dependencies）"></a>依赖（Dependencies）</h3><p>依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。</p>
<h3 id="跟踪（Traces）"><a href="#跟踪（Traces）" class="headerlink" title="跟踪（Traces）"></a>跟踪（Traces）</h3><p>跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。</p>
<h3 id="实现（Realizations）"><a href="#实现（Realizations）" class="headerlink" title="实现（Realizations）"></a>实现（Realizations）</h3><p>是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-realizations.gif"></div><br></p>
<h3 id="嵌套（Nestings）"><a href="#嵌套（Nestings）" class="headerlink" title="嵌套（Nestings）"></a>嵌套（Nestings）</h3><p>嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 EA 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-nestings.gif"></div><br></p>
<h2 id="复合结构图"><a href="#复合结构图" class="headerlink" title="复合结构图"></a>复合结构图</h2><blockquote>
<p><strong>复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。</strong></p>
</blockquote>
<p>类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-composite-structure-diagram.gif"></div><br></p>
<h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。<br>部件在类或组件内部显示为不加修饰的方框。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-part.gif"></div><br></p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。<br>端口显示为所属类元边界指定的方框。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-port.gif"></div><br></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。<br>当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-interface.gif"></div><br></p>
<p>注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。<br>提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-interface-02.gif"></div><br></p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-delegate.gif"></div><br></p>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。<br>协作元素显示为椭圆。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-collaboration.gif"></div><br></p>
<h3 id="角色绑定"><a href="#角色绑定" class="headerlink" title="角色绑定"></a>角色绑定</h3><p>角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-role-binding.gif"></div><br></p>
<h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-represent.gif"></div><br></p>
<p>发生<br>发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-occurrence.gif"></div><br></p>
<h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><blockquote>
<p><strong>对象图（Object Diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系</strong>。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。</p>
</blockquote>
<h3 id="类和对象元素"><a href="#类和对象元素" class="headerlink" title="类和对象元素"></a>类和对象元素</h3><p>下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-object.gif"></div><br></p>
<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-run-time-state.gif"></div><br></p>
<h3 id="类和对象图示例"><a href="#类和对象图示例" class="headerlink" title="类和对象图示例"></a>类和对象图示例</h3><p>下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-object-diagram.gif"></div><br></p>
<h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><blockquote>
<p>UML 中，活动图用来展示活动的顺序。<strong>显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径</strong>。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。<br>一个活动图的示例如下所示。</p>
</blockquote>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-diagram.gif"></div><br></p>
<p>下面描述组成活动图的元素。</p>
<h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><p>活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity.gif"></div><br></p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>一个动作代表活动中的一个步骤。动作用圆角矩形表示。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-action.gif"></div><br></p>
<h3 id="动作约束"><a href="#动作约束" class="headerlink" title="动作约束"></a>动作约束</h3><p>动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-conditions.gif"></div><br></p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>控制流显示一个动作到下一个动作的流。表示为带箭头实线</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-edge.gif"></div><br></p>
<h3 id="初始节点"><a href="#初始节点" class="headerlink" title="初始节点"></a>初始节点</h3><p>一个开始或起始点用大黑圆点表示，如下图。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-initial.gif"></div><br></p>
<h3 id="结束节点"><a href="#结束节点" class="headerlink" title="结束节点"></a>结束节点</h3><p>结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-final.gif"></div><br></p>
<p>流结束节点表示为内部为叉号的圆环。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-flow-final.gif"></div><br></p>
<p>这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。</p>
<h3 id="对象和对象流"><a href="#对象和对象流" class="headerlink" title="对象和对象流"></a>对象和对象流</h3><p>对象流是对象和数据转递的通道。对象显示为矩形。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-object.gif"></div><br></p>
<p>对象流显示为带箭头的连接器，表明方向和通过的对象。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-object-flow.gif"></div><br></p>
<p>一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-object-flow-alt.gif"></div><br></p>
<p>数据存储显示为带 «datastore» 关键字的对象。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-data-store.gif"></div><br></p>
<h3 id="判断节点和合并节点"><a href="#判断节点和合并节点" class="headerlink" title="判断节点和合并节点"></a>判断节点和合并节点</h3><p>判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-decision-or-merge.gif"></div><br></p>
<h3 id="分叉和结合节点"><a href="#分叉和结合节点" class="headerlink" title="分叉和结合节点"></a>分叉和结合节点</h3><p>分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-fork-and-join.gif"></div><br></p>
<p>结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。</p>
<h3 id="扩展域"><a href="#扩展域" class="headerlink" title="扩展域"></a>扩展域</h3><p>扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 “iterative”， “parallel” 或 “stream”显示在区域的左上角</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-expansion-region.gif"></div><br></p>
<h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><p>异常处理器在活动图中可以建模。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-exception-handler.gif"></div><br></p>
<h3 id="可中断活动区"><a href="#可中断活动区" class="headerlink" title="可中断活动区"></a>可中断活动区</h3><p>可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 “Close Order” 动作，定单处理”Process Order” 动作会执行直到完成，除非”Cancel Request”取消请求中断被接受，这会将控制传递给”Cancel Order”动作。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-interruptible-activity-region.gif"></div><br></p>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 “accounting department”中执行的，有在 “customer”中执行的。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-activity-partitions.gif"></div><br></p>
<h2 id="状态机图"><a href="#状态机图" class="headerlink" title="状态机图"></a>状态机图</h2><blockquote>
<p><strong>状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</strong></p>
</blockquote>
<p>如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-diagram.gif"></div><br></p>
<p>门可以处于以下的三种状态之一： “Opened”打开状态， “Closed”关闭状态，或者”Locked”锁定状态。 它分别响应事件：“Open”开门， “Close”关门， “Lock”锁门 和 “Unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorWay-&gt;isEmpty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态被表示为圆角矩形，状态名写在里面。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state.gif"></div><br></p>
<h3 id="起始和结束状态"><a href="#起始和结束状态" class="headerlink" title="起始和结束状态"></a>起始和结束状态</h3><p>初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-initial-and-final.gif"></div><br></p>
<h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“Trigger”触发器，一个“Guard”监护条件和一个“effect”效果。如下所示：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-transition.gif"></div><br></p>
<p>“Trigger”触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。”Guard”监护是一个条件，而且必须为真，以便于让触发器引起转移。效果”Effect”是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。</p>
<h3 id="状态活动"><a href="#状态活动" class="headerlink" title="状态活动"></a>状态活动</h3><p>在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-entry-and-exit.gif"></div><br></p>
<p>可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。</p>
<h3 id="自转移"><a href="#自转移" class="headerlink" title="自转移"></a>自转移</h3><p>一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-self-transition.gif"></div><br></p>
<h3 id="复合状态"><a href="#复合状态" class="headerlink" title="复合状态"></a>复合状态</h3><p>一个状态机图可以有子状态机图，如下图所示：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-compound.gif"></div><br></p>
<p>可选择不同方式显示相同信息，如下图所示：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-composite.gif"></div><br></p>
<p>上面版本的标注说明”Check PIN”的子状态机图显示在单独的图中。</p>
<h3 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h3><p>有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从”初始化”状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 “Ready” 状态开始。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-entry-point.gif"></div><br></p>
<p>下图显示了状态机的上一层。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-entry-point-higher.gif"></div><br></p>
<h3 id="出口点"><a href="#出口点" class="headerlink" title="出口点"></a>出口点</h3><p>有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-exit-point.gif"></div><br></p>
<h3 id="选择伪状态"><a href="#选择伪状态" class="headerlink" title="选择伪状态"></a>选择伪状态</h3><p>选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-choice.gif"></div><br></p>
<h3 id="连接伪状态"><a href="#连接伪状态" class="headerlink" title="连接伪状态"></a>连接伪状态</h3><p>连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-junction.gif"></div><br></p>
<h3 id="终止伪状态"><a href="#终止伪状态" class="headerlink" title="终止伪状态"></a>终止伪状态</h3><p>进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-terminate.gif"></div><br></p>
<h3 id="历史状态"><a href="#历史状态" class="headerlink" title="历史状态"></a>历史状态</h3><p>历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。</p>
<p>在这个状态机中，当洗衣机运行时，它会按照”Washing” 到 Rinsing”再到”Spinning”来进行。如果电源被切断 ，洗衣机会停止运行并进入”Power Off” 状态。当电源恢复，运行状态在”History State”符号处进入，表示它会从上次离开的地方恢复。</p>
<h3 id="并发区"><a href="#并发区" class="headerlink" title="并发区"></a>并发区</h3><p>一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 “Applying Brakes”， “front brake”和”rear brakes” 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-concurrent-regions.gif"></div><br></p>
<h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><blockquote>
<p><strong>用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。</strong></p>
</blockquote>
<h3 id="执行者"><a href="#执行者" class="headerlink" title="执行者"></a>执行者</h3><p>用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-actor.gif"></div><br></p>
<p>在下图中，执行者可以详细的泛化其他执行者:</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-generalize.gif"></div><br></p>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case.gif"></div><br></p>
<p>使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 “Customer”使用 “Withdraw”用例。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-use.gif"></div><br></p>
<p>用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-multiplicity-use.gif"></div><br></p>
<h3 id="用例定义"><a href="#用例定义" class="headerlink" title="用例定义"></a>用例定义</h3><p>一个典型的用例包括:</p>
<ul>
<li><strong>名称和描述</strong> - 用例通常用一个动词词组定义，而且有一个简短的文字说明。</li>
<li><strong>需求</strong> - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。</li>
<li><strong>约束</strong> - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为”真”。不变化条件说明用例整个执行过程中该条件始终为”真”。</li>
<li><strong>情形</strong> - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。</li>
<li><strong>情形图</strong></li>
<li><strong>附加信息</strong></li>
</ul>
<h3 id="包含用例"><a href="#包含用例" class="headerlink" title="包含用例"></a>包含用例</h3><p>用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认”<card identification> 在运行时，被用例“取钱”<withdraw>当作一个子部分。</withdraw></card></p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-include.gif"></div><br></p>
<p>用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。</p>
<h3 id="扩展用例"><a href="#扩展用例" class="headerlink" title="扩展用例"></a>扩展用例</h3><p>一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”<get approval>用例将有选择的扩展常规的“修改订单”<modify order>用例。</modify></get></p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-extend.gif"></div><br></p>
<p><strong>扩展点</strong> - 扩展用例的加入点被定义为扩展点。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-extend-with-condition.gif"></div><br></p>
<p><strong>系统边界</strong> - 它用来显示用例在系统内部，执行者在系统的外部。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-use-case-system-boundary.gif"></div><br></p>
<h2 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h2><blockquote>
<p>通信图，以前称之为协作图，是一种交互图，<strong>所显示消息与时序图相似，但是它更侧重于对象间的联系</strong>。</p>
</blockquote>
<p>在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。</p>
<p>下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-communications-diagram.gif"></div><br></p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-diagram.gif"></div><br></p>
<h2 id="交互概述图"><a href="#交互概述图" class="headerlink" title="交互概述图"></a>交互概述图</h2><blockquote>
<p><strong>一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。</strong></p>
</blockquote>
<h3 id="交互发生"><a href="#交互发生" class="headerlink" title="交互发生"></a>交互发生</h3><p>交互发生引用现有的交互图。显示为一个引用框，左上角显示 “ref” 。被引用的图名显示在框的中央。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-interaction-overview-01.gif"></div><br></p>
<h3 id="交互元素"><a href="#交互元素" class="headerlink" title="交互元素"></a>交互元素</h3><p>交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-interaction-overview-02.gif"></div><br></p>
<h3 id="将它们放在一起"><a href="#将它们放在一起" class="headerlink" title="将它们放在一起"></a>将它们放在一起</h3><p>所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-interaction-overview-diagram.gif"></div><br></p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><blockquote>
<p><strong>时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。</strong></p>
</blockquote>
<h3 id="生命线"><a href="#生命线" class="headerlink" title="生命线"></a>生命线</h3><p>一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是”self”，则说明该生命线代表控制带时序图的类元。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-lifelines.gif"></div><br></p>
<p>有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-more-lifelines.gif"></div><br></p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-messages.gif"></div><br></p>
<h3 id="执行发生"><a href="#执行发生" class="headerlink" title="执行发生"></a>执行发生</h3><p>向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。</p>
<h3 id="内部通信"><a href="#内部通信" class="headerlink" title="内部通信"></a>内部通信</h3><p>内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-recursion.gif"></div><br></p>
<h3 id="迷路消息和拾取消息"><a href="#迷路消息和拾取消息" class="headerlink" title="迷路消息和拾取消息"></a>迷路消息和拾取消息</h3><p>迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-lost-and-found.gif"></div><br></p>
<h3 id="生命线开始与结束"><a href="#生命线开始与结束" class="headerlink" title="生命线开始与结束"></a>生命线开始与结束</h3><p>生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（Child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-lost-and-found.gif"></div><br></p>
<h3 id="时间和期限约束"><a href="#时间和期限约束" class="headerlink" title="时间和期限约束"></a>时间和期限约束</h3><p>消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-time.gif"></div><br></p>
<h3 id="复合片段"><a href="#复合片段" class="headerlink" title="复合片段"></a>复合片段</h3><p>如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:</p>
<ul>
<li>选择性片段 (显示 “alt”) 为 if…then…else 结构建模。</li>
<li>选项片段 (显示 “opt”) 为 “switch”(开关) 结构建模。</li>
<li>中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。</li>
<li>并行片段(显示 “par”) 为并发处理建模。</li>
<li>弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。</li>
<li>严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。</li>
<li>非片段 (显示 “neg”) 包含了一系列不可用的消息。</li>
<li>关键片段 具有关键部分。</li>
<li>忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。</li>
<li>考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。</li>
<li>断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。</li>
<li>循环片段 包含一系列被重复的消息。</li>
</ul>
<p>下图显示的是循环片段：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-fragment.gif"></div><br></p>
<p>这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带”ref”，将被参考图名显示在方框的中间。</p>
<h3 id="门"><a href="#门" class="headerlink" title="门"></a>门</h3><p>门是连接片段内消息和片段外消息的连接点。 在 EA 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：” top level diagram”中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-top-level-diagram.gif"></div><br></p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-nested-diagram.gif"></div><br></p>
<h3 id="部分分解"><a href="#部分分解" class="headerlink" title="部分分解"></a>部分分解</h3><p>一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-part-decomposition.gif"></div><br></p>
<h3 id="状态常量-延续"><a href="#状态常量-延续" class="headerlink" title="状态常量/延续"></a>状态常量/延续</h3><p>状态常量是生命线的约束，运行时始终为”真”。显示为两侧半圆的矩形，如下图：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-sequence-state-invariant.gif"></div><br></p>
<p>延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。</p>
<h2 id="时间图"><a href="#时间图" class="headerlink" title="时间图"></a>时间图</h2><blockquote>
<p><strong>UML 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。</strong></p>
</blockquote>
<h3 id="状态生命线"><a href="#状态生命线" class="headerlink" title="状态生命线"></a>状态生命线</h3><p>状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，X 轴显示经过的时间，Y 轴被标为给出状态的列表。状态生命线如下所示：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-state-lifeline.gif"></div><br></p>
<h3 id="值生命线"><a href="#值生命线" class="headerlink" title="值生命线"></a>值生命线</h3><p>值生命线显示随时间变化，一个单项的值的变化。X 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-value-lifeline.gif"></div><br></p>
<h3 id="将它们放在一起-1"><a href="#将它们放在一起-1" class="headerlink" title="将它们放在一起"></a>将它们放在一起</h3><p>状态和值的生命线能叠加组合。它们必须有相同的 X 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/design/uml/uml-timing-diagram.gif"></div><br></p>
<h2 id="UML-工具"><a href="#UML-工具" class="headerlink" title="UML 工具"></a>UML 工具</h2><p>UML 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 UML 工具：</p>
<h3 id="亿图"><a href="#亿图" class="headerlink" title="亿图"></a>亿图</h3><blockquote>
<p>国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。</p>
<p><a href="http://www.edrawsoft.cn/" target="_blank" rel="noopener">亿图官网</a></p>
</blockquote>
<p><br><div align="center"><img src="http://www.edrawsoft.cn/images/software/createsoftware.png"></div><br></p>
<h3 id="Visio"><a href="#Visio" class="headerlink" title="Visio"></a>Visio</h3><blockquote>
<p>Office 的绘图工具，特点是简单、清晰。</p>
<p><a href="https://products.office.com/zh-cn/visio/flowchart-software" target="_blank" rel="noopener">Visio 官网</a></p>
</blockquote>
<p><br><div align="center"><img src="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RE2jMC4?ver=5361&q=90&h=675&w=830&b=%23FFFFFFFF&aim=true"></div><br></p>
<h3 id="StarUML"><a href="#StarUML" class="headerlink" title="StarUML"></a>StarUML</h3><blockquote>
<p>样式精美，功能全面的 UML 工具。</p>
<p><a href="http://staruml.io/" target="_blank" rel="noopener">StarUML 官网</a></p>
</blockquote>
<p><br><div align="center"><img src="http://staruml.io/image/screenshot_jumbotron.png"></div><br></p>
<h3 id="Astah"><a href="#Astah" class="headerlink" title="Astah"></a>Astah</h3><blockquote>
<p>样式不错，功能全面的绘图工具。</p>
<p><a href="http://astah.net/" target="_blank" rel="noopener">Astah 官网</a></p>
</blockquote>
<p><br><div align="center"><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1539757904141&di=7e4f71d0a00ffcd87e0e5aa62f0ed168&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D3525476819%2C2924170461%26fm%3D214%26gp%3D0.jpg"></div><br></p>
<h3 id="ArgoUML"><a href="#ArgoUML" class="headerlink" title="ArgoUML"></a>ArgoUML</h3><blockquote>
<p>UML 工具。</p>
<p><a href="https://argouml.en.softonic.com/?ex=CAT-759.2" target="_blank" rel="noopener">ArgoUML 官网</a></p>
</blockquote>
<p><br><div align="center"><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f4e8a7c6923df8dcb23087c3ac7819ee/8b13632762d0f70315a83ced05fa513d2697c5ed.jpg"></div><br></p>
<h3 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h3><blockquote>
<p>在线绘图工具，特点是简洁、清晰。</p>
<p><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn 官网</a></p>
</blockquote>
<h3 id="drawio"><a href="#drawio" class="headerlink" title="drawio"></a>drawio</h3><blockquote>
<p>开源的在线绘图工具，特点是简洁、清晰。</p>
<p><a href="https://www.draw.io/" target="_blank" rel="noopener">drawio 官网</a></p>
</blockquote>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><blockquote>
<p>:notebook: 本文已归档到：「<a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">notes</a>」</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/统一建模语言" target="_blank" rel="noopener">Wiki-UML</a></li>
<li><a href="https://sparxsystems.cn/resources/uml2_tutorial/index.html" target="_blank" rel="noopener">Sparx UML 教程</a></li>
<li><a href="https://www.omg.org/spec/UML" target="_blank" rel="noopener">OMG UML</a></li>
<li><a href="https://www.tutorialspoint.com/uml/index.htm" target="_blank" rel="noopener">UML Tutorial</a></li>
<li><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">W3Cschool UML 教程</a></li>
<li><a href="https://blog.csdn.net/soft_zzti/article/details/79811923" target="_blank" rel="noopener">UML 学习入门就这一篇文章</a></li>
<li><a href="http://www.cnblogs.com/ywqu/category/223486.html" target="_blank" rel="noopener">http://www.cnblogs.com/ywqu/category/223486.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/programming/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/programming/shell/" itemprop="url">一篇文章让你彻底掌握 shell 语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一篇文章让你彻底掌握-shell-语言"><a href="#一篇文章让你彻底掌握-shell-语言" class="headerlink" title="一篇文章让你彻底掌握 shell 语言"></a>一篇文章让你彻底掌握 shell 语言</h1><blockquote>
<p>由于 bash 是 Linux 标准默认的 shell 解释器，可以说 bash 是 shell 编程的基础。</p>
<p>本文主要介绍 bash 的语法，对于 linux 指令不做任何介绍。</p>
<p>:notebook: 本文已归档到：「<a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">notes</a>」<br>:keyboard: 本文的源码已归档到 <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos" target="_blank" rel="noopener">os-tutorial</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">███████╗██╗  ██╗███████╗██╗     ██╗</span><br><span class="line">██╔════╝██║  ██║██╔════╝██║     ██║</span><br><span class="line">███████╗███████║█████╗  ██║     ██║</span><br><span class="line">╚════██║██╔══██║██╔══╝  ██║     ██║</span><br><span class="line">███████║██║  ██║███████╗███████╗███████╗</span><br></pre></td></tr></table></figure>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-简介">1. 简介</a><ul>
<li><a href="#11-什么是-shell">1.1. 什么是 shell</a></li>
<li><a href="#12-什么是-shell-脚本">1.2. 什么是 shell 脚本</a></li>
<li><a href="#13-shell-环境">1.3. Shell 环境</a></li>
<li><a href="#14-模式">1.4. 模式</a></li>
</ul>
</li>
<li><a href="#2-基本语法">2. 基本语法</a><ul>
<li><a href="#21-解释器">2.1. 解释器</a></li>
<li><a href="#22-注释">2.2. 注释</a></li>
<li><a href="#23-echo">2.3. echo</a></li>
<li><a href="#24-printf">2.4. printf</a></li>
</ul>
</li>
<li><a href="#3-变量">3. 变量</a><ul>
<li><a href="#31-变量命名原则">3.1. 变量命名原则</a></li>
<li><a href="#32-声明变量">3.2. 声明变量</a></li>
<li><a href="#33-只读变量">3.3. 只读变量</a></li>
<li><a href="#34-删除变量">3.4. 删除变量</a></li>
<li><a href="#35-变量类型">3.5. 变量类型</a></li>
<li><a href="#36-变量示例源码">3.6. 变量示例源码</a></li>
</ul>
</li>
<li><a href="#4-字符串">4. 字符串</a><ul>
<li><a href="#41-单引号和双引号">4.1. 单引号和双引号</a></li>
<li><a href="#42-拼接字符串">4.2. 拼接字符串</a></li>
<li><a href="#43-获取字符串长度">4.3. 获取字符串长度</a></li>
<li><a href="#44-截取子字符串">4.4. 截取子字符串</a></li>
<li><a href="#45-查找子字符串">4.5. 查找子字符串</a></li>
<li><a href="#46-字符串示例源码">4.6. 字符串示例源码</a></li>
</ul>
</li>
<li><a href="#5-数组">5. 数组</a><ul>
<li><a href="#51-创建数组">5.1. 创建数组</a></li>
<li><a href="#52-访问数组元素">5.2. 访问数组元素</a></li>
<li><a href="#53-访问数组长度">5.3. 访问数组长度</a></li>
<li><a href="#54-向数组中添加元素">5.4. 向数组中添加元素</a></li>
<li><a href="#55-从数组中删除元素">5.5. 从数组中删除元素</a></li>
<li><a href="#56-数组示例源码">5.6. 数组示例源码</a></li>
</ul>
</li>
<li><a href="#6-运算符">6. 运算符</a><ul>
<li><a href="#61-算术运算符">6.1. 算术运算符</a></li>
<li><a href="#62-关系运算符">6.2. 关系运算符</a></li>
<li><a href="#63-布尔运算符">6.3. 布尔运算符</a></li>
<li><a href="#64-逻辑运算符">6.4. 逻辑运算符</a></li>
<li><a href="#65-字符串运算符">6.5. 字符串运算符</a></li>
<li><a href="#66-文件测试运算符">6.6. 文件测试运算符</a></li>
</ul>
</li>
<li><a href="#7-控制语句">7. 控制语句</a><ul>
<li><a href="#71-条件语句">7.1. 条件语句</a></li>
<li><a href="#72-循环语句">7.2. 循环语句</a></li>
</ul>
</li>
<li><a href="#8-函数">8. 函数</a><ul>
<li><a href="#81-位置参数">8.1. 位置参数</a></li>
<li><a href="#82-函数处理参数">8.2. 函数处理参数</a></li>
</ul>
</li>
<li><a href="#9-shell-扩展">9. Shell 扩展</a></li>
<li><a href="#10-流和重定向">10. 流和重定向</a><ul>
<li><a href="#101-输入输出流">10.1. 输入、输出流</a></li>
<li><a href="#102-重定向">10.2. 重定向</a></li>
<li><a href="#103-devnull-文件">10.3. <code>/dev/null</code> 文件</a></li>
</ul>
</li>
<li><a href="#11-debug">11. Debug</a></li>
<li><a href="#12-更多内容">12. 更多内容</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-什么是-shell"><a href="#1-1-什么是-shell" class="headerlink" title="1.1. 什么是 shell"></a>1.1. 什么是 shell</h3><ul>
<li>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li>
<li>Shell 既是一种命令语言，又是一种程序设计语言。</li>
<li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。</li>
</ul>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h3 id="1-2-什么是-shell-脚本"><a href="#1-2-什么是-shell-脚本" class="headerlink" title="1.2. 什么是 shell 脚本"></a>1.2. 什么是 shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 <code>.sh</code>。</p>
<p>业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。</p>
<h3 id="1-3-Shell-环境"><a href="#1-3-Shell-环境" class="headerlink" title="1.3. Shell 环境"></a>1.3. Shell 环境</h3><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>Shell 的解释器种类众多，常见的有：</p>
<ul>
<li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">sh</a> - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li>
<li><a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">bash</a> - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li>
<li><a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a> - 智能和用户友好的命令行 shell。</li>
<li><a href="http://xiki.org/" target="_blank" rel="noopener">xiki</a> - 使 shell 控制台更友好，更强大。</li>
<li><a href="http://www.zsh.org/" target="_blank" rel="noopener">zsh</a> - 功能强大的 shell 与脚本语言。</li>
</ul>
<h4 id="指定脚本解释器"><a href="#指定脚本解释器" class="headerlink" title="指定脚本解释器"></a>指定脚本解释器</h4><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p>
<p>所以，你应该会在 shell 中，见到诸如以下的注释：</p>
<ul>
<li>指定 sh 解释器</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定 bash 解释器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">#!/usr/bin/env bash</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这样做的好处是，系统会自动在 <code>PATH</code> 环境变量中查找你指定的程序（本例中的<code>bash</code>）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的<code>PATH</code>变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的<code>bash</code>，我们可能将其路径添加到<code>PATH</code>中，来“隐藏”老版本。如果直接用<code>#!/bin/bash</code>，那么系统会选择老版本的<code>bash</code>来执行脚本，如果用<code>#!/usr/bin/env bash</code>，则会使用新版本。</p>
</blockquote>
<h3 id="1-4-模式"><a href="#1-4-模式" class="headerlink" title="1.4. 模式"></a>1.4. 模式</h3><p>shell 有交互和非交互两种模式。</p>
<h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><blockquote>
<p>简单来说，你可以将 shell 的交互模式理解为执行命令行。</p>
</blockquote>
<p>看到形如下面的东西，说明 shell 处于交互模式下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@host:~$</span><br></pre></td></tr></table></figure>
<p>接着，便可以输入一系列 Linux 命令，比如 <code>ls</code>，<code>grep</code>，<code>cd</code>，<code>mkdir</code>，<code>rm</code> 等等。</p>
<h4 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h4><blockquote>
<p>简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。</p>
</blockquote>
<p>在非交互模式下，shell 从文件或者管道中读取命令并执行。</p>
<p>当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。</p>
<p>可以使用下面的命令让 shell 以非交互模式运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh /path/to/script.sh</span><br><span class="line">bash /path/to/script.sh</span><br><span class="line"><span class="built_in">source</span> /path/to/script.sh</span><br><span class="line">./path/to/script.sh</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>script.sh</code>是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，<code>sh</code>和<code>bash</code>是 shell 解释器程序。你可以使用任何喜欢的编辑器创建<code>script.sh</code>（vim，nano，Sublime Text, Atom 等等）。</p>
<p>其中，<code>source /path/to/script.sh</code> 和 <code>./path/to/script.sh</code> 是等价的。</p>
<p>除此之外，你还可以通过<code>chmod</code>命令给文件添加可执行的权限，来直接执行脚本文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /path/to/script.sh <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">/path/to/test.sh</span><br></pre></td></tr></table></figure>
<p>这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：</p>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/helloworld.sh" target="_blank" rel="noopener">helloworld.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们使用了一个很有用的命令<code>echo</code>来输出字符串到屏幕上。</p>
<h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-解释器"><a href="#2-1-解释器" class="headerlink" title="2.1. 解释器"></a>2.1. 解释器</h3><p>前面虽然两次提到了<code>#!</code> ，但是本着重要的事情说三遍的精神，这里再强调一遍：</p>
<p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang（也称为 Hashbang ）</a>。</p>
<p><code>#!</code> 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入<code>sh</code>, <code>bash</code>, <code>python</code>, <code>php</code>等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2. 注释"></a>2.2. 注释</h3><p>注释可以说明你的代码是什么作用，以及为什么这样写。</p>
<p>shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。</p>
<ul>
<li>单行注释 - 以 <code>#</code> 开头，到行尾结束。</li>
<li>多行注释 - 以 <code>:&lt;&lt;EOF</code> 开头，到 <code>EOF</code> 结束。</li>
</ul>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/comment-demo.sh" target="_blank" rel="noopener">comment-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># shell 注释示例</span></span><br><span class="line"><span class="comment"># author：zp</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo '这是单行注释'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 这是分割线 ##########</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'这是多行注释'</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="2-3-echo"><a href="#2-3-echo" class="headerlink" title="2.3. echo"></a>2.3. echo</h3><p>echo 用于字符串的输出。</p>
<p>输出普通字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world"</span></span><br><span class="line"><span class="comment"># Output: hello, world</span></span><br></pre></td></tr></table></figure>
<p>输出含变量的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure>
<p>输出含变量的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, \"<span class="variable">$&#123;name&#125;</span>\""</span></span><br><span class="line"><span class="comment"># Output: hello, "zp"</span></span><br></pre></td></tr></table></figure>
<p>输出含换行符的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"YES\nNO"</span></span><br><span class="line"><span class="comment">#  Output: YES\nNO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\nNO"</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br></pre></td></tr></table></figure>
<p>输出含不换行符的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"YES"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"YES\c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"NO"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YESNO</span></span><br></pre></td></tr></table></figure>
<p>输出重定向至文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p>输出执行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#  Output:(当前目录路径)</span></span><br></pre></td></tr></table></figure>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/echo-demo.sh" target="_blank" rel="noopener">echo-demo.sh</a></p>
<h3 id="2-4-printf"><a href="#2-4-printf" class="headerlink" title="2.4. printf"></a>2.4. printf</h3><p>printf 用于格式化输出字符串。</p>
<p>默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 <code>\n</code>。</p>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/printf-demo.sh" target="_blank" rel="noopener">printf-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'%d %s\n'</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d %s\n"</span> 1 <span class="string">"abc"</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无引号</span></span><br><span class="line"><span class="built_in">printf</span> %s abcdef</span><br><span class="line"><span class="comment">#  Output: abcdef(并不会换行)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> abc def</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  abc</span></span><br><span class="line"><span class="comment">#  def</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s\n"</span> a b c d e f g h i j</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  a b c</span></span><br><span class="line"><span class="comment">#  d e f</span></span><br><span class="line"><span class="comment">#  g h i</span></span><br><span class="line"><span class="comment">#  j</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s and %d \n"</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#   and 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭靖 男 66.1234</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 杨过 男 48.6543</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭芙 女 47.9876</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  姓名     性别   体重kg</span></span><br><span class="line"><span class="comment">#  郭靖     男      66.12</span></span><br><span class="line"><span class="comment">#  杨过     男      48.65</span></span><br><span class="line"><span class="comment">#  郭芙     女      47.99</span></span><br></pre></td></tr></table></figure>
<h4 id="printf-的转义符"><a href="#printf-的转义符" class="headerlink" title="printf 的转义符"></a>printf 的转义符</h4><table>
<thead>
<tr>
<th>序列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\a</code></td>
<td>警告字符，通常为 ASCII 的 BEL 字符</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>后退</td>
</tr>
<tr>
<td><code>\c</code></td>
<td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页（formfeed）</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车（Carriage return）</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表符</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>一个字面上的反斜杠字符</td>
</tr>
<tr>
<td><code>\ddd</code></td>
<td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td><code>\0ddd</code></td>
<td>表示 1 到 3 位的八进制值字符</td>
</tr>
</tbody>
</table>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>跟许多程序设计语言一样，你可以在 bash 中创建变量。</p>
<p>Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。</p>
<h3 id="3-1-变量命名原则"><a href="#3-1-变量命名原则" class="headerlink" title="3.1. 变量命名原则"></a>3.1. 变量命名原则</h3><ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li>
</ul>
<h3 id="3-2-声明变量"><a href="#3-2-声明变量" class="headerlink" title="3.2. 声明变量"></a>3.2. 声明变量</h3><p>访问变量的语法形式为：<code>${var}</code> 和 <code>$var</code> 。</p>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;word&#125;</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-只读变量"><a href="#3-3-只读变量" class="headerlink" title="3.3. 只读变量"></a>3.3. 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rword=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;rword&#125;</span></span><br><span class="line"><span class="built_in">readonly</span> rword</span><br><span class="line"><span class="comment"># rword="bye"  # 如果放开注释，执行时会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-删除变量"><a href="#3-4-删除变量" class="headerlink" title="3.4. 删除变量"></a>3.4. 删除变量</h3><p>使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dword=<span class="string">"hello"</span>  <span class="comment"># 声明变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span>  <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> dword    <span class="comment"># 删除变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span></span><br><span class="line"><span class="comment"># Output: （空）</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-变量类型"><a href="#3-5-变量类型" class="headerlink" title="3.5. 变量类型"></a>3.5. 变量类型</h3><ul>
<li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li>
<li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li>
</ul>
<p>常见的环境变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$HOME</code></td>
<td>当前用户的用户目录</td>
</tr>
<tr>
<td><code>$PATH</code></td>
<td>用分号分隔的目录列表，shell 会到这些目录中查找命令</td>
</tr>
<tr>
<td><code>$PWD</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td><code>$RANDOM</code></td>
<td>0 到 32767 之间的整数</td>
</tr>
<tr>
<td><code>$UID</code></td>
<td>数值类型，当前用户的用户 ID</td>
</tr>
<tr>
<td><code>$PS1</code></td>
<td>主要系统输入提示符</td>
</tr>
<tr>
<td><code>$PS2</code></td>
<td>次要系统输入提示符</td>
</tr>
</tbody>
</table>
<p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html###sect_03_02_04" target="_blank" rel="noopener">这里</a> 有一张更全面的 Bash 环境变量列表。</p>
<h3 id="3-6-变量示例源码"><a href="#3-6-变量示例源码" class="headerlink" title="3.6. 变量示例源码"></a>3.6. 变量示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/variable-demo.sh" target="_blank" rel="noopener">variable-demo.sh</a></p>
<h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><h3 id="4-1-单引号和双引号"><a href="#4-1-单引号和双引号" class="headerlink" title="4.1. 单引号和双引号"></a>4.1. 单引号和双引号</h3><p>shell 字符串可以用单引号 <code>&#39;&#39;</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p>
<ul>
<li>单引号的特点<ul>
<li>单引号里不识别变量</li>
<li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
</li>
<li>双引号的特点<ul>
<li>双引号里识别变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
</li>
</ul>
<p>综上，推荐使用双引号。</p>
<h3 id="4-2-拼接字符串"><a href="#4-2-拼接字符串" class="headerlink" title="4.2. 拼接字符串"></a>4.2. 拼接字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">name1=<span class="string">'white'</span></span><br><span class="line">str1=<span class="string">'hello, '</span><span class="variable">$&#123;name1&#125;</span><span class="string">''</span></span><br><span class="line">str2=<span class="string">'hello, $&#123;name1&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str1&#125;</span>_<span class="variable">$&#123;str2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, white_hello, $&#123;name1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">name2=<span class="string">"black"</span></span><br><span class="line">str3=<span class="string">"hello, "</span><span class="variable">$&#123;name2&#125;</span><span class="string">""</span></span><br><span class="line">str4=<span class="string">"hello, <span class="variable">$&#123;name2&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str3&#125;</span>_<span class="variable">$&#123;str4&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, black_hello, black</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-获取字符串长度"><a href="#4-3-获取字符串长度" class="headerlink" title="4.3. 获取字符串长度"></a>4.3. 获取字符串长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#text&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-截取子字符串"><a href="#4-4-截取子字符串" class="headerlink" title="4.4. 截取子字符串"></a>4.4. 截取子字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text=<span class="string">"12345"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;text:2:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 34</span></span><br></pre></td></tr></table></figure>
<p>从第 3 个字符开始，截取 2 个字符</p>
<h3 id="4-5-查找子字符串"><a href="#4-5-查找子字符串" class="headerlink" title="4.5. 查找子字符串"></a>4.5. 查找子字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">text=<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$&#123;text&#125;</span>"</span> ll`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute: ./str-demo5.sh</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>查找 <code>ll</code> 子字符在 <code>hello</code> 字符串中的起始位置。</p>
<h3 id="4-6-字符串示例源码"><a href="#4-6-字符串示例源码" class="headerlink" title="4.6. 字符串示例源码"></a>4.6. 字符串示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/string-demo.sh" target="_blank" rel="noopener">string-demo.sh</a></p>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><p>bash 只支持一维数组。</p>
<p>数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<h3 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1. 创建数组"></a>5.1. 创建数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组的不同方式</span></span><br><span class="line">nums=([2]=2 [0]=0 [1]=1)</span><br><span class="line">colors=(red yellow <span class="string">"dark blue"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-2-访问数组元素"><a href="#5-2-访问数组元素" class="headerlink" title="5.2. 访问数组元素"></a>5.2. 访问数组元素</h3><ul>
<li><strong>访问数组的单个元素：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span></span><br><span class="line"><span class="comment"># Output: 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>访问数组的所有元素：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br></pre></td></tr></table></figure>
<p>上面两行有很重要（也很微妙）的区别：</p>
<p>为了将数组中每个元素单独一行输出，我们用 <code>printf</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark</span></span><br><span class="line"><span class="comment"># + blue</span></span><br></pre></td></tr></table></figure>
<p>为什么<code>dark</code>和<code>blue</code>各占了一行？尝试用引号包起来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[*]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red yellow dark blue</span></span><br></pre></td></tr></table></figure>
<p>现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试<code>${colors[@]}</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark blue</span></span><br></pre></td></tr></table></figure>
<p>在引号内，<code>${colors[@]}</code>将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。</p>
<ul>
<li><strong>访问数组的部分元素：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]:0:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 0 1</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>${array[@]}</code> 扩展为整个数组，<code>:0:2</code>取出了数组中从 0 开始，长度为 2 的元素。</p>
<h3 id="5-3-访问数组长度"><a href="#5-3-访问数组长度" class="headerlink" title="5.3. 访问数组长度"></a>5.3. 访问数组长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-向数组中添加元素"><a href="#5-4-向数组中添加元素" class="headerlink" title="5.4. 向数组中添加元素"></a>5.4. 向数组中添加元素</h3><p>向数组中添加元素也非常简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colors=(white <span class="string">"<span class="variable">$&#123;colors[@]&#125;</span>"</span> green black)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>${colors[@]}</code> 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组<code>colors</code>的赋值覆盖了它原来的值。</p>
<h3 id="5-5-从数组中删除元素"><a href="#5-5-从数组中删除元素" class="headerlink" title="5.5. 从数组中删除元素"></a>5.5. 从数组中删除元素</h3><p>用<code>unset</code>命令来从数组中删除一个元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> nums[0]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure>
<h3 id="5-6-数组示例源码"><a href="#5-6-数组示例源码" class="headerlink" title="5.6. 数组示例源码"></a>5.6. 数组示例源码</h3><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/array-demo.sh" target="_blank" rel="noopener">array-demo.sh</a></p>
<h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h2><h3 id="6-1-算术运算符"><a href="#6-1-算术运算符" class="headerlink" title="6.1. 算术运算符"></a>6.1. 算术运算符</h3><p>下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $x + $y</code> 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $x - $y</code> 结果为 -10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $x * $y</code> 结果为 200。</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $y / $x</code> 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $y % $x</code> 结果为 0。</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td><code>x=$y</code> 将把变量 y 的值赋给 x。</td>
</tr>
<tr>
<td>==</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td><code>[ $x == $y ]</code> 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td><code>[ $x != $y ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <code>[$x==$y]</code> 是错误的，必须写成 <code>[ $x == $y ]</code>。</p>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo.sh" target="_blank" rel="noopener">operator-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> == <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 + 20 = 30</span></span><br><span class="line"><span class="comment">#  10 - 20 = -10</span></span><br><span class="line"><span class="comment">#  10 * 20 = 200</span></span><br><span class="line"><span class="comment">#  20 / 10 = 2</span></span><br><span class="line"><span class="comment">#  20 % 10 = 0</span></span><br><span class="line"><span class="comment">#  10 != 20</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-关系运算符"><a href="#6-2-关系运算符" class="headerlink" title="6.2. 关系运算符"></a>6.2. 关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-eq</code></td>
<td>检测两个数是否相等，相等返回 true。</td>
<td><code>[ $a -eq $b ]</code>返回 false。</td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>检测两个数是否相等，不相等返回 true。</td>
<td><code>[ $a -ne $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td><code>[ $a -gt $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td><code>[ $a -lt $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -ge $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-le</code></td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -le $b ]</code>返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo2.sh" target="_blank" rel="noopener">operator-demo2.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 不大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 不小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 大于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 小于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 小于或等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 大于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo2.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -gt 20: x 不大于 y</span></span><br><span class="line"><span class="comment">#  10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -ge 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-布尔运算符"><a href="#6-3-布尔运算符" class="headerlink" title="6.3. 布尔运算符"></a>6.3. 布尔运算符</h3><p>下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>!</code></td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td><code>[ ! false ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-o</code></td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td>
</tr>
</tbody>
</table>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo3.sh" target="_blank" rel="noopener">operator-demo3.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 15 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 5 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo3.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 != 20 : x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 小于 100 且 20 大于 15 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 100 或 20 大于 100 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 5 或 20 大于 100 : 返回 false</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4. 逻辑运算符"></a>6.4. 逻辑运算符</h3><p>以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑的 AND</td>
<td><code>[[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]</code> 返回 false</td>
</tr>
<tr>
<td>`</td>
<td></td>
<td>`</td>
<td>逻辑的 OR</td>
<td>`[[ ${x} -lt 100</td>
<td></td>
<td>${y} -gt 100 ]]` 返回 true</td>
</tr>
</tbody>
</table>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo4.sh" target="_blank" rel="noopener">operator-demo4.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo4.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -lt 100 &amp;&amp; 20 -gt 100 返回 false</span></span><br><span class="line"><span class="comment">#  10 -lt 100 || 20 -gt 100 返回 true</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-字符串运算符"><a href="#6-5-字符串运算符" class="headerlink" title="6.5. 字符串运算符"></a>6.5. 字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td><code>[ $a = $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td><code>[ $a != $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-z</code></td>
<td>检测字符串长度是否为 0，为 0 返回 true。</td>
<td><code>[ -z $a ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>检测字符串长度是否为 0，不为 0 返回 true。</td>
<td><code>[ -n $a ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>str</code></td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td><code>[ $a ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo5.sh" target="_blank" rel="noopener">operator-demo5.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">"abc"</span></span><br><span class="line">y=<span class="string">"xyz"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> : x 等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>: x 不等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$&#123;x&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> : 字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo5.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=abc, y=xyz</span></span><br><span class="line"><span class="comment">#  abc = xyz: x 不等于 y</span></span><br><span class="line"><span class="comment">#  abc != xyz : x 不等于 y</span></span><br><span class="line"><span class="comment">#  -z abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  -n abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  abc : 字符串不为空</span></span><br></pre></td></tr></table></figure>
<h3 id="6-6-文件测试运算符"><a href="#6-6-文件测试运算符" class="headerlink" title="6.6. 文件测试运算符"></a>6.6. 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td><code>[ -b $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td><code>[ -c $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td><code>[ -d $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td><code>[ -f $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td><code>[ -g $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td><code>[ -k $file ]</code>返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是有名管道，如果是，则返回 true。</td>
<td><code>[ -p $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td><code>[ -u $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td><code>[ -r $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td><code>[ -w $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td><code>[ -x $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td>
<td><code>[ -s $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td><code>[ -e $file ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo6.sh" target="_blank" rel="noopener">operator-demo6.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="string">"/etc/hosts"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可读"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可读"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -w <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可写"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可写"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -x <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件可执行"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不可执行"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为普通文件"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为特殊文件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件是个目录"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不是个目录"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -s <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span> 文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo6.sh</span></span><br><span class="line"><span class="comment">#  Output:(根据文件的实际情况，输出结果可能不同)</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可读</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可写</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不可执行</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件为普通文件</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不是个目录</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不为空</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件存在</span></span><br></pre></td></tr></table></figure>
<h2 id="7-控制语句"><a href="#7-控制语句" class="headerlink" title="7. 控制语句"></a>7. 控制语句</h2><h3 id="7-1-条件语句"><a href="#7-1-条件语句" class="headerlink" title="7.1. 条件语句"></a>7.1. 条件语句</h3><p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式。</p>
<p>由<code>[[ ]]</code>（<code>sh</code>中是<code>[ ]</code>）包起来的表达式被称作 <strong>检测命令</strong> 或 <strong>基元</strong>。这些表达式帮助我们检测一个条件的结果。这里可以找到有关<a href="http://serverfault.com/a/52050" target="_blank" rel="noopener">bash 中单双中括号区别</a>的答案。</p>
<p>共有两个不同的条件表达式：<code>if</code>和<code>case</code>。</p>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><p>（1）<code>if</code> 语句</p>
<p><code>if</code>在使用上跟其它语言相同。如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行。<code>fi</code>标志着条件代码块的结束。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写成一行</span></span><br><span class="line"><span class="keyword">if</span> [[ 1 -eq 1 ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"1 -eq 1 result is: true"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 1 -eq 1 result is: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写成多行</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"abc"</span> -eq <span class="string">"abc"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">""</span>abc<span class="string">" -eq "</span>abc<span class="string">" result is: true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: abc -eq abc result is: true</span></span><br></pre></td></tr></table></figure>
<p>（2）<code>if else</code> 语句</p>
<p>同样，我们可以使用<code>if..else</code>语句，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 2 -ne 1 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: true</span></span><br></pre></td></tr></table></figure>
<p>（3）<code>if elif else</code> 语句</p>
<p>有些时候，<code>if..else</code>不能满足我们的要求。别忘了<code>if..elif..else</code>，使用起来也很方便。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 10 &lt; 20</span></span><br></pre></td></tr></table></figure>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/if-demo.sh" target="_blank" rel="noopener">if-demo.sh</a></p>
<h4 id="case"><a href="#case" class="headerlink" title="case"></a><code>case</code></h4><p>如果你需要面对很多情况，分别要采取不同的措施，那么使用<code>case</code>会比嵌套的<code>if</code>更有用。使用<code>case</code>来解决复杂的条件判断，看起来像下面这样：</p>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/case-demo.sh" target="_blank" rel="noopener">case-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">"+"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"-"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"*"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">"/"</span>)</span><br><span class="line">    val=`expr <span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unknown oper!"</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>每种情况都是匹配了某个模式的表达式。<code>|</code>用来分割多个模式，<code>)</code>用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。<code>*</code>代表任何不匹配以上给定模式的模式。命令块儿之间要用<code>;;</code>分隔。</p>
<h3 id="7-2-循环语句"><a href="#7-2-循环语句" class="headerlink" title="7.2. 循环语句"></a>7.2. 循环语句</h3><p>循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。</p>
<p>Bash 中有四种循环：<code>for</code>，<code>while</code>，<code>until</code>和<code>select</code>。</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><p><code>for</code>与它在 C 语言中的姊妹非常像。看起来是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在每次循环的过程中，<code>arg</code>依次被赋值为从<code>elem1</code>到<code>elemN</code>。这些值还可以是通配符或者<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95" target="_blank" rel="noopener">大括号扩展</a>。</p>
<p>当然，我们还可以把<code>for</code>循环写在一行，但这要求<code>do</code>之前要有一个分号，就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>还有，如果你觉得<code>for..in..do</code>对你来说有点奇怪，那么你也可以像 C 语言那样使用<code>for</code>，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>当我们想对一个目录下的所有文件做同样的操作时，<code>for</code>就很方便了。举个例子，如果我们想把所有的<code>.bash</code>文件移动到<code>script</code>文件夹中，并给它们可执行权限，我们的脚本可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DIR=/home/zp</span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$&#123;DIR&#125;</span>/*.sh; <span class="keyword">do</span></span><br><span class="line">  mv <span class="string">"<span class="variable">$FILE</span>"</span> <span class="string">"<span class="variable">$&#123;DIR&#125;</span>/scripts"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</span></span><br></pre></td></tr></table></figure>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/for-demo.sh" target="_blank" rel="noopener">for-demo.sh</a></p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h4><p><code>while</code>循环检测一个条件，只要这个条件为 _真_，就执行一段命令。被检测的条件跟<code>if..then</code>中使用的<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%9F%BA%E5%85%83%E5%92%8C%E7%BB%84%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">基元</a>并无二异。因此一个<code>while</code>循环看起来会是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [[ condition ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>跟<code>for</code>循环一样，如果我们把<code>do</code>和被检测的条件写到一行，那么必须要在<code>do</code>之前加一个分号。</p>
<p>比如下面这个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 0到9之间每个数的平方</span></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> $((x * x))</span><br><span class="line">  x=$((x + 1))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  4</span></span><br><span class="line"><span class="comment">#  9</span></span><br><span class="line"><span class="comment">#  16</span></span><br><span class="line"><span class="comment">#  25</span></span><br><span class="line"><span class="comment">#  36</span></span><br><span class="line"><span class="comment">#  49</span></span><br><span class="line"><span class="comment">#  64</span></span><br><span class="line"><span class="comment">#  81</span></span><br></pre></td></tr></table></figure>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/while-demo.sh" target="_blank" rel="noopener">while-demo.sh</a></p>
<h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h4><p><code>until</code>循环跟<code>while</code>循环正好相反。它跟<code>while</code>一样也需要检测一个测试条件，但不同的是，只要该条件为 _假_ 就一直执行循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=0</span><br><span class="line">until [[ <span class="variable">$&#123;x&#125;</span> -ge 5 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br><span class="line">  x=`expr <span class="variable">$&#123;x&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  2</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  4</span></span><br></pre></td></tr></table></figure>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/until-demo.sh" target="_blank" rel="noopener">until-demo.sh</a></p>
<h4 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a><code>select</code>循环</h4><p><code>select</code>循环帮助我们组织一个用户菜单。它的语法几乎跟<code>for</code>循环一致：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select answer <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是<code>$?</code>（<code>PS3</code>变量）。用户的选择结果会被保存到<code>answer</code>中。如果<code>answer</code>是一个在<code>1..N</code>之间的数字，那么<code>语句</code>会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用<code>break</code>语句。</p>
<p>一个可能的实例可能会是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">PS3=<span class="string">"Choose the package manager: "</span></span><br><span class="line">select ITEM <span class="keyword">in</span> bower npm gem pip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Enter the package name: "</span> &amp;&amp; <span class="built_in">read</span> PACKAGE</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;ITEM&#125;</span> <span class="keyword">in</span></span><br><span class="line">  bower) bower install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  npm) npm install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  gem) gem install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  pip) pip install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">break</span> <span class="comment"># 避免无限循环</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。</p>
<p>运行这个脚本，会得到如下输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">1) bower</span><br><span class="line">2) npm</span><br><span class="line">3) gem</span><br><span class="line">4) pip</span><br><span class="line">Choose the package manager: 2</span><br><span class="line">Enter the package name: gitbook-cli</span><br></pre></td></tr></table></figure>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/select-demo.sh" target="_blank" rel="noopener">select-demo.sh</a></p>
<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a><code>break</code> 和 <code>continue</code></h4><p>如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的<code>break</code>和<code>continue</code>语句来实现。它们可以在任何循环中使用。</p>
<blockquote>
<p><code>break</code>语句用来提前结束当前循环。</p>
<p><code>continue</code>语句用来跳过某次迭代。</p>
</blockquote>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/break-demo.sh" target="_blank" rel="noopener">break-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找 10 以内第一个能整除 2 和 3 的正整数</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;i&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  i=`expr <span class="variable">$&#123;i&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># Output: 6</span></span><br></pre></td></tr></table></figure>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/continue-demo.sh" target="_blank" rel="noopener">continue-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印10以内的奇数</span></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 10; i ++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % 2)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  5</span></span><br><span class="line"><span class="comment">#  7</span></span><br><span class="line"><span class="comment">#  9</span></span><br></pre></td></tr></table></figure>
<h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><p>bash 函数定义语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()] &#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>:bulb: 说明：</p>
<ol>
<li>函数定义时，<code>function</code> 关键字可有可无。</li>
<li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li>
<li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li>
<li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li>
</ol>
</blockquote>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo.sh" target="_blank" rel="noopener">function-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">calc</span></span>()&#123;</span><br><span class="line">  PS3=<span class="string">"choose the oper: "</span></span><br><span class="line">  select oper <span class="keyword">in</span> + - \* / <span class="comment"># 生成操作符选择菜单</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter first num: "</span> &amp;&amp; <span class="built_in">read</span> x <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"enter second num: "</span> &amp;&amp; <span class="built_in">read</span> y <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">exec</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"+"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"-"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"*"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">"/"</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;oper&#125;</span> is not support!"</span></span><br><span class="line">      <span class="built_in">return</span> 0</span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">calc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the result is: $?"</span> <span class="comment"># $? 获取 calc 函数返回值</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo.sh</span><br><span class="line">1) +</span><br><span class="line">2) -</span><br><span class="line">3) *</span><br><span class="line">4) /</span><br><span class="line">choose the oper: 3</span><br><span class="line">enter first num: 10</span><br><span class="line">enter second num: 10</span><br><span class="line">the result is: 100</span><br></pre></td></tr></table></figure>
<h3 id="8-1-位置参数"><a href="#8-1-位置参数" class="headerlink" title="8.1. 位置参数"></a>8.1. 位置参数</h3><p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p>
<p>位置参数变量表：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0</code></td>
<td>脚本名称</td>
</tr>
<tr>
<td><code>$1 … $9</code></td>
<td>第 1 个到第 9 个参数列表</td>
</tr>
<tr>
<td><code>${10} … ${N}</code></td>
<td>第 10 个到 N 个参数列表</td>
</tr>
<tr>
<td><code>$*</code> or <code>$@</code></td>
<td>除了<code>$0</code>外的所有位置参数</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>不包括<code>$0</code>在内的位置参数的个数</td>
</tr>
<tr>
<td><code>$FUNCNAME</code></td>
<td>函数名称（仅在函数内部有值）</td>
</tr>
</tbody>
</table>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo2.sh" target="_blank" rel="noopener">function-demo2.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span></span><br><span class="line">  x=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第一个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">y=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$2</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为：<span class="variable">$2</span>"</span></span><br><span class="line">  y=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第二个参数为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction <span class="variable">$&#123;x&#125;</span> <span class="variable">$&#123;y&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="keyword">function</span>-demo2.sh</span><br><span class="line">第一个参数为空</span><br><span class="line">第二个参数为空</span><br><span class="line">函数第一个入参：0</span><br><span class="line">函数第二个入参：0</span><br><span class="line"></span><br><span class="line">$ ./<span class="keyword">function</span>-demo2.sh 10 20</span><br><span class="line">第一个参数为：10</span><br><span class="line">第二个参数为：20</span><br><span class="line">函数第一个入参：10</span><br><span class="line">函数第二个入参：20</span><br></pre></td></tr></table></figure>
<p>执行 <code>./variable-demo4.sh hello world</code> ，然后在脚本中通过 <code>$1</code>、<code>$2</code> … 读取第 1 个参数、第 2 个参数。。。</p>
<h3 id="8-2-函数处理参数"><a href="#8-2-函数处理参数" class="headerlink" title="8.2. 函数处理参数"></a>8.2. 函数处理参数</h3><p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>返回参数个数</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>返回所有参数</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>脚本运行的当前进程 ID 号</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>后台运行的最后一个进程的 ID 号</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>返回所有参数</td>
</tr>
<tr>
<td><code>$-</code></td>
<td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>函数返回值</td>
</tr>
</tbody>
</table>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo3.sh" target="_blank" rel="noopener">function-demo3.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">runner</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=zp</span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第一个入参：<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"函数第二个入参：<span class="variable">$2</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"传递到脚本的参数个数：<span class="variable">$#</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"$*"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"脚本运行的当前进程 ID 号：$$"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"后台运行的最后一个进程的 ID 号：$!"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数："</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"+ %s\n"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Shell 使用的当前选项：$-"</span></span><br><span class="line">  runner</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"runner 函数的返回值：$?"</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction 1 <span class="string">"abc"</span> <span class="string">"hello, \"zp\""</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  函数第一个入参：1</span></span><br><span class="line"><span class="comment">#  函数第二个入参：abc</span></span><br><span class="line"><span class="comment">#  传递到脚本的参数个数：3</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1 abc hello, "zp"</span></span><br><span class="line"><span class="comment">#  脚本运行的当前进程 ID 号：26400</span></span><br><span class="line"><span class="comment">#  后台运行的最后一个进程的 ID 号：</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1</span></span><br><span class="line"><span class="comment">#  + abc</span></span><br><span class="line"><span class="comment">#  + hello, "zp"</span></span><br><span class="line"><span class="comment">#  Shell 使用的当前选项：hB</span></span><br><span class="line"><span class="comment">#  runner 函数的返回值：0</span></span><br></pre></td></tr></table></figure>
<h2 id="9-Shell-扩展"><a href="#9-Shell-扩展" class="headerlink" title="9. Shell 扩展"></a>9. Shell 扩展</h2><p>_扩展_ 发生在一行命令被分成一个个的 <em>记号（tokens）</em> 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。</p>
<p>感兴趣的话可以阅读<a href="https://www.gnu.org/software/bash/manual/bash.html###Shell-Expansions" target="_blank" rel="noopener">关于 shell 扩展的更多细节</a>。</p>
<h4 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h4><p>大括号扩展让生成任意的字符串成为可能。它跟 <em>文件名扩展</em> 很类似，举个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> beg&#123;i,a,u&#125;n <span class="comment">### begin began begun</span></span><br></pre></td></tr></table></figure>
<p>大括号扩展还可以用来创建一个可被循环迭代的区间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;0..5&#125; <span class="comment">### 0 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">echo</span> &#123;00..8..2&#125; <span class="comment">### 00 02 04 06 08</span></span><br></pre></td></tr></table></figure>
<h4 id="命令置换"><a href="#命令置换" class="headerlink" title="命令置换"></a>命令置换</h4><p>命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被<code></code>或<code>$()</code>包围时，命令置换将会执行。举个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">now=`date +%T`</span><br><span class="line"><span class="comment">### or</span></span><br><span class="line">now=$(date +%T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$now</span> <span class="comment">### 19:08:26</span></span><br></pre></td></tr></table></figure>
<h4 id="算数扩展"><a href="#算数扩展" class="headerlink" title="算数扩展"></a>算数扩展</h4><p>在 bash 中，执行算数运算是非常方便的。算数表达式必须包在<code>$(( ))</code>中。算数扩展的格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result=$(( ((10 + 5*3) - 7) / 2 ))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span> <span class="comment">### 9</span></span><br></pre></td></tr></table></figure>
<p>在算数表达式中，使用变量无需带上<code>$</code>前缀：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=4</span><br><span class="line">y=7</span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 11</span></span><br><span class="line"><span class="built_in">echo</span> $(( ++x + y++ )) <span class="comment">### 12</span></span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 13</span></span><br></pre></td></tr></table></figure>
<h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Your home: <span class="variable">$HOME</span>"</span> <span class="comment">### Your home: /Users/&lt;username&gt;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Your home: $HOME'</span> <span class="comment">### Your home: $HOME</span></span><br></pre></td></tr></table></figure>
<p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INPUT=<span class="string">"A string  with   strange    whitespace."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$INPUT</span>   <span class="comment">### A string with strange whitespace.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$INPUT</span>"</span> <span class="comment">### A string  with   strange    whitespace.</span></span><br></pre></td></tr></table></figure>
<p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个\$INPUT 的值，包括其中的空格）。</p>
<p>来看一个更严肃的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE=<span class="string">"Favorite Things.txt"</span></span><br><span class="line">cat <span class="variable">$FILE</span>   <span class="comment">### 尝试输出两个文件: `Favorite` 和 `Things.txt`</span></span><br><span class="line">cat <span class="string">"<span class="variable">$FILE</span>"</span> <span class="comment">### 输出一个文件: `Favorite Things.txt`</span></span><br></pre></td></tr></table></figure>
<p>尽管这个问题可以通过把 FILE 重命名成<code>Favorite-Things.txt</code>来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（<code>find</code>, <code>cat</code>, 等等）呢。因此，如果输入 _可能_ 包含空格，务必要用引号把表达式包起来。</p>
<h2 id="10-流和重定向"><a href="#10-流和重定向" class="headerlink" title="10. 流和重定向"></a>10. 流和重定向</h2><p>Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。</p>
<p>管道给了我们创建传送带的机会，控制程序的执行成为可能。</p>
<p>学习如何使用这些强大的、高级的工具是非常非常重要的。</p>
<h3 id="10-1-输入、输出流"><a href="#10-1-输入、输出流" class="headerlink" title="10.1. 输入、输出流"></a>10.1. 输入、输出流</h3><p>Bash 接收输入，并以字符序列或 <strong>字符流</strong> 的形式产生输出。这些流能被重定向到文件或另一个流中。</p>
<p>有三个文件描述符：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>描述符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>stdin</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>stdout</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>stderr</code></td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>
<h3 id="10-2-重定向"><a href="#10-2-重定向" class="headerlink" title="10.2. 重定向"></a>10.2. 重定向</h3><p>重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>重定向输出</td>
</tr>
<tr>
<td><code>&amp;&gt;</code></td>
<td>重定向输出和错误输出</td>
</tr>
<tr>
<td><code>&amp;&gt;&gt;</code></td>
<td>以附加的形式重定向输出和错误输出</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>重定向输入</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td><a href="http://tldp.org/LDP/abs/html/here-docs.html" target="_blank" rel="noopener">Here 文档</a> 语法</td>
</tr>
<tr>
<td><code>&lt;&lt;&lt;</code></td>
<td><a href="http://www.tldp.org/LDP/abs/html/x17837.html" target="_blank" rel="noopener">Here 字符串</a></td>
</tr>
</tbody>
</table>
<p>以下是一些使用重定向的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### ls的结果将会被写到list.txt中</span></span><br><span class="line">ls -l &gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 将输出附加到list.txt中</span></span><br><span class="line">ls -a &gt;&gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 所有的错误信息会被写到errors.txt中</span></span><br><span class="line">grep da * 2&gt; errors.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从errors.txt中读取输入</span></span><br><span class="line">less &lt; errors.txt</span><br></pre></td></tr></table></figure>
<h3 id="10-3-dev-null-文件"><a href="#10-3-dev-null-文件" class="headerlink" title="10.3. /dev/null 文件"></a>10.3. <code>/dev/null</code> 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<h2 id="11-Debug"><a href="#11-Debug" class="headerlink" title="11. Debug"></a>11. Debug</h2><p>shell 提供了用于 debug 脚本的工具。</p>
<p>如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash options</span><br></pre></td></tr></table></figure>
<p>options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：</p>
<table>
<thead>
<tr>
<th>Short</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-f</code></td>
<td>noglob</td>
<td>禁止文件名展开（globbing）</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>interactive</td>
<td>让脚本以 _交互_ 模式运行</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>noexec</td>
<td>读取命令，但不执行（语法检查）</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>—</td>
<td>执行完第一条命令后退出</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>verbose</td>
<td>在执行每条命令前，向<code>stderr</code>输出该命令</td>
</tr>
<tr>
<td><code>-x</code></td>
<td>xtrace</td>
<td>在执行每条命令前，向<code>stderr</code>输出该命令以及该命令的扩展参数</td>
</tr>
</tbody>
</table>
<p>举个例子，如果我们在脚本中指定了<code>-x</code>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这会向<code>stdout</code>打印出变量的值和一些其它有用的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">+ (( i = 0 ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 0</span><br><span class="line">0</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 1</span><br><span class="line">1</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ <span class="built_in">echo</span> 2</span><br><span class="line">2</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br></pre></td></tr></table></figure>
<p>有时我们值需要 debug 脚本的一部分。这种情况下，使用<code>set</code>命令会很方便。这个命令可以启用或禁用选项。使用<code>-</code>启用选项，<code>+</code>禁用选项：</p>
<p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/debug-demo.sh" target="_blank" rel="noopener">debug-demo.sh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启 debug</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; 3; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 关闭 debug</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  + (( i = 0 ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 0</span></span><br><span class="line"><span class="comment">#  0+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 1</span></span><br><span class="line"><span class="comment">#  1+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 2</span></span><br><span class="line"><span class="comment">#  2+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + set +x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span>; <span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\n"</span></span><br><span class="line"><span class="comment">#  Output: 12345</span></span><br></pre></td></tr></table></figure>
<h2 id="12-更多内容"><a href="#12-更多内容" class="headerlink" title="12. 更多内容"></a>12. 更多内容</h2><blockquote>
<p>:notebook: 本文已归档到：「<a href="https://github.com/dunwu/notes" target="_blank" rel="noopener">notes</a>」</p>
</blockquote>
<ul>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">awesome-shell</a>，shell 资源列表</li>
<li><a href="https://github.com/awesome-lists/awesome-bash" target="_blank" rel="noopener">awesome-bash</a>，bash 资源列表</li>
<li><a href="https://github.com/denysdovhan/bash-handbook" target="_blank" rel="noopener">bash-handbook</a></li>
<li><a href="https://github.com/vuuihc/bash-guide" target="_blank" rel="noopener">bash-guide</a> ，bash 基本用法指南</li>
<li><a href="https://github.com/Bash-it/bash-it" target="_blank" rel="noopener">bash-it</a>，为你日常使用，开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架</li>
<li><a href="http://dotfiles.github.io/" target="_blank" rel="noopener">dotfiles.github.io</a>，上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接</li>
<li><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Runoob Shell 教程</a></li>
<li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">shellcheck</a> 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
</ul>
<p>最后，Stack Overflow 上 <a href="https://stackoverflow.com/questions/tagged/bash" target="_blank" rel="noopener">bash 标签下</a>有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/database/sql/关系型数据库基本原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/database/sql/关系型数据库基本原理/" itemprop="url">关系型数据库基本原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关系型数据库基本原理"><a href="#关系型数据库基本原理" class="headerlink" title="关系型数据库基本原理"></a>关系型数据库基本原理</h1><blockquote>
<p>本文所述内容主要针对的是关系型数据库，nosql 数据库并不适用。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-索引">1. 索引</a><ul>
<li><a href="#11-索引的优点和缺点">1.1. 索引的优点和缺点</a></li>
<li><a href="#12-索引类型">1.2. 索引类型</a></li>
<li><a href="#13-索引数据结构">1.3. 索引数据结构</a></li>
<li><a href="#14-索引原则">1.4. 索引原则</a></li>
</ul>
</li>
<li><a href="#2-事务">2. 事务</a><ul>
<li><a href="#21-acid">2.1. ACID</a></li>
<li><a href="#22-并发一致性问题">2.2. 并发一致性问题</a></li>
<li><a href="#23-事务隔离级别">2.3. 事务隔离级别</a></li>
<li><a href="#24-死锁">2.4. 死锁</a></li>
</ul>
</li>
<li><a href="#3-并发控制">3. 并发控制</a><ul>
<li><a href="#31-锁粒度">3.1. 锁粒度</a></li>
<li><a href="#32-数据库锁的类型">3.2. 数据库锁的类型</a></li>
<li><a href="#33-数据库锁的协议">3.3. 数据库锁的协议</a></li>
</ul>
</li>
<li><a href="#4-多版本并发控制">4. 多版本并发控制</a><ul>
<li><a href="#41-版本号">4.1. 版本号</a></li>
<li><a href="#42-undo-日志">4.2. Undo 日志</a></li>
<li><a href="#43-实现过程">4.3. 实现过程</a></li>
<li><a href="#44-快照读与当前读">4.4. 快照读与当前读</a></li>
</ul>
</li>
<li><a href="#5-分库分表">5. 分库分表</a><ul>
<li><a href="#51-水平拆分">5.1. 水平拆分</a></li>
<li><a href="#52-垂直拆分">5.2. 垂直拆分</a></li>
<li><a href="#53-sharding-策略">5.3. Sharding 策略</a></li>
<li><a href="#54-分库分表的问题及解决方案">5.4. 分库分表的问题及解决方案</a></li>
<li><a href="#55-常用的分库分表中间件">5.5. 常用的分库分表中间件</a></li>
</ul>
</li>
<li><a href="#6-sql-优化">6. sql 优化</a><ul>
<li><a href="#61-使用执行计划进行分析">6.1. 使用执行计划进行分析</a></li>
<li><a href="#62-优化数据访问">6.2. 优化数据访问</a></li>
<li><a href="#63-重构查询方式">6.3. 重构查询方式</a></li>
</ul>
</li>
<li><a href="#7-关系数据库设计理论">7. 关系数据库设计理论</a><ul>
<li><a href="#71-函数依赖">7.1. 函数依赖</a></li>
<li><a href="#72-异常">7.2. 异常</a></li>
<li><a href="#73-范式">7.3. 范式</a></li>
</ul>
</li>
<li><a href="#8-er-图">8. ER 图</a><ul>
<li><a href="#81-实体的三种联系">8.1. 实体的三种联系</a></li>
<li><a href="#82-表示出现多次的关系">8.2. 表示出现多次的关系</a></li>
<li><a href="#83-联系的多向性">8.3. 联系的多向性</a></li>
<li><a href="#84-表示子类">8.4. 表示子类</a></li>
</ul>
</li>
<li><a href="#9-资料">9. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h2><p>索引能够轻易将查询性能提升几个数量级。</p>
<ul>
<li>数据量小的表，使用全表扫描比建立索引更高效。</li>
<li>数据量大的表，使用索引更高效。</li>
<li>数据量特大的表，建立和维护索引的代价将会随之增长，可以使用分区技术。</li>
</ul>
<h3 id="1-1-索引的优点和缺点"><a href="#1-1-索引的优点和缺点" class="headerlink" title="1.1. 索引的优点和缺点"></a>1.1. 索引的优点和缺点</h3><p>优点：</p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机 I/O 变为顺序 I/O。</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h3 id="1-2-索引类型"><a href="#1-2-索引类型" class="headerlink" title="1.2. 索引类型"></a>1.2. 索引类型</h3><p>主流的关系型数据库一般都支持以下索引类型：</p>
<ul>
<li>普通索引：最基本的索引，没有任何限制。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>
<li>主键索引：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</li>
<li>组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</li>
</ul>
<h3 id="1-3-索引数据结构"><a href="#1-3-索引数据结构" class="headerlink" title="1.3. 索引数据结构"></a>1.3. 索引数据结构</h3><p><strong>主流数据库的索引一般使用的数据结构为：B-Tree 或 B+Tree。</strong></p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>B-Tree 不同于 Binary Tree（二叉树，最多有两个子树），它是平衡搜索树。</p>
<p>一棵 M 阶的 B-Tree 满足以下条件：</p>
<ul>
<li>每个结点至多有 M 个孩子；</li>
<li>除根结点和叶结点外，其它每个结点至少有 M/2 个孩子；</li>
<li>根结点至少有两个孩子（除非该树仅包含一个结点）；</li>
<li>所有叶结点在同一层，叶结点不包含任何关键字信息；</li>
<li>有 K 个关键字的非叶结点恰好包含 K+1 个孩子；</li>
</ul>
<p>对于任意结点，其内部的关键字 Key 是升序排列的。每个节点中都包含了 data。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/B-TREE.png"><br></div>

<p>对于每个结点，主要包含一个关键字数组 Key[]，一个指针数组（指向儿子）Son[]。</p>
<p>在 B-Tree 内，查找的流程是：</p>
<ol>
<li>使用顺序查找（数组长度较短时）或折半查找方法查找 Key[]数组，若找到关键字 K，则返回该结点的地址及 K 在 Key[]中的位置；</li>
<li>否则，可确定 K 在某个 Key[i]和 Key[i+1]之间，则从 Son[i]所指的子结点继续查找，直到在某结点中查找成功；</li>
<li>或直至找到叶结点且叶结点中的查找仍不成功时，查找过程失败。</li>
</ol>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B+Tree 是 B-Tree 的变种：</p>
<ul>
<li>每个节点的指针上限为 2d 而不是 2d+1（d 为节点的出度）。</li>
<li>非叶子节点不存储 data，只存储 key；叶子节点不存储指针。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/B+TREE.png"><br></div>

<p>由于并不是所有节点都具有相同的域，因此 B+Tree 中叶节点和内节点一般大小不同。这点与 B-Tree 不同，虽然 B-Tree 中不同节点存放的 key 和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中 B-Tree 往往对每个节点申请同等大小的空间。</p>
<h5 id="带有顺序访问指针的-B-Tree"><a href="#带有顺序访问指针的-B-Tree" class="headerlink" title="带有顺序访问指针的 B+Tree"></a>带有顺序访问指针的 B+Tree</h5><p>一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 的基础上进行了优化，增加了顺序访问指针。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/带有顺序访问指针的B+Tree.png"><br></div>

<p>在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree。</p>
<p>这个优化的目的是为了提高区间访问的性能，例如上图中如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Hash 索引只有精确匹配索引所有列的查询才有效。</p>
<p>对于每一行数据，对所有的索引列计算一个 hashcode。哈希索引将所有的 hashcode 存储在索引中，同时在 Hash 表中保存指向每个数据行的指针。</p>
<p>哈希索引的优点：</p>
<ul>
<li>因为索引数据结构紧凑，所以查询速度非常快。</li>
</ul>
<p>哈希索引的缺点：</p>
<ul>
<li>哈希索引数据不是按照索引值顺序存储的，所以无法用于排序。</li>
<li>哈希索引不支持部分索引匹配查找。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li>哈希索引只支持等值比较查询，不支持任何范围查询，如 WHERE price &gt; 100。</li>
<li>哈希索引有可能出现哈希冲突，出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
</ul>
<h3 id="1-4-索引原则"><a href="#1-4-索引原则" class="headerlink" title="1.4. 索引原则"></a>1.4. 索引原则</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>如果查询中的列不是独立的列，则数据库不会使用索引。</p>
<p>“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。</p>
<p>:x: 错误示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(CURRENT_DAT) - <span class="keyword">TO_DAYS</span>(date_col) &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>有时候需要索引很长的字符列，这会让索引变得大且慢。</p>
<p>解决方法是：可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。</p>
<p>索引的选择性是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<p>对于 BLOB/TEXT/VARCHAR 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p>
<p>要选择足够长的前缀以保证较高的选择性，同时又不能太长（节约空间）。</p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>不要为每个列创建独立的索引。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>经验法则：将选择性高的列或基数大的列优先排在多列索引最前列。</p>
<p>但有时，也需要考虑 WHERE 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>聚簇表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>索引最好既满足排序，又用于查找行。这样，就可以使用索引来对结果排序。</p>
<h4 id="和-in-可以乱序"><a href="#和-in-可以乱序" class="headerlink" title="= 和 in 可以乱序"></a>= 和 in 可以乱序</h4><p>比如 a = 1 and b = 2 and c = 3 建立（a,b,c）索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。</p>
<h4 id="尽量的扩展索引，不要新建索引"><a href="#尽量的扩展索引，不要新建索引" class="headerlink" title="尽量的扩展索引，不要新建索引"></a>尽量的扩展索引，不要新建索引</h4><p>比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2. 事务"></a>2. 事务</h2><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库事务.png"><br></div>

<p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<h3 id="2-1-ACID"><a href="#2-1-ACID" class="headerlink" title="2.1. ACID"></a>2.1. ACID</h3><h4 id="原子性（Automicity）"><a href="#原子性（Automicity）" class="headerlink" title="原子性（Automicity）"></a>原子性（Automicity）</h4><p>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。</p>
<p>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</p>
<h4 id="ACID-小结"><a href="#ACID-小结" class="headerlink" title="ACID 小结"></a>ACID 小结</h4><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库奔溃的情况。</li>
</ul>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库ACID.png"><br></div>

<h3 id="2-2-并发一致性问题"><a href="#2-2-并发一致性问题" class="headerlink" title="2.2. 并发一致性问题"></a>2.2. 并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-丢失修改.png"><br></div>

<h4 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h4><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-脏数据.png"><br></div>

<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-不可重复读.png"><br></div>

<h4 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h4><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库并发一致性-幻读.png"><br></div>

<h4 id="并发一致性解决方案"><a href="#并发一致性解决方案" class="headerlink" title="并发一致性解决方案"></a>并发一致性解决方案</h4><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p>
<p>并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h3 id="2-3-事务隔离级别"><a href="#2-3-事务隔离级别" class="headerlink" title="2.3. 事务隔离级别"></a>2.3. 事务隔离级别</h3><ul>
<li>未提交读（READ UNCOMMITTED） - 事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>提交读（READ COMMITTED） - 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li>可重复读（REPEATABLE READ） - 保证在同一个事务中多次读取同样数据的结果是一样的。</li>
<li>可串行化（SERIALIXABLE） - 强制事务串行执行。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">提交读</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">可串行化</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
</tbody>
</table>
<h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4. 死锁"></a>2.4. 死锁</h3><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定一个资源时，也会产生死锁。</p>
<h2 id="3-并发控制"><a href="#3-并发控制" class="headerlink" title="3. 并发控制"></a>3. 并发控制</h2><p>无论何时，只要有多个查询需要在同一时刻修改数据，就会产生并发控制的问题。</p>
<h3 id="3-1-锁粒度"><a href="#3-1-锁粒度" class="headerlink" title="3.1. 锁粒度"></a>3.1. 锁粒度</h3><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</p>
<p>但是加锁需要消耗资源，锁的各种操作，包括获取锁、释放锁、以及检查锁状态等，都会增加系统开销。因此锁粒度越小，系统开销就越大。</p>
<p>所谓锁策略，就是在锁的开销和并发程度之间寻求平衡，这种平衡自然也会影响到性能。</p>
<p>很多数据库都提供了表级锁和行级锁。</p>
<ul>
<li><strong>表级锁（table lock）</strong> - 锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。</li>
<li><strong>行级锁（row lock）</strong> - 仅对指定的行记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。</li>
</ul>
<h3 id="3-2-数据库锁的类型"><a href="#3-2-数据库锁的类型" class="headerlink" title="3.2. 数据库锁的类型"></a>3.2. 数据库锁的类型</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">S</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">IX</th>
<th style="text-align:center">S</th>
<th style="text-align:center">IS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">IX</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">IS</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h3 id="3-3-数据库锁的协议"><a href="#3-3-数据库锁的协议" class="headerlink" title="3.3. 数据库锁的协议"></a>3.3. 数据库锁的协议</h3><h4 id="三级锁协议"><a href="#三级锁协议" class="headerlink" title="三级锁协议"></a>三级锁协议</h4><p><strong>一级锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=21</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-x(A)</td>
</tr>
</tbody>
</table>
<p><strong>二级锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-s(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">rollback</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-s(A)</td>
</tr>
</tbody>
</table>
<p><strong>三级锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-s(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-s(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-X(A)</td>
</tr>
</tbody>
</table>
<h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>
<h2 id="4-多版本并发控制"><a href="#4-多版本并发控制" class="headerlink" title="4. 多版本并发控制"></a>4. 多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是实现隔离级别的一种具体方式。</p>
<p>Mysql、Oracle、PostgreSQL 等数据库都实现了 MVCC，但各自的实现机制不尽相同。</p>
<p>MVCC 用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p>MVCC 可以视为行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。</p>
<p>MVCC 的实现，是通过保存数据在某个时间的快照来实现的。</p>
<h3 id="4-1-版本号"><a href="#4-1-版本号" class="headerlink" title="4.1. 版本号"></a>4.1. 版本号</h3><ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<h3 id="4-2-Undo-日志"><a href="#4-2-Undo-日志" class="headerlink" title="4.2. Undo 日志"></a>4.2. Undo 日志</h3><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<h3 id="4-3-实现过程"><a href="#4-3-实现过程" class="headerlink" title="4.3. 实现过程"></a>4.3. 实现过程</h3><p>以下实现过程针对可重复读隔离级别。</p>
<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p>
<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。</p>
<p>除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p>将当前系统版本号作为数据行快照的创建版本号。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_insert.png"><br></div>

<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>将当前系统版本号作为数据行快照的删除版本号。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_delete.png"><br></div>

<h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>将当前系统版本号作为更新后的数据行快照的创建版本号，同时将当前系统版本号作为更新前的数据行快照的删除版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/mvcc_update.png"><br></div>

<h3 id="4-4-快照读与当前读"><a href="#4-4-快照读与当前读" class="headerlink" title="4.4. 快照读与当前读"></a>4.4. 快照读与当前读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-分库分表"><a href="#5-分库分表" class="headerlink" title="5. 分库分表"></a>5. 分库分表</h2><p>分库分表的基本思想就要把一个数据库切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。</p>
<p>当然，现实中更多是这两种情况混杂在一起，这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列。</p>
<h3 id="5-1-水平拆分"><a href="#5-1-水平拆分" class="headerlink" title="5.1. 水平拆分"></a>5.1. 水平拆分</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库水平拆分.jpg" width="500"><br></div>

<p>对于海量数据的数据库，如果表并不多，但每张表的数据非常多，这时候适合水平切分，即把表的数据按某种规则（比如按 ID 散列）切分到多个数据库(server)上。</p>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<h3 id="5-2-垂直拆分"><a href="#5-2-垂直拆分" class="headerlink" title="5.2. 垂直拆分"></a>5.2. 垂直拆分</h3><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库垂直拆分.jpg" width="500"><br></div>

<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个 server 上。</p>
<h3 id="5-3-Sharding-策略"><a href="#5-3-Sharding-策略" class="headerlink" title="5.3. Sharding 策略"></a>5.3. Sharding 策略</h3><ul>
<li>哈希取模：hash(key) % NUM_DB</li>
<li>范围：可以是 ID 范围也可以是时间范围</li>
<li>映射表：使用单独的一个数据库来存储映射关系</li>
</ul>
<h3 id="5-4-分库分表的问题及解决方案"><a href="#5-4-分库分表的问题及解决方案" class="headerlink" title="5.4. 分库分表的问题及解决方案"></a>5.4. 分库分表的问题及解决方案</h3><h4 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h4><p>方案一：使用分布式事务</p>
<ul>
<li>优点：交由数据库管理，简单有效</li>
<li>缺点：性能代价高，特别是 shard 越来越多时</li>
</ul>
<p>方案二：由应用程序和数据库共同控制</p>
<ul>
<li>原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。</li>
<li>优点：性能上有优势</li>
<li>缺点：需要应用程序在事务控制上做灵活设计。如果使用了 spring 的事务管理，改动起来会面临一定的困难。</li>
</ul>
<h4 id="跨节点-Join-的问题"><a href="#跨节点-Join-的问题" class="headerlink" title="跨节点 Join 的问题"></a>跨节点 Join 的问题</h4><p>只要是进行切分，跨节点 Join 的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的 id，根据这些 id 发起第二次请求得到关联数据。</p>
<h4 id="跨节点的-count-order-by-group-by-以及聚合函数问题"><a href="#跨节点的-count-order-by-group-by-以及聚合函数问题" class="headerlink" title="跨节点的 count,order by,group by 以及聚合函数问题"></a>跨节点的 count,order by,group by 以及聚合函数问题</h4><p>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。</p>
<p>解决方案：与解决跨节点 join 问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和 join 不同的是每个节点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
<h4 id="ID-唯一性"><a href="#ID-唯一性" class="headerlink" title="ID 唯一性"></a>ID 唯一性</h4><p>一旦数据库被切分到多个物理节点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID，以便进行 SQL 路由。</p>
<p>一些常见的主键生成策略：</p>
<ul>
<li>使用全局唯一 ID：GUID。</li>
<li>为每个分片指定一个 ID 范围。</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)。</li>
</ul>
<h4 id="数据迁移，容量规划，扩容等问题"><a href="#数据迁移，容量规划，扩容等问题" class="headerlink" title="数据迁移，容量规划，扩容等问题"></a>数据迁移，容量规划，扩容等问题</h4><p>来自淘宝综合业务平台团队，它利用对 2 的倍数取余具有向前兼容的特性（如对 4 取余得 1 的数对 2 取余也是 1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了 Sharding 扩容的难度。</p>
<h4 id="分库数量"><a href="#分库数量" class="headerlink" title="分库数量"></a>分库数量</h4><p>分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。</p>
<h4 id="跨分片的排序分页"><a href="#跨分片的排序分页" class="headerlink" title="跨分片的排序分页"></a>跨分片的排序分页</h4><ul>
<li>如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</li>
<li>如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</li>
<li>分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</li>
</ul>
<h3 id="5-5-常用的分库分表中间件"><a href="#5-5-常用的分库分表中间件" class="headerlink" title="5.5. 常用的分库分表中间件"></a>5.5. 常用的分库分表中间件</h3><h4 id="简单易用的组件："><a href="#简单易用的组件：" class="headerlink" title="简单易用的组件："></a>简单易用的组件：</h4><ul>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="noopener">当当 sharding-jdbc</a></li>
<li><a href="https://github.com/baihui212/tsharding" target="_blank" rel="noopener">蘑菇街 TSharding</a></li>
</ul>
<h4 id="强悍重量级的中间件："><a href="#强悍重量级的中间件：" class="headerlink" title="强悍重量级的中间件："></a>强悍重量级的中间件：</h4><ul>
<li><a href="https://github.com/go-pg/sharding" target="_blank" rel="noopener">sharding </a></li>
<li><a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">TDDL Smart Client 的方式（淘宝）</a></li>
<li><a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">Atlas(Qihoo 360)</a></li>
<li><a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">alibaba.cobar(是阿里巴巴（B2B）部门开发)</a></li>
<li><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">MyCAT（基于阿里开源的 Cobar 产品而研发）</a></li>
<li><a href="https://github.com/58code/Oceanus" target="_blank" rel="noopener">Oceanus(58 同城数据库中间件)</a></li>
<li><a href="http://www.cnblogs.com/youge-OneSQL/articles/4208583.html" target="_blank" rel="noopener">OneProxy(支付宝首席架构师楼方鑫开发)</a></li>
<li><a href="https://github.com/youtube/vitess" target="_blank" rel="noopener">vitess（谷歌开发的数据库中间件）</a></li>
</ul>
<h2 id="6-sql-优化"><a href="#6-sql-优化" class="headerlink" title="6. sql 优化"></a>6. sql 优化</h2><h3 id="6-1-使用执行计划进行分析"><a href="#6-1-使用执行计划进行分析" class="headerlink" title="6.1. 使用执行计划进行分析"></a>6.1. 使用执行计划进行分析</h3><p>执行计划 Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<p>更多内容请参考：<a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p>
<h3 id="6-2-优化数据访问"><a href="#6-2-优化数据访问" class="headerlink" title="6.2. 优化数据访问"></a>6.2. 优化数据访问</h3><h4 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h4><p>（一）只返回必要的列</p>
<p>最好不要使用 SELECT * 语句。</p>
<p>（二）只返回必要的行</p>
<p>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。</p>
<p>（三）缓存重复查询的数据</p>
<p>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。</p>
<h4 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p>
<h3 id="6-3-重构查询方式"><a href="#6-3-重构查询方式" class="headerlink" title="6.3. 重构查询方式"></a>6.3. 重构查询方式</h3><h4 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h4><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected &gt; 0</span><br></pre></td></tr></table></figure>
<h4 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h4><p>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class="line">JOIN post ON tag_post.post_id=post.id</span><br><span class="line">WHERE tag.tag=&apos;mysql&apos;;</span><br><span class="line">SELECT * FROM tag WHERE tag=&apos;mysql&apos;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class="line">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>
<h2 id="7-关系数据库设计理论"><a href="#7-关系数据库设计理论" class="headerlink" title="7. 关系数据库设计理论"></a>7. 关系数据库设计理论</h2><h3 id="7-1-函数依赖"><a href="#7-1-函数依赖" class="headerlink" title="7.1. 函数依赖"></a>7.1. 函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖；</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递依赖。</p>
<h3 id="7-2-异常"><a href="#7-2-异常" class="headerlink" title="7.2. 异常"></a>7.2. 异常</h3><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 学生-2 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li>
<li>插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h3 id="7-3-范式"><a href="#7-3-范式" class="headerlink" title="7.3. 范式"></a>7.3. 范式</h3><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/images/master/images/database/RDB/数据库范式.png"><br></div>

<h4 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 (1NF)"></a>第一范式 (1NF)</h4><p>属性不可分；</p>
<h4 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 (2NF)"></a>第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><font size="4"> <strong>分解前</strong> </font><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><font size="4"> <strong>分解后</strong> </font><br></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept, Mname</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade</li>
</ul>
<h4 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 (3NF)"></a>第三范式 (3NF)</h4><p>非主属性不传递依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<h2 id="8-ER-图"><a href="#8-ER-图" class="headerlink" title="8. ER 图"></a>8. ER 图</h2><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h3 id="8-1-实体的三种联系"><a href="#8-1-实体的三种联系" class="headerlink" title="8.1. 实体的三种联系"></a>8.1. 实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p>
<p>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。</p>
<h3 id="8-2-表示出现多次的关系"><a href="#8-2-表示出现多次的关系" class="headerlink" title="8.2. 表示出现多次的关系"></a>8.2. 表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<h3 id="8-3-联系的多向性"><a href="#8-3-联系的多向性" class="headerlink" title="8.3. 联系的多向性"></a>8.3. 联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<p>一般只使用二元联系，可以把多元关系转换为二元关系。</p>
<h3 id="8-4-表示子类"><a href="#8-4-表示子类" class="headerlink" title="8.4. 表示子类"></a>8.4. 表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<h2 id="9-资料"><a href="#9-资料" class="headerlink" title="9. 资料"></a>9. 资料</h2><ul>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/数据库系统原理.md" target="_blank" rel="noopener">数据库系统原理</a></li>
<li><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">分库分表需要考虑的问题及方案</a></li>
<li><a href="https://blog.csdn.net/bluishglc/article/details/7710738" target="_blank" rel="noopener">数据库分库分表(sharding)系列(二) 全局主键生成策略</a></li>
<li><a href="https://blog.csdn.net/bluishglc/article/details/7970268" target="_blank" rel="noopener">一种支持自由规划无须数据迁移和修改路由代码的 Sharding 扩容方案</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/os/linux/ops/service/gitlab/gitlab-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/os/linux/ops/service/gitlab/gitlab-install/" itemprop="url">Gitlab 安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Gitlab-安装"><a href="#Gitlab-安装" class="headerlink" title="Gitlab 安装"></a>Gitlab 安装</h1><blockquote>
<p>环境：</p>
<p>OS: CentOS7</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#安装-gitlab">安装 gitlab</a><ul>
<li><a href="#常规安装-gitlab">常规安装 gitlab</a></li>
<li><a href="#docker-安装-gitlab">Docker 安装 gitlab</a></li>
</ul>
</li>
<li><a href="#安装-gitlab-ci-multi-runner">安装 gitlab-ci-multi-runner</a><ul>
<li><a href="#常规安装-gitlab-ci-multi-runner">常规安装 gitlab-ci-multi-runner</a></li>
<li><a href="#docker-安装-gitlab-ci-multi-runner">Docker 安装 gitlab-ci-multi-runner</a></li>
</ul>
</li>
<li><a href="#自签名证书">自签名证书</a><ul>
<li><a href="#创建证书">创建证书</a></li>
</ul>
</li>
<li><a href="#gitlab-配置">gitlab 配置</a></li>
<li><a href="#更多内容">更多内容</a></li>
</ul>
<!-- /TOC -->
<h2 id="安装-gitlab"><a href="#安装-gitlab" class="headerlink" title="安装 gitlab"></a>安装 gitlab</h2><h3 id="常规安装-gitlab"><a href="#常规安装-gitlab" class="headerlink" title="常规安装 gitlab"></a>常规安装 gitlab</h3><p>进入官方下载地址：<a href="https://about.gitlab.com/install/" target="_blank" rel="noopener">https://about.gitlab.com/install/</a> ，如下图，选择合适的版本。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20190129155838.png"></div><br></p>
<p>以 CentOS7 为例：</p>
<h4 id="安装和配置必要依赖"><a href="#安装和配置必要依赖" class="headerlink" title="安装和配置必要依赖"></a>安装和配置必要依赖</h4><p>在系统防火墙中启用 HTTP 和 SSH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server</span><br><span class="line">sudo systemctl enable sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure>
<p>安装 Postfix ，使得 Gitlab 可以发送通知邮件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postfix</span><br><span class="line">sudo systemctl enable postfix</span><br><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure>
<h4 id="添加-Gitlab-yum-仓库并安装包"><a href="#添加-Gitlab-yum-仓库并安装包" class="headerlink" title="添加 Gitlab yum 仓库并安装包"></a>添加 Gitlab yum 仓库并安装包</h4><p>添加 Gitlab yum 仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure>
<p>通过 yum 安装 gitlab-ce</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum install -y gitlab-ce</span><br></pre></td></tr></table></figure>
<p>安装完成后，即可通过默认的 root 账户进行登录。更多细节可以参考：<a href="https://docs.gitlab.com/omnibus/README.html#installation-and-configuration-using-omnibus-package" target="_blank" rel="noopener">documentation for detailed instructions on installing and configuration</a></p>
<h3 id="Docker-安装-gitlab"><a href="#Docker-安装-gitlab" class="headerlink" title="Docker 安装 gitlab"></a>Docker 安装 gitlab</h3><p>拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --hostname gitlab.zp.io \</span><br><span class="line">    --publish 8443:443 --publish 80:80 --publish 2222:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    --volume $GITLAB_HOME/config:/etc/gitlab \</span><br><span class="line">    --volume $GITLAB_HOME/logs:/var/log/gitlab \</span><br><span class="line">    --volume $GITLAB_HOME/data:/var/opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20190131150515.png"></div><br></p>
<h2 id="安装-gitlab-ci-multi-runner"><a href="#安装-gitlab-ci-multi-runner" class="headerlink" title="安装 gitlab-ci-multi-runner"></a>安装 gitlab-ci-multi-runner</h2><blockquote>
<p>参考：<a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">https://docs.gitlab.com/runner/install/</a></p>
</blockquote>
<h3 id="常规安装-gitlab-ci-multi-runner"><a href="#常规安装-gitlab-ci-multi-runner" class="headerlink" title="常规安装 gitlab-ci-multi-runner"></a>常规安装 gitlab-ci-multi-runner</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</span><br></pre></td></tr></table></figure>
<h4 id="配置执行权限"><a href="#配置执行权限" class="headerlink" title="配置执行权限"></a>配置执行权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/gitlab-runner</span><br></pre></td></tr></table></figure>
<h4 id="如果想使用-Docker，安装-Docker（可选的）"><a href="#如果想使用-Docker，安装-Docker（可选的）" class="headerlink" title="如果想使用 Docker，安装 Docker（可选的）"></a>如果想使用 Docker，安装 Docker（可选的）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>
<h4 id="创建-CI-用户"><a href="#创建-CI-用户" class="headerlink" title="创建 CI 用户"></a>创建 CI 用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd --comment &apos;GitLab Runner&apos; --create-home gitlab-runner --shell /bin/bash</span><br></pre></td></tr></table></figure>
<h4 id="安装并启动服务"><a href="#安装并启动服务" class="headerlink" title="安装并启动服务"></a>安装并启动服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner</span><br><span class="line">sudo gitlab-runner start</span><br></pre></td></tr></table></figure>
<h4 id="注册-Runner"><a href="#注册-Runner" class="headerlink" title="注册 Runner"></a>注册 Runner</h4><p>（1）执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner register</span><br></pre></td></tr></table></figure>
<p>（2）输入 Gitlab URL 和 令牌</p>
<p>URL 和令牌信息在 Gitlab 的 Runner 管理页面获取：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20190129163100.png"></div><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://gitlab.com</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci token for this runner</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>
<p>（3）输入 Runner 的描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci description for this runner</span><br><span class="line">[hostame] my-runner</span><br></pre></td></tr></table></figure>
<p>（4）输入 Runner 相关的标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci tags for this runner (comma separated):</span><br><span class="line">my-tag,another-tag</span><br></pre></td></tr></table></figure>
<p>（5）输入 Runner 执行器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</span><br><span class="line">docker</span><br></pre></td></tr></table></figure>
<p>如果想选择 Docker 作为执行器，你需要指定默认镜像（ <code>.gitlab-ci.yml</code> 中没有此配置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">alpine:latest</span><br></pre></td></tr></table></figure>
<h3 id="Docker-安装-gitlab-ci-multi-runner"><a href="#Docker-安装-gitlab-ci-multi-runner" class="headerlink" title="Docker 安装 gitlab-ci-multi-runner"></a>Docker 安装 gitlab-ci-multi-runner</h3><p>拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/gitlab/gitlab-runner</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">   -v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">   gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure>
<h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>首先，创建认证目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/gitlab/ssl</span><br><span class="line">sudo chmod 700 /etc/gitlab/ssl</span><br></pre></td></tr></table></figure>
<h3 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h3><h4 id="创建-Private-Key"><a href="#创建-Private-Key" class="headerlink" title="创建 Private Key"></a>创建 Private Key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openssl genrsa -des3 -out /etc/gitlab/ssl/gitlab.domain.com.key 2048</span><br></pre></td></tr></table></figure>
<p>会提示输入密码，请记住</p>
<h4 id="生成-Certificate-Request"><a href="#生成-Certificate-Request" class="headerlink" title="生成 Certificate Request"></a>生成 Certificate Request</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openssl req -new -key /etc/gitlab/ssl/gitlab.domain.com.key -out /etc/gitlab/ssl/gitlab.domain.com.csr</span><br></pre></td></tr></table></figure>
<p>根据提示，输入信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:JS</span><br><span class="line">Locality Name (eg, city) [Default City]:NJ</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:xxxxx</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (eg, your name or your server&apos;s hostname) []:gitlab.xxxx.io</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br><span class="line">Please enter the following &apos;extra&apos; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br></pre></td></tr></table></figure>
<h4 id="移除-Private-Key-中的密码短语"><a href="#移除-Private-Key-中的密码短语" class="headerlink" title="移除 Private Key 中的密码短语"></a>移除 Private Key 中的密码短语</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -v /etc/gitlab/ssl/gitlab.domain.com.&#123;key,original&#125;</span><br><span class="line">sudo openssl rsa -in /etc/gitlab/ssl/gitlab.domain.com.original -out /etc/gitlab/ssl/gitlab.domain.com.key</span><br><span class="line">sudo rm -v /etc/gitlab/ssl/gitlab.domain.com.original</span><br></pre></td></tr></table></figure>
<h4 id="创建证书-1"><a href="#创建证书-1" class="headerlink" title="创建证书"></a>创建证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openssl x509 -req -days 1460 -in /etc/gitlab/ssl/gitlab.domain.com.csr -signkey /etc/gitlab/ssl/gitlab.domain.com.key -out /etc/gitlab/ssl/gitlab.domain.com.crt</span><br></pre></td></tr></table></figure>
<h4 id="移除证书请求文件"><a href="#移除证书请求文件" class="headerlink" title="移除证书请求文件"></a>移除证书请求文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -v /etc/gitlab/ssl/gitlab.domain.com.csr</span><br></pre></td></tr></table></figure>
<h4 id="设置文件权限"><a href="#设置文件权限" class="headerlink" title="设置文件权限"></a>设置文件权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 600 /etc/gitlab/ssl/gitlab.domain.com.*</span><br></pre></td></tr></table></figure>
<h2 id="gitlab-配置"><a href="#gitlab-配置" class="headerlink" title="gitlab 配置"></a>gitlab 配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb</span><br><span class="line">external_url &apos;https://gitlab.domain.com&apos;</span><br></pre></td></tr></table></figure>
<h4 id="gitlab-网站-https："><a href="#gitlab-网站-https：" class="headerlink" title="gitlab 网站 https："></a>gitlab 网站 https：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx[&apos;redirect_http_to_https&apos;] = true</span><br></pre></td></tr></table></figure>
<h4 id="gitlab-ci-网站-https："><a href="#gitlab-ci-网站-https：" class="headerlink" title="gitlab ci 网站 https："></a>gitlab ci 网站 https：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ci_nginx[&apos;redirect_http_to_https&apos;] = true</span><br></pre></td></tr></table></figure>
<h4 id="复制证书到-gitlab-目录："><a href="#复制证书到-gitlab-目录：" class="headerlink" title="复制证书到 gitlab 目录："></a>复制证书到 gitlab 目录：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/gitlab/ssl/gitlab.domain.com.crt /etc/gitlab/trusted-certs/</span><br></pre></td></tr></table></figure>
<h4 id="gitlab-重新配置-更新："><a href="#gitlab-重新配置-更新：" class="headerlink" title="gitlab 重新配置+更新："></a>gitlab 重新配置+更新：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul>
<li><strong>引申</strong><ul>
<li><a href="https://github.com/dunwu/OS" target="_blank" rel="noopener">操作系统、运维部署总结系列</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/frontend/mvc/angular/angular/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/frontend/mvc/angular/angular/" itemprop="url">Angular 教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Angular-教程"><a href="#Angular-教程" class="headerlink" title="Angular 教程"></a>Angular 教程</h1><blockquote>
<p><strong>Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#入门">入门</a></li>
<li><a href="#架构">架构</a></li>
<li><a href="#模块">模块</a><ul>
<li><a href="#ngmodule-元数据">@NgModule 元数据</a></li>
<li><a href="#ngmodule-和组件">NgModule 和组件</a></li>
<li><a href="#es2015-模块">ES2015 模块</a></li>
</ul>
</li>
<li><a href="#组件">组件</a><ul>
<li><a href="#组件的元数据">组件的元数据</a></li>
<li><a href="#模板与视图">模板与视图</a></li>
<li><a href="#模板语法">模板语法</a></li>
<li><a href="#数据绑定">数据绑定</a></li>
<li><a href="#管道">管道</a></li>
<li><a href="#指令">指令</a></li>
</ul>
</li>
<li><a href="#服务与依赖注入">服务与依赖注入</a><ul>
<li><a href="#依赖注入">依赖注入</a></li>
<li><a href="#提供服务">提供服务</a></li>
</ul>
</li>
<li><a href="#路由">路由</a></li>
<li><a href="#更多内容">更多内容</a></li>
</ul>
<!-- /TOC -->
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote>
<p>先决条件：Node.js</p>
</blockquote>
<p>（1）执行 npm install -g @angular/cli 安装 Angular CLI</p>
<p>（2）创建工作空间和初始应用</p>
<p>Angular 工作空间就是你开发应用的上下文环境。 每个工作空间包含一些供一个或多个项目使用的文件。 每个项目都是一组由应用、库或端到端（e2e）测试构成的文件。</p>
<p>执行命令 <code>ng new my-app</code>，根据提示选择需要的特性，Angular CLI 会安装必要的 Angular npm 包及其它依赖。</p>
<p>（3）启动开发服务器</p>
<p>执行下面的命令，ng serve 命令会自动打开浏览器，并访问 <a href="http://localhost:4200/" target="_blank" rel="noopener">http://localhost:4200/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">ng serve --open</span><br></pre></td></tr></table></figure>
<p><br><div align="center"><img src="https://angular.cn/generated/images/guide/cli-quickstart/app-works.png"></div><br></p>
<p>（4）添加组件</p>
<p>组件是 Angular 应用中的基本构造块。 它们在屏幕上显示数据、监听用户输入，并根据这些输入采取行动。</p>
<p>修改 ./src/app/app.component.ts</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.css'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">'My First Angular App!'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 ./src/app/app.component.css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#369</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">250%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><br><div align="center"><img src="https://angular.cn/generated/images/guide/cli-quickstart/my-first-app.png"></div><br></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><strong>Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。</strong></p>
<p>Angular 的基本构造块是 <strong>NgModule</strong>，它为<strong>组件</strong>提供了编译的上下文环境。 NgModule 会把相关的代码收集到一些功能集中。Angular 应用就是由一组 NgModule 定义出的。 应用至少会有一个用于引导应用的<strong>根模块</strong>，通常还会有很多<strong>特性模块</strong>。</p>
<ul>
<li>组件定义<strong>视图</strong>。视图是一组可见的屏幕元素，Angular 可以根据你的程序逻辑和数据来选择和修改它们。 每个应用都至少有一个根组件。</li>
<li>组件使用<strong>服务</strong>。服务会提供那些与视图不直接相关的功能。服务提供商可以作为<strong>依赖</strong>被<strong>注入</strong>到组件中， 这能让你的代码更加模块化、可复用，而且高效。</li>
</ul>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/front/mvc/angular/Angular架构.png"></div><br></p>
<p>组件和模板共同定义了 Angular 的视图。</p>
<ul>
<li>组件类上的装饰器为其添加了元数据，其中包括指向相关模板的指针。</li>
<li>组件模板中的指令和绑定标记会根据程序数据和程序逻辑修改这些视图。</li>
</ul>
<p>依赖注入器会为组件提供一些服务，比如路由器服务就能让你定义如何在视图之间导航。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Angular 应用是模块化的，它拥有自己的模块化系统，称作 <strong>NgModule</strong>。</p>
<p>一个 NgModule 就是一个容器，用于存放一些内聚的代码块，这些代码块专注于某个应用领域、某个工作流或一组紧密相关的功能。 它可以包含一些组件、服务或其它代码文件，其作用域由包含它们的 NgModule 定义。 它还可以导入一些由其它模块中导出的功能，并导出一些指定的功能供其它 NgModule 使用。</p>
<p>每个 Angular 应用都有一个根模块，通常命名为 AppModule，并位于一个名叫 app.module.ts 的文件中。根模块提供了用来启动应用的<strong>引导</strong>机制。 一个应用通常会包含很多功能模块。</p>
<p>把你的代码组织成一些清晰的功能模块，可以帮助管理复杂应用的开发工作并实现可复用性设计。 另外，这项技术还能让你获得惰性加载（也就是按需加载模块）的优点，以尽可能减小启动时需要加载的代码体积。</p>
<h3 id="NgModule-元数据"><a href="#NgModule-元数据" class="headerlink" title="@NgModule 元数据"></a>@NgModule 元数据</h3><p>NgModule 是一个带有 <code>@NgModule()</code> 装饰器的类。@NgModule() 装饰器是一个函数，它接受一个元数据对象，该对象的属性用来描述这个模块。其中最重要的属性如下。</p>
<ul>
<li>declarations（可声明对象表） —— 那些属于本 NgModule 的组件、指令、管道。</li>
<li>exports（导出表） —— 那些能在其它模块的组件模板中使用的可声明对象的子集。</li>
<li>imports（导入表） —— 那些导出了本模块中的组件模板所需的类的其它模块。</li>
<li>providers —— 本模块向全局服务中贡献的那些服务的创建器。 这些服务能被本应用中的任何部分使用。（你也可以在组件级别指定服务提供商，这通常是首选方式。）</li>
<li>bootstrap —— 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有根模块才应该设置这个 bootstrap 属性。</li>
</ul>
<p>一个简单的根 NgModule 定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [BrowserModule],</span><br><span class="line">  providers: [Logger],</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  exports: [AppComponent],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NgModule-和组件"><a href="#NgModule-和组件" class="headerlink" title="NgModule 和组件"></a>NgModule 和组件</h3><p>NgModule 为其中的组件提供了一个<strong>编译上下文环境</strong>。根模块总会有一个根组件，并在引导期间创建它。 但是，任何模块都能包含任意数量的其它组件，这些组件可以通过路由器加载，也可以通过模板创建。那些属于这个 NgModule 的组件会共享同一个编译上下文环境。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/front/mvc/angular/Angular编译上下文环境.png"></div><br></p>
<p>组件及其模板共同定义<strong>视图</strong>。组件还可以包含<strong>视图层级结构</strong>，它能让你定义任意复杂的屏幕区域，可以将其作为一个整体进行创建、修改和销毁。 一个视图层次结构中可以混合使用由不同 NgModule 中的组件定义的视图。 这种情况很常见，特别是对一些 UI 库来说。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/front/mvc/angular/Angular视图层级结构.png"></div><br></p>
<p>当你创建一个组件时，它直接与一个叫做<strong>宿主视图</strong>的视图关联起来。 宿主视图可以是视图层次结构的根，该视图层次结构可以包含一些<strong>内嵌视图</strong>，这些内嵌视图又是其它组件的宿主视图。 这些组件可以位于相同的 NgModule 中，也可以从其它 NgModule 中导入。 树中的视图可以嵌套到任意深度。</p>
<h3 id="ES2015-模块"><a href="#ES2015-模块" class="headerlink" title="ES2015 模块"></a>ES2015 模块</h3><p>NgModule 系统与 ES201）用来管理对象的模块系统不同，而且也没有直接关联。 这两种模块系统不同但互补。你可以使用它们来共同编写你的应用。</p>
<p>JavaScript 中，每个文件是一个模块，文件中定义的所有对象都从属于那个模块。 通过 export 关键字，模块可以把它的某些对象声明为公共的。 其它 JavaScript 模块可以使用 import 语句来访问这些公共对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件控制屏幕上被称为<strong>视图</strong>的一小片区域。</p>
<p>每个 Angular 应用都至少有一个组件，也就是<strong>根组件</strong>，它会把组件树和页面中的 DOM 连接起来。 每个组件都会定义一个类，其中包含应用的数据和逻辑，并与一个 HTML <strong>模板</strong>相关联，该模板定义了一个供目标环境下显示的视图。</p>
<h3 id="组件的元数据"><a href="#组件的元数据" class="headerlink" title="组件的元数据"></a>组件的元数据</h3><p>@Component() 装饰器表明紧随它的那个类是一个组件，并提供模板和该组件专属的元数据。</p>
<blockquote>
<p>@Component() 装饰器表明紧随它的那个类是一个组件，并提供模板和该组件专属的元数据。</p>
</blockquote>
<p>组件的元数据告诉 Angular 到哪里获取它需要的主要构造块，以创建和展示这个组件及其视图。 具体来说，它把一个模板（无论是直接内联在代码中还是引用的外部文件）和该组件关联起来。 该组件及其<strong>模板</strong>，共同描述了一个<strong>视图</strong>。</p>
<p>除了包含或指向模板之外，@Component 的元数据还会配置要如何在 HTML 中引用该组件，以及该组件需要哪些服务等等。</p>
<p>最常用的 @Component 配置选项：</p>
<ul>
<li><code>selector</code> —— 是一个 CSS 选择器，它会告诉 Angular，一旦在模板 HTML 中找到了这个选择器对应的标签，就创建并插入该组件的一个实例。 比如，如果应用的 HTML 中包含 <code>&lt;app-hero-list&gt;&lt;/app-hero-list&gt;</code>，Angular 就会在这些标签中插入一个 HeroListComponent 实例的视图。</li>
<li><code>templateUrl</code> —— 该组件的 HTML 模板文件相对于这个组件文件的地址。 另外，你还可以用 template 属性的值来提供内联的 HTML 模板。 这个模板定义了该组件的宿主视图。</li>
<li><code>providers</code> —— 当前组件所需的服务提供商的一个数组。在这个例子中，它告诉 Angular 该如何提供一个 HeroService 实例，以获取要显示的英雄列表。</li>
</ul>
<h3 id="模板与视图"><a href="#模板与视图" class="headerlink" title="模板与视图"></a>模板与视图</h3><p>你要通过组件的配套模板来定义其视图。模板就是一种 HTML，它会告诉 Angular 如何渲染该组件。</p>
<p>视图通常会分层次进行组织，让你能以 UI 分区或页面为单位进行修改、显示或隐藏。与组件直接关联的模板会定义该组件的<strong>宿主视图</strong>。该组件还可以定义一个<strong>带层次结构的视图</strong>，它包含一些<strong>内嵌的视图</strong>作为其它组件的宿主。</p>
<p>带层次结构的视图可以包含同一模块（NgModule）中组件的视图，也可以（而且经常会）包含其它模块中定义的组件的视图。</p>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>模板很像标准的 HTML，但是它还包含 Angular 的<a href="https://angular.cn/guide/template-syntax" target="_blank" rel="noopener">模板语法</a>，这些模板语法可以根据你的应用逻辑、应用状态和 DOM 数据来修改这些 HTML。 你的模板可以使用<strong>数据绑定</strong>来协调应用和 DOM 中的数据，使用<strong>管道</strong>在显示出来之前对其进行转换，使用<strong>指令</strong>来把程序逻辑应用到要显示的内容上。</p>
<p>模板示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hero List<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>Pick a hero from the list<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">"let hero of heroes"</span> (<span class="attr">click</span>)=<span class="string">"selectHero(hero)"</span>&gt;</span>&#123; &#123;hero.name&#125; &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">"selectedHero"</span> [<span class="attr">hero</span>]=<span class="string">"selectedHero"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：上例中，除了 HTML 元素外，还包括一些 Angular 的模板语法元素：</p>
<ul>
<li><code>*ngFor</code> 指令告诉 Angular 在一个列表上进行迭代。</li>
<li><code>{ {hero.name} }</code>、<code>(click)</code> 和 <code>[hero]</code> 把程序数据绑定到及绑定回 DOM，以响应用户的输入。更多内容参见稍后的数据绑定部分。</li>
<li>模板中的 <code>&lt;app-hero-detail&gt;</code> 标签是一个代表新组件 HeroDetailComponent 的元素。 HeroDetailComponent（代码略）定义了 HeroListComponent 的英雄详情子视图。 注意观察像这样的自定义组件是如何与原生 HTML 元素无缝的混合在一起的。</li>
</ul>
</blockquote>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>模板会把 HTML 和 Angular 的标记（markup）组合起来，这些标记可以在 HTML 元素显示出来之前修改它们。模板中的<strong>指令</strong>会提供程序逻辑，而<strong>绑定标记</strong>会把你应用中的数据和 DOM 连接在一起。 有两种类型的数据绑定：</p>
<ul>
<li><strong>事件绑定</strong>让你的应用可以通过更新应用的数据来响应目标环境下的用户输入。</li>
<li><strong>属性绑定</strong>让你将从应用数据中计算出来的值插入到 HTML 中。</li>
</ul>
<p>在视图显示出来之前，Angular 会先根据你的应用数据和逻辑来运行模板中的指令并解析绑定表达式，以修改 HTML 元素和 DOM。</p>
<p>Angular 支持<strong>双向数据绑定</strong>，这意味着 DOM 中发生的变化（比如用户的选择）同样可以反映回你的程序数据中。</p>
<p>下图显示了数据绑定标记的四种形式。每种形式都有一个方向 —— 从组件到 DOM、从 DOM 到组件或双向。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/front/mvc/angular/Angular数据绑定.png"></div><br></p>
<p>在双向绑定中，数据属性值通过属性绑定从组件流到输入框。用户的修改通过事件绑定流回组件，把属性值设置为最新的值。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>Angular 的管道可以让你在模板中声明显示值的转换逻辑。 带有 <code>@Pipe</code> 装饰器的类中会定义一个转换函数，用来把输入值转换成供视图显示用的输出值。</p>
<p>Angular 自带了很多管道，完整的列表参见 <a href="https://angular.cn/api?type=pipe" target="_blank" rel="noopener">Pipes API 列表</a>。你也可以自己定义一些新管道。</p>
<p>要在 HTML 模板中指定值的转换方式，请使用 <a href="https://angular.cn/guide/template-syntax#pipe" target="_blank" rel="noopener">管道操作符 (|)</a>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;interpolated_value | pipe_name&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>你可以把管道串联起来，把一个管道函数的输出送给另一个管道函数进行转换。 管道还能接收一些参数，来控制它该如何进行转换。比如，你可以把要使用的日期格式传给 <code>date</code> 管道：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Default format: output 'Jun 15, 2015' --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Today is &#123; &#123;today | date&#125; &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- fullDate format: output 'Monday, June 15, 2015' --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The date is &#123; &#123;today | date:'fullDate'&#125; &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shortTime format: output '9:43 AM' --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The time is &#123; &#123;today | date:'shortTime'&#125; &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>Angular 的模板是<strong>动态的</strong>。当 Angular 渲染它们的时候，会根据<strong>指令</strong>给出的指示对 DOM 进行转换。 指令就是一个带有 <code>@Directive()</code> 装饰器的类。</p>
<p>组件从技术角度上说就是一个指令，但是由于组件对 Angular 应用来说非常独特、非常重要，因此 Angular 专门定义了 <code>@Component()</code> 装饰器，它使用一些面向模板的特性扩展了 <code>@Directive()</code> 装饰器。</p>
<p>除组件外，还有两种指令：<strong>结构型指令</strong>和<strong>属性型指令</strong>。 Angular 本身定义了一系列这两种类型的指令，你也可以使用 <code>@Directive()</code> 装饰器来定义自己的指令。</p>
<p>像组件一样，指令的元数据把它所装饰的指令类和一个 <code>selector</code> 关联起来，<code>selector</code> 用来把该指令插入到 HTML 中。 在模板中，指令通常作为属性出现在元素标签上，可能仅仅作为名字出现，也可能作为赋值目标或绑定目标出现。</p>
<h4 id="结构型指令"><a href="#结构型指令" class="headerlink" title="结构型指令"></a>结构型指令</h4><p><strong>结构型指令</strong>通过添加、移除或替换 DOM 元素来修改布局。 这个范例模板使用了两个内置的结构型指令来为要渲染的视图添加程序逻辑：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">"let hero of heroes"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">"selectedHero"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>*ngFor</code> 是一个迭代器，它要求 Angular 为 heroes 列表中的每个 <code>&lt;li&gt;</code> 渲染出一个 <code>&lt;li&gt;</code>。</li>
<li><code>*ngIf</code> 是个条件语句，只有当选中的英雄存在时，它才会包含 HeroDetail 组件。</li>
</ul>
<h4 id="属性型指令"><a href="#属性型指令" class="headerlink" title="属性型指令"></a>属性型指令</h4><p><em>属性型指令</em>会修改现有元素的外观或行为。 在模板中，它们看起来就像普通的 HTML 属性一样，因此得名“属性型指令”。</p>
<p><code>ngModel</code> 指令就是属性型指令的一个例子，它实现了双向数据绑定。 <code>ngModel</code> 修改现有元素（一般是 <code>&lt;input&gt;</code>）的行为：设置其显示属性值，并响应 change 事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">"hero.name"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="服务与依赖注入"><a href="#服务与依赖注入" class="headerlink" title="服务与依赖注入"></a>服务与依赖注入</h2><p><strong>服务</strong>是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。</p>
<p>Angular 把组件和服务区分开，以提高模块性和复用性。 通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。</p>
<p>理想情况下，组件的工作只管用户体验，而不用顾及其它。 它应该提供用于数据绑定的属性和方法，以便作为视图（由模板渲染）和应用逻辑（通常包含一些<strong>模型</strong>的概念）的中介者。</p>
<p>组件应该把诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供商，你还可以让你的应用更具适应性。</p>
<p>Angular 不会<strong>强制</strong>你遵循这些原则。它只会通过<strong>依赖注入</strong>让你能更容易地将应用逻辑分解为服务，并让这些服务可用于各个组件中。</p>
<p>服务范例一：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  log(msg: any) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  error(msg: any) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  warn(msg: any) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务也可以依赖其它服务。服务范例二：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;</span><br><span class="line">  private heroes: Hero[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private backend: BackendService,</span><br><span class="line">    private logger: Logger) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  getHeroes() &#123;</span><br><span class="line">    <span class="keyword">this</span>.backend.getAll(Hero).then( <span class="function">(<span class="params">heroes: Hero[]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.log(<span class="string">`Fetched <span class="subst">$&#123;heroes.length&#125;</span> heroes.`</span>);</span><br><span class="line">      <span class="keyword">this</span>.heroes.push(...heroes); <span class="comment">// fill cache</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.heroes;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建<strong>服务</strong>类。服务类的定义通常紧跟在 <code>@Injectable()</code> 装饰器之后。该装饰器提供的元数据可以让你的服务作为<strong>依赖</strong>被<strong>注入</strong>到客户组件中。</p>
<ul>
<li><strong>注入器</strong>是主要的机制。你不用自己创建 Angular 注入器。Angular 会在启动过程中为你创建全应用级注入器以及所需的其它注入器。你不用自己创建注入器。</li>
<li>该注入器会创建依赖、维护一个<strong>容器</strong>来管理这些依赖，并尽可能复用它们。</li>
<li><strong>提供商</strong>是一个对象，用来告诉注入器应该如何获取或创建依赖。</li>
</ul>
<p>你的应用中所需的任何依赖，都必须使用该应用的注入器来注册一个提供商，以便注入器可以使用这个提供商来创建新实例。对于服务，该提供商通常就是服务类本身。</p>
<blockquote>
<p>依赖不一定是服务 —— 它还可能是函数或值。</p>
</blockquote>
<p>当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。 比如 <code>HeroListComponent</code> 的构造函数中需要 <code>HeroService</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(private service: HeroService) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在，注入器就会使用以前注册的服务提供商来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</p>
<p>当所有请求的服务已解析并返回时，Angular 可以用这些服务实例为参数，调用该组件的构造函数。</p>
<p><code>HeroService</code> 的注入过程如下所示：</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/front/mvc/angular/Angular依赖注入.png"></div><br></p>
<h3 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h3><p>对于要用到的任何服务，你必须至少注册一个<strong>提供商</strong>。服务可以在自己的元数据中把自己注册为提供商，这样可以让自己随处可用。或者，你也可以为特定的模块或组件注册提供商。要注册提供商，就要在服务的 <code>@Injectable()</code> 装饰器中提供它的元数据，或者在<code>@NgModule()</code> 或 <code>@Component()</code> 的元数据中。</p>
<ul>
<li>默认情况下，Angular CLI 的 <a href="https://angular.cn/cli/generate" target="_blank" rel="noopener"><code>ng generate service</code></a> 命令会在 <code>@Injectable()</code> 装饰器中提供元数据来把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供商：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当你在根一级提供服务时，Angular 会为 HeroService 创建一个单一的共享实例，并且把它注入到任何想要它的类中。这种在 <code>@Injectable</code> 元数据中注册提供商的方式还让 Angular 能够通过移除那些从未被用过的服务来优化大小。</p>
<ul>
<li>当你使用<a href="https://angular.cn/guide/architecture-modules" target="_blank" rel="noopener">特定的 NgModule</a> 注册提供商时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 <code>@NgModule()</code> 装饰器中的 <code>providers</code> 属性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content_copy@NgModule(&#123;   providers: [    BackendService,    Logger  ],  ... &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>当你在组件级注册提供商时，你会为该组件的每一个新实例提供该服务的一个新实例。 要在组件级注册，就要在 <code>@Component()</code> 元数据的 <code>providers</code> 属性中注册服务提供商。</li>
</ul>
<p>src/app/hero-list.component.ts (component providers)<code>content_copy@Component({ selector: &#39;app-hero-list&#39;, templateUrl: &#39;./hero-list.component.html&#39;, providers: [ HeroService ] })</code></p>
<p>要了解更多细节，请参见<a href="https://angular.cn/guide/dependency-injection" target="_blank" rel="noopener">依赖注入</a>一节。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>Angular 的 Router 模块提供了一个服务，它可以让你定义在应用的各个不同状态和视图层次结构之间导航时要使用的路径。 它的工作模型基于人们熟知的浏览器导航约定：</p>
<ul>
<li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li>
<li>在页面中点击链接，浏览器就会导航到一个新页面。</li>
<li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li>
</ul>
<p>不过路由器会把类似 URL 的路径映射到视图而不是页面。 当用户执行一个动作时（比如点击链接），本应该在浏览器中加载一个新页面，但是路由器拦截了浏览器的这个行为，并显示或隐藏一个视图层次结构。</p>
<p>如果路由器认为当前的应用状态需要某些特定的功能，而定义此功能的模块尚未加载，路由器就会按需<strong>惰性加载</strong>此模块。</p>
<p>路由器会根据你应用中的导航规则和数据状态来拦截 URL。 当用户点击按钮、选择下拉框或收到其它任何来源的输入时，你可以导航到一个新视图。 路由器会在浏览器的历史日志中记录这个动作，所以前进和后退按钮也能正常工作。</p>
<p>要定义导航规则，你就要把<strong>导航路径</strong>和你的组件关联起来。 路径（path）使用类似 URL 的语法来和程序数据整合在一起，就像模板语法会把你的视图和程序数据整合起来一样。 然后你就可以用程序逻辑来决定要显示或隐藏哪些视图，以根据你制定的访问规则对用户的输入做出响应。</p>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><blockquote>
<p>:package: 本文归档在 <a href="https://github.com/dunwu/frontend-tutorial" target="_blank" rel="noopener">我的前端技术教程系列：frontend-tutorial</a></p>
</blockquote>
<ul>
<li><strong>官方</strong><ul>
<li><a href="https://angular.io" target="_blank" rel="noopener">Angular 官网</a></li>
<li><a href="https://angular.cn/" target="_blank" rel="noopener">Angular 中文网</a></li>
<li><a href="https://github.com/angular/angular" target="_blank" rel="noopener">Angular Github</a></li>
<li><a href="https://github.com/angular/angular.js" target="_blank" rel="noopener">AngularJS Github</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/os/linux/ops/service/gitlab/gitlab-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/os/linux/ops/service/gitlab/gitlab-quickstart/" itemprop="url">Gitlab 快速教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Gitlab-快速教程"><a href="#Gitlab-快速教程" class="headerlink" title="Gitlab 快速教程"></a>Gitlab 快速教程</h1><blockquote>
<p>准备</p>
<p>Git - 如果不熟悉 Git ，可以先阅读：<a href="https://github.com/dunwu/OS/tree/master/docs/git" target="_blank" rel="noopener">Git 教程</a></p>
</blockquote>
<h2 id="创建你的-SSH-key"><a href="#创建你的-SSH-key" class="headerlink" title="创建你的 SSH key"></a>创建你的 SSH key</h2><ol>
<li><p>使用 Gitlab 的第一步是生成你自己的 SSH 密钥对（Github 也类似）。</p>
</li>
<li><p>登录 Gitlab</p>
</li>
<li><p>打开 <strong>Profile settings</strong>.</p>
</li>
</ol>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/gitlab-basics/img/profile_settings.png"></div><br></p>
<ol start="4">
<li>跳转到 <strong>SSH keys</strong> tab 页</li>
</ol>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/gitlab-basics/img/profile_settings_ssh_keys.png"></div><br></p>
<ol start="5">
<li>黏贴你的 SSH 公钥内容到 Key 文本框</li>
</ol>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/gitlab-basics/img/profile_settings_ssh_keys_paste_pub.png"></div><br></p>
<ol start="6">
<li>为了便于识别，你可以为其命名</li>
</ol>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/gitlab-basics/img/profile_settings_ssh_keys_title.png"></div><br></p>
<ol start="7">
<li>点击 <strong>Add key</strong> 将 SSH 公钥添加到 GitLab</li>
</ol>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/gitlab-basics/img/profile_settings_ssh_keys_single_key.png"></div><br></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20190131150658.png"></div><br></p>
<p>输入项目信息，点击 Create project 按钮，在 Gitlab 创建项目。</p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20190131150759.png"></div><br></p>
<h2 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h2><p>可以选择 SSH 或 HTTPS 方式克隆项目到本地（推荐 SSH）</p>
<p>拷贝项目地址，然后在本地执行 <code>git clone &lt;url&gt;</code></p>
<p><br><div align="center"><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1548919326929.png"></div><br></p>
<h2 id="创建-Issue"><a href="#创建-Issue" class="headerlink" title="创建 Issue"></a>创建 Issue</h2><p>依次点击 <strong>Project’s Dashboard</strong> &gt; <strong>Issues</strong> &gt; <strong>New Issue</strong> 可以新建 Issue</p>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/user/project/issues/img/new_issue_from_tracker_list.png"></div><br></p>
<p>在项目中直接添加 issue</p>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/user/project/issues/img/new_issue.png"></div><br></p>
<p>在未关闭 issue 中，点击 <strong>New Issue</strong> 添加 issue</p>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/user/project/issues/img/new_issue_from_open_issue.png"></div><br></p>
<p>通过项目面板添加 issue</p>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/user/project/issues/img/new_issue_from_projects_dashboard.png"></div><br></p>
<p>通过 issue 面板添加 issue</p>
<p><br><div align="center"><img src="https://docs.gitlab.com/ce/user/project/issues/img/new_issue_from_issue_board.png"></div><br></p>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul>
<li><strong>引申</strong><ul>
<li><a href="https://github.com/dunwu/OS" target="_blank" rel="noopener">操作系统、运维部署总结系列</a></li>
</ul>
</li>
<li><strong>引用</strong><ul>
<li><a href="https://about.gitlab.com/" target="_blank" rel="noopener">官网</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/programming/java/javaweb/architecture/网站的高性能架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/programming/java/javaweb/architecture/网站的高性能架构/" itemprop="url">网站的高性能架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网站的高性能架构"><a href="#网站的高性能架构" class="headerlink" title="网站的高性能架构"></a>网站的高性能架构</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-性能测试">1. 性能测试</a><ul>
<li><a href="#11-性能指标">1.1. 性能指标</a></li>
<li><a href="#12-性能测试方法">1.2. 性能测试方法</a></li>
<li><a href="#13-性能测试报告">1.3. 性能测试报告</a></li>
<li><a href="#14-性能优化策略">1.4. 性能优化策略</a></li>
</ul>
</li>
<li><a href="#2-前端性能优化">2. 前端性能优化</a><ul>
<li><a href="#21-浏览器访问优化">2.1. 浏览器访问优化</a></li>
<li><a href="#22-cdn">2.2. CDN</a></li>
<li><a href="#23-反向代理">2.3. 反向代理</a></li>
</ul>
</li>
<li><a href="#3-应用服务性能优化">3. 应用服务性能优化</a><ul>
<li><a href="#31-分布式缓存">3.1. 分布式缓存</a></li>
<li><a href="#32-异步操作">3.2. 异步操作</a></li>
<li><a href="#33-使用集群">3.3. 使用集群</a></li>
<li><a href="#34-代码优化">3.4. 代码优化</a></li>
</ul>
</li>
<li><a href="#4-存储性能优化">4. 存储性能优化</a><ul>
<li><a href="#41-机械键盘和固态硬盘">4.1. 机械键盘和固态硬盘</a></li>
<li><a href="#42-b数和-lsm-树">4.2. B+数和 LSM 树</a></li>
<li><a href="#43-raid-和-hdfs">4.3. RAID 和 HDFS</a></li>
</ul>
</li>
<li><a href="#5-资料">5. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-性能测试"><a href="#1-性能测试" class="headerlink" title="1. 性能测试"></a>1. 性能测试</h2><h3 id="1-1-性能指标"><a href="#1-1-性能指标" class="headerlink" title="1.1. 性能指标"></a>1.1. 性能指标</h3><p>网站性能测试的主要指标有：</p>
<ul>
<li><strong>响应时间</strong> - 响应时间(RT)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。</li>
<li><strong>并发数</strong> - 系统同时处理的请求、事务数。</li>
<li><strong>吞吐量</strong> - TPS(每秒事务数)、HPS(每秒 HTTP 请求数)、QPS(每秒查询数)。</li>
<li><strong>性能计数器</strong> - 系统负载、对象与线程数、内存使用、CPU 使用、磁盘与网络 IO 等。这些指标也是系统监控的重要参数。</li>
</ul>
<h3 id="1-2-性能测试方法"><a href="#1-2-性能测试方法" class="headerlink" title="1.2. 性能测试方法"></a>1.2. 性能测试方法</h3><ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
<h3 id="1-3-性能测试报告"><a href="#1-3-性能测试报告" class="headerlink" title="1.3. 性能测试报告"></a>1.3. 性能测试报告</h3><p>性能测试报告示例：</p>
<div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/3101171-3d533a36f42608a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h3 id="1-4-性能优化策略"><a href="#1-4-性能优化策略" class="headerlink" title="1.4. 性能优化策略"></a>1.4. 性能优化策略</h3><ol>
<li><strong>性能分析</strong> - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、CPU，可能是代码或架构设计不合理，又或者是系统资源确实不足。</li>
<li><strong>性能优化</strong> - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。</li>
</ol>
<h2 id="2-前端性能优化"><a href="#2-前端性能优化" class="headerlink" title="2. 前端性能优化"></a>2. 前端性能优化</h2><h3 id="2-1-浏览器访问优化"><a href="#2-1-浏览器访问优化" class="headerlink" title="2.1. 浏览器访问优化"></a>2.1. 浏览器访问优化</h3><ol>
<li><strong>减少 HTTP 请求</strong> - HTTP 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 HTTP 请求数可以有效提高访问性能。减少 HTTP 的主要手段是合并 Css、JavaScript、图片。</li>
<li><strong>使用浏览器缓存</strong> - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 HTTP 头中的 Cache-Control 和 Expires 属性，可以设定浏览器缓存。</li>
<li><strong>启用压缩</strong> - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 Html、Css、JavaScrip 进行压缩。</li>
<li><strong>CSS 放在页面最上面，JavaScript 放在页面最下面</strong> - 浏览器会在下载完全部的 Css 后才对整个页面进行渲染，所以最好的做法是将 Css 放在页面最上面，让浏览器尽快下载 Css；JavaScript 则相反，浏览器加载 JavaScript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 JavaScript 最好放在页面最下面。</li>
<li><strong>减少 Cookie 传输</strong> - Cookie 包含在 HTTP 每次的请求和响应中，太大的 Cookie 会严重影响数据传输。</li>
</ol>
<h3 id="2-2-CDN"><a href="#2-2-CDN" class="headerlink" title="2.2. CDN"></a>2.2. CDN</h3><p>CDN 一般缓存的是静态资源。</p>
<p>CDN 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/cdn.png" width="640"><br></div>

<h3 id="2-3-反向代理"><a href="#2-3-反向代理" class="headerlink" title="2.3. 反向代理"></a>2.3. 反向代理</h3><p>传统代理服务器位于浏览器一侧，代理浏览器将 HTTP 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 HTTP 请求。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/reverse-proxy.jpg" width="640"><br></div>

<p>反向代理服务器可以配置缓存功能加速 Web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。</p>
<p>反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。</p>
<p>因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 IP，达到保护网站安全的作用。</p>
<h2 id="3-应用服务性能优化"><a href="#3-应用服务性能优化" class="headerlink" title="3. 应用服务性能优化"></a>3. 应用服务性能优化</h2><h3 id="3-1-分布式缓存"><a href="#3-1-分布式缓存" class="headerlink" title="3.1. 分布式缓存"></a>3.1. 分布式缓存</h3><p>网站性能优化第一定律：优先考虑使用缓存优化性能。</p>
<h4 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h4><p>缓存指将数据存储在相对较高访问速度的存储介质中，以供系统处理。一方面缓存访问速度快，可以减少数据访问的时间，另一方面如果缓存的数据是经过计算处理得到的，那么被缓存的数据无需重复计算即可直接使用，因此缓存还起到减少计算时间的作用。</p>
<p>缓存的本质是一个内存 HASH 表。</p>
<p>缓存主要用来存放那些读写比很高、很少变化的数据，如商品的类目信息，热门词的搜索列表信息、热门商品信息等。</p>
<h4 id="合理使用缓存"><a href="#合理使用缓存" class="headerlink" title="合理使用缓存"></a>合理使用缓存</h4><p>缓存数据的选择：</p>
<ul>
<li>不要存储频繁修改的数据</li>
<li>不要存储非热点数据</li>
</ul>
<p>数据不一致和脏读：</p>
<ul>
<li>缓存有有效期，所以存在一定时间的数据不一致和脏读问题。如果不能接受，可以考虑使用数据更新立即更新缓存策略</li>
</ul>
<p>需要考虑缓存问题：缓存雪崩、缓存穿透、缓存预热</p>
<h3 id="3-2-异步操作"><a href="#3-2-异步操作" class="headerlink" title="3.2. 异步操作"></a>3.2. 异步操作</h3><p>异步处理一般是通过分布式消息队列的方式。</p>
<p>异步处理可以解决一下问题：</p>
<ul>
<li>异步处理</li>
<li>应用解耦</li>
<li>流量削锋</li>
<li>日志处理</li>
<li>消息通讯</li>
</ul>
<h3 id="3-3-使用集群"><a href="#3-3-使用集群" class="headerlink" title="3.3. 使用集群"></a>3.3. 使用集群</h3><p>在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。</p>
<h3 id="3-4-代码优化"><a href="#3-4-代码优化" class="headerlink" title="3.4. 代码优化"></a>3.4. 代码优化</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>从资源利用的角度看，使用多线程的原因主要有两个：IO 阻塞和多 CPU。</p>
<p>线程数并非越多越好，那么启动多少线程合适呢？</p>
<p>有个参考公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动线程数 = (任务执行时间 / (任务执行时间 - IO 等待时间)) * CPU 内核数</span><br></pre></td></tr></table></figure>
<p>最佳启动线程数和 CPU 内核数成正比，和 IO 阻塞时间成反比。如果任务都是 CPU 计算型任务，那么线程数最多不要超过 CPU 内核数，因为启动再多线程，CPU 也来不及调度；相反如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并罚赌，提高系统吞吐量。</p>
<h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><ul>
<li>将对象设计为无状态对象</li>
<li>使用局部对象</li>
<li>并发访问资源时使用锁</li>
</ul>
<h4 id="资源复用"><a href="#资源复用" class="headerlink" title="资源复用"></a>资源复用</h4><p>应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>根据具体场景，选择合适的数据结构。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>如果 Web 应用运行在 JVM 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。</p>
<h2 id="4-存储性能优化"><a href="#4-存储性能优化" class="headerlink" title="4. 存储性能优化"></a>4. 存储性能优化</h2><h3 id="4-1-机械键盘和固态硬盘"><a href="#4-1-机械键盘和固态硬盘" class="headerlink" title="4.1. 机械键盘和固态硬盘"></a>4.1. 机械键盘和固态硬盘</h3><p>考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。</p>
<h3 id="4-2-B-数和-LSM-树"><a href="#4-2-B-数和-LSM-树" class="headerlink" title="4.2. B+数和 LSM 树"></a>4.2. B+数和 LSM 树</h3><p>传统关系数据库的数据库索引一般都使用两级索引的 B+ 树结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，然后再进行一次数据文件读操作及一次数据文件写操作）。</p>
<p>由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。</p>
<p>许多 Nosql 数据库中的索引采用 LSM 树作为主要数据结构。LSM 树可视为一个 N 阶合并树。数据写操作都在内存中进行。在 LSM 树上进行一次数据更新不需要磁盘访问，速度远快于 B+ 树。</p>
<h3 id="4-3-RAID-和-HDFS"><a href="#4-3-RAID-和-HDFS" class="headerlink" title="4.3. RAID 和 HDFS"></a>4.3. RAID 和 HDFS</h3><p>HDFS(分布式文件系统) 更被大型网站所青睐。它可以配合 MapReduce 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 RAID 支持。</p>
<h2 id="5-资料"><a href="#5-资料" class="headerlink" title="5. 资料"></a>5. 资料</h2><ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2019/03/06/programming/java/javaweb/architecture/网站的高可用架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/06/programming/java/javaweb/architecture/网站的高可用架构/" itemprop="url">网站的高可用架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网站的高可用架构"><a href="#网站的高可用架构" class="headerlink" title="网站的高可用架构"></a>网站的高可用架构</h1><!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-网站可用性的度量">1. 网站可用性的度量</a></li>
<li><a href="#2-高可用的网站架构">2. 高可用的网站架构</a></li>
<li><a href="#3-高可用的应用">3. 高可用的应用</a><ul>
<li><a href="#31-通过负载均衡进行无状态服务的失效转移">3.1. 通过负载均衡进行无状态服务的失效转移</a></li>
<li><a href="#32-应用服务器集群的-session-管理">3.2. 应用服务器集群的 Session 管理</a></li>
</ul>
</li>
<li><a href="#4-高可用的服务">4. 高可用的服务</a></li>
<li><a href="#5-高可用的数据">5. 高可用的数据</a><ul>
<li><a href="#51-cap-原理">5.1. CAP 原理</a></li>
<li><a href="#52-数据备份">5.2. 数据备份</a></li>
<li><a href="#53-失效转移">5.3. 失效转移</a></li>
</ul>
</li>
<li><a href="#6-高可用网站的软件质量保证">6. 高可用网站的软件质量保证</a></li>
<li><a href="#7-网站监控">7. 网站监控</a></li>
<li><a href="#8-资料">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-网站可用性的度量"><a href="#1-网站可用性的度量" class="headerlink" title="1. 网站可用性的度量"></a>1. 网站可用性的度量</h2><p>网站不可用也被称作网站故障，业界通常用多个 9 来衡量网站的可用性。如 QQ 的可用性为 4 个 9，即 99.99% 可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网站不可用时间 = 故障修复时间点 - 故障发现时间点</span><br><span class="line">网站年度可用性指标 = (1 - 网站不可用时间/年度总时间) * 100%</span><br></pre></td></tr></table></figure>
<h2 id="2-高可用的网站架构"><a href="#2-高可用的网站架构" class="headerlink" title="2. 高可用的网站架构"></a>2. 高可用的网站架构</h2><p>大型网站的分层架构及服务器的分布式部署使得位于不同层次的服务器具有不同的可用性特点。关闭服务或服务器宕机时产生的影响也不相同，高可用的解决方案也差异甚大。</p>
<h2 id="3-高可用的应用"><a href="#3-高可用的应用" class="headerlink" title="3. 高可用的应用"></a>3. 高可用的应用</h2><h3 id="3-1-通过负载均衡进行无状态服务的失效转移"><a href="#3-1-通过负载均衡进行无状态服务的失效转移" class="headerlink" title="3.1. 通过负载均衡进行无状态服务的失效转移"></a>3.1. 通过负载均衡进行无状态服务的失效转移</h3><p>应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 <strong>无状态</strong> 性。</p>
<p>所谓的 <strong>无状态</strong> 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。</p>
<p>负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。</p>
<h3 id="3-2-应用服务器集群的-Session-管理"><a href="#3-2-应用服务器集群的-Session-管理" class="headerlink" title="3.2. 应用服务器集群的 Session 管理"></a>3.2. 应用服务器集群的 Session 管理</h3><p>应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。</p>
<p>Web 应用中将这些多次请求修改使用的上下文对象称作会话。单机情况下，Session 可由部署在服务器上的 Web 容器管理。</p>
<p>而在集群环境下，Session 管理有以下手段：</p>
<h4 id="Session-复制"><a href="#Session-复制" class="headerlink" title="Session 复制"></a>Session 复制</h4><p>Session 复制是指应用服务器开发 Web 容器的 Session 复制功能，在集群中的几台服务器之间同步 Session 对象。</p>
<p>这种方案很简单，但当集群规模较大时，集群服务间需要大量的通信来进行 Session 复制。</p>
<h4 id="Session-绑定"><a href="#Session-绑定" class="headerlink" title="Session 绑定"></a>Session 绑定</h4><p>可以利用负载均衡的源地址 Hash 算法实现，总是将来源于同一 IP 的请求分发到同一台服务器上。这样在整个会话期间，用户所有的请求都在同一台服务器上处理，即 Session 绑定到某台特定服务器上。这种方法又被称作会话粘滞。</p>
<p>但是这种策略不符合高可用的需求，因为一旦某台服务器宕机，那么该机器上的 Session 也就不复存在了。</p>
<h4 id="利用-Cookie-记录-Session"><a href="#利用-Cookie-记录-Session" class="headerlink" title="利用 Cookie 记录 Session"></a>利用 Cookie 记录 Session</h4><p>可以将 Session 记录在客户端（浏览器 Cookie），每次请求服务器时，将 Session 放在请求中发送给服务器，服务器处理完请求后再将修改过的 Session 响应给客户端。</p>
<p>这种策略的缺点是：Cookie 有大小限制，能记录的信息有限；每次请求响应都需要传输 Cookie，影响性能；如果用户关闭 Cookie，访问就不能工作。</p>
<h4 id="Session-服务器"><a href="#Session-服务器" class="headerlink" title="Session 服务器"></a>Session 服务器</h4><p>利用独立部署的 Session 服务器（集群）统一管理 Session，应用服务器每次读写 Session 时，都访问 Session 服务器。</p>
<p>实现 Session 服务器的一种简单方法时：利用分布式缓存、数据库等，在此基础上进行包装，使其符合 Session 的存储和访问要求。</p>
<h2 id="4-高可用的服务"><a href="#4-高可用的服务" class="headerlink" title="4. 高可用的服务"></a>4. 高可用的服务</h2><p>高可用的服务策略：</p>
<ul>
<li><strong>分级管理</strong> - 将服务根据业务重要性进行分级管理，并在服务部署上进行隔离。</li>
<li><strong>超时设置</strong> - 由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。</li>
<li><strong>异步调用</strong> - 对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免长时间等待服务响应结果。</li>
<li><strong>服务降级</strong> - 网站访问高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：拒绝服务和关闭服务。</li>
<li><strong>幂等性设计</strong> - 为了避免服务重复调用，可以通过设置编号的方式进行服务调用有效性校验，有效的操作才能继续执行。</li>
</ul>
<h2 id="5-高可用的数据"><a href="#5-高可用的数据" class="headerlink" title="5. 高可用的数据"></a>5. 高可用的数据</h2><h3 id="5-1-CAP-原理"><a href="#5-1-CAP-原理" class="headerlink" title="5.1. CAP 原理"></a>5.1. CAP 原理</h3><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/architecture/分布式理论-CAP.jpg" width="450"><br></div>

<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h4><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性指的是多个数据副本是否能保持一致的特性。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>数据一致性又可以分为以下几点：</p>
<ul>
<li>强一致性 - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。</li>
<li>最终一致性 - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。</li>
</ul>
<h4 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h4><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="5-2-数据备份"><a href="#5-2-数据备份" class="headerlink" title="5.2. 数据备份"></a>5.2. 数据备份</h3><ul>
<li>冷备份：定期将数据复制到某种存储介质。</li>
<li>热备份<ul>
<li>异步热备方式 - 异步方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。</li>
<li>同步热备方式 - 同步方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。</li>
</ul>
</li>
</ul>
<h3 id="5-3-失效转移"><a href="#5-3-失效转移" class="headerlink" title="5.3. 失效转移"></a>5.3. 失效转移</h3><h4 id="失效确认"><a href="#失效确认" class="headerlink" title="失效确认"></a>失效确认</h4><div align="center"><br><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/architecture/check-fail.png" width="500"><br></div>

<p>判断服务器宕机的手段有两种：心跳检测和访问失败报告。</p>
<p>对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。</p>
<h4 id="访问转移"><a href="#访问转移" class="headerlink" title="访问转移"></a>访问转移</h4><p>确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。</p>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。</p>
<h2 id="6-高可用网站的软件质量保证"><a href="#6-高可用网站的软件质量保证" class="headerlink" title="6. 高可用网站的软件质量保证"></a>6. 高可用网站的软件质量保证</h2><p>高可用网站的软件质量保证的手段：</p>
<ul>
<li>自动化发布</li>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制</li>
<li>灰度发布</li>
</ul>
<h2 id="7-网站监控"><a href="#7-网站监控" class="headerlink" title="7. 网站监控"></a>7. 网站监控</h2><ul>
<li>监控数据采集<ul>
<li>用户行为日志收集</li>
<li>服务器性能监控</li>
<li>运行数据报告</li>
</ul>
</li>
<li>监控管理<ul>
<li>系统报警</li>
<li>失效转移</li>
<li>自动优雅降级</li>
</ul>
</li>
</ul>
<h2 id="8-资料"><a href="#8-资料" class="headerlink" title="8. 资料"></a>8. 资料</h2><ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/blog/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">381</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">76</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dunwu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:forbreak@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
